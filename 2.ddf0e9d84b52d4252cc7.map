{"version":3,"file":"2.2cf768ad0d349c366218.chunk.js","sources":["webpack:///./~/asn1js/build/asn1.js?da50*","webpack:///./~/bytestreamjs/src/bytestream.js?2212*","webpack:///./~/pkijs/build/AccessDescription.js?ed68*","webpack:///./~/pkijs/build/Accuracy.js?46aa*","webpack:///./~/pkijs/build/AlgorithmIdentifier.js?88af*","webpack:///./~/pkijs/build/AltName.js?fdf4*","webpack:///./~/pkijs/build/Attribute.js?4386*","webpack:///./~/pkijs/build/AttributeCertificateV1.js?d153*","webpack:///./~/pkijs/build/AttributeCertificateV2.js?5f9e*","webpack:///./~/pkijs/build/AttributeTypeAndValue.js?452b*","webpack:///./~/pkijs/build/AuthenticatedSafe.js?837b*","webpack:///./~/pkijs/build/AuthorityKeyIdentifier.js?2f6b*","webpack:///./~/pkijs/build/BasicConstraints.js?67de*","webpack:///./~/pkijs/build/BasicOCSPResponse.js?7179*","webpack:///./~/pkijs/build/CAVersion.js?3fca*","webpack:///./~/pkijs/build/CRLBag.js?632a*","webpack:///./~/pkijs/build/CRLDistributionPoints.js?b226*","webpack:///./~/pkijs/build/CertBag.js?ea13*","webpack:///./~/pkijs/build/CertID.js?1edf*","webpack:///./~/pkijs/build/Certificate.js?caf9*","webpack:///./~/pkijs/build/CertificateChainValidationEngine.js?2467*","webpack:///./~/pkijs/build/CertificatePolicies.js?5d77*","webpack:///./~/pkijs/build/CertificateRevocationList.js?11e9*","webpack:///./~/pkijs/build/CertificateSet.js?4ac2*","webpack:///./~/pkijs/build/CertificateTemplate.js?dcf3*","webpack:///./~/pkijs/build/CertificationRequest.js?7135*","webpack:///./~/pkijs/build/ContentInfo.js?e646*","webpack:///./~/pkijs/build/CryptoEngine.js?5ebc*","webpack:///./~/pkijs/build/DigestInfo.js?3828*","webpack:///./~/pkijs/build/DistributionPoint.js?da00*","webpack:///./~/pkijs/build/ECCCMSSharedInfo.js?bdba*","webpack:///./~/pkijs/build/ECPrivateKey.js?1753*","webpack:///./~/pkijs/build/ECPublicKey.js?bbd5*","webpack:///./~/pkijs/build/EncapsulatedContentInfo.js?590d*","webpack:///./~/pkijs/build/EncryptedContentInfo.js?db08*","webpack:///./~/pkijs/build/EncryptedData.js?216e*","webpack:///./~/pkijs/build/EnvelopedData.js?74f9*","webpack:///./~/pkijs/build/ExtKeyUsage.js?a9c7*","webpack:///./~/pkijs/build/Extension.js?751b*","webpack:///./~/pkijs/build/Extensions.js?e14a*","webpack:///./~/pkijs/build/GeneralName.js?58e3*","webpack:///./~/pkijs/build/GeneralNames.js?d96c*","webpack:///./~/pkijs/build/GeneralSubtree.js?46f1*","webpack:///./~/pkijs/build/InfoAccess.js?b665*","webpack:///./~/pkijs/build/IssuerAndSerialNumber.js?0163*","webpack:///./~/pkijs/build/IssuingDistributionPoint.js?7dae*","webpack:///./~/pkijs/build/KEKIdentifier.js?3a01*","webpack:///./~/pkijs/build/KEKRecipientInfo.js?6bda*","webpack:///./~/pkijs/build/KeyAgreeRecipientIdentifier.js?3dcf*","webpack:///./~/pkijs/build/KeyAgreeRecipientInfo.js?8b88*","webpack:///./~/pkijs/build/KeyTransRecipientInfo.js?8a75*","webpack:///./~/pkijs/build/MacData.js?1604*","webpack:///./~/pkijs/build/MessageImprint.js?2891*","webpack:///./~/pkijs/build/NameConstraints.js?9054*","webpack:///./~/pkijs/build/OriginatorIdentifierOrKey.js?17b5*","webpack:///./~/pkijs/build/OriginatorInfo.js?60fc*","webpack:///./~/pkijs/build/OriginatorPublicKey.js?ea8c*","webpack:///./~/pkijs/build/OtherCertificateFormat.js?1eac*","webpack:///./~/pkijs/build/OtherKeyAttribute.js?8734*","webpack:///./~/pkijs/build/OtherPrimeInfo.js?ba03*","webpack:///./~/pkijs/build/OtherRecipientInfo.js?e2fb*","webpack:///./~/pkijs/build/OtherRevocationInfoFormat.js?575d*","webpack:///./~/pkijs/build/PBES2Params.js?3ebf*","webpack:///./~/pkijs/build/PBKDF2Params.js?d87f*","webpack:///./~/pkijs/build/PFX.js?1a74*","webpack:///./~/pkijs/build/PKCS8ShroudedKeyBag.js?f549*","webpack:///./~/pkijs/build/PasswordRecipientinfo.js?0283*","webpack:///./~/pkijs/build/PolicyConstraints.js?4f67*","webpack:///./~/pkijs/build/PolicyInformation.js?83c1*","webpack:///./~/pkijs/build/PolicyMapping.js?2abc*","webpack:///./~/pkijs/build/PolicyMappings.js?402f*","webpack:///./~/pkijs/build/PolicyQualifierInfo.js?3893*","webpack:///./~/pkijs/build/PrivateKeyInfo.js?b78a*","webpack:///./~/pkijs/build/PrivateKeyUsagePeriod.js?b126*","webpack:///./~/pkijs/build/PublicKeyInfo.js?c17a*","webpack:///./~/pkijs/build/QCStatements.js?8a9a*","webpack:///./~/pkijs/build/RSAESOAEPParams.js?b81c*","webpack:///./~/pkijs/build/RSAPrivateKey.js?e0fa*","webpack:///./~/pkijs/build/RSAPublicKey.js?b84f*","webpack:///./~/pkijs/build/RSASSAPSSParams.js?0dbc*","webpack:///./~/pkijs/build/RecipientEncryptedKey.js?254e*","webpack:///./~/pkijs/build/RecipientEncryptedKeys.js?c09f*","webpack:///./~/pkijs/build/RecipientIdentifier.js?bdd5*","webpack:///./~/pkijs/build/RecipientInfo.js?752f*","webpack:///./~/pkijs/build/RecipientKeyIdentifier.js?c70e*","webpack:///./~/pkijs/build/RelativeDistinguishedNames.js?845f*","webpack:///./~/pkijs/build/ResponseData.js?7bb4*","webpack:///./~/pkijs/build/RevocationInfoChoices.js?2d83*","webpack:///./~/pkijs/build/RevokedCertificate.js?b94f*","webpack:///./~/pkijs/build/SafeBag.js?8b3b*","webpack:///./~/pkijs/build/SafeContents.js?a6e9*","webpack:///./~/pkijs/build/SecretBag.js?cf3f*","webpack:///./~/pkijs/build/SignedAndUnsignedAttributes.js?56ce*","webpack:///./~/pkijs/build/SignedCertificateTimestampList.js?75be*","webpack:///./~/pkijs/build/SignedData.js?1944*","webpack:///./~/pkijs/build/SignerInfo.js?d5ae*","webpack:///./~/pkijs/build/SingleResponse.js?c8e1*","webpack:///./~/pkijs/build/SubjectDirectoryAttributes.js?87f5*","webpack:///./~/pkijs/build/TSTInfo.js?8ee4*","webpack:///./~/pkijs/build/Time.js?0602*","webpack:///./~/pkijs/build/common.js?5ae7*","webpack:///./~/pvtsutils/build/index.js?5825*","webpack:///./~/pvutils/src/utils.js?8140*","webpack:///./src/app/backend-api/identity-registry/autogen/model/Organization.ts?e7eb*","webpack:///./src/app/backend-api/identity-registry/autogen/model/Service.ts?20ea*","webpack:///./src/app/pages/administration/administration.component.ts","webpack:///./src/app/pages/administration/administration.module.ts","webpack:///./src/app/pages/administration/administration.routing.ts","webpack:///./src/app/pages/administration/approve-organizations/approve-organization.component.ts","webpack:///./src/app/pages/administration/approve-organizations/approve-organization.module.ts","webpack:///./src/app/pages/administration/approve-organizations/approve-organization.routing.ts","webpack:///./src/app/pages/administration/approve-organizations/components/approve-details/approve-details.component.ts","webpack:///./src/app/pages/administration/approve-organizations/components/approve-details/approve-details.html","webpack:///./src/app/pages/administration/approve-organizations/components/approve-details/approve-details.scss","webpack:///./src/app/pages/administration/approve-organizations/components/approve-list/approve-list.component.ts","webpack:///./src/app/pages/administration/approve-organizations/components/approve-list/approve-list.html","webpack:///./src/app/pages/org-identity-registry/services/view-models/ServiceViewModel.ts?73cd*","webpack:///./src/app/pages/org-service-registry/shared/services/sr-search-requests.service.ts?51f0*","webpack:///./src/app/pages/org-service-registry/shared/services/sr-view-model.service.ts?f923*","webpack:///./src/app/pages/shared/components/certificate-issue-new/certificate-issue-new.component.ts?34e7*","webpack:///./src/app/pages/shared/components/certificate-issue-new/certificate-issue-new.html?9ab8*","webpack:///./src/app/pages/shared/components/certificate-revoke/certificate-revoke.component.ts?4ec2*","webpack:///./src/app/pages/shared/components/certificate-revoke/certificate-revoke.html?6ce5*","webpack:///./src/app/pages/shared/components/certificates-table/certificates-table.component.ts?7f64*","webpack:///./src/app/pages/shared/components/certificates-table/certificates-table.html?947c*","webpack:///./src/app/pages/shared/components/certificates-table/certificates-table.scss?89ae*","webpack:///./src/app/pages/shared/components/designs-table/designs-table.component.ts?c517*","webpack:///./src/app/pages/shared/components/designs-table/designs-table.html?4ed3*","webpack:///./src/app/pages/shared/components/endorsed-by-list/endorsed-by-list.component.ts?2512*","webpack:///./src/app/pages/shared/components/endorsed-by-list/endorsed-by-list.html?a249*","webpack:///./src/app/pages/shared/components/instances-table/instances-table.component.ts?af65*","webpack:///./src/app/pages/shared/components/instances-table/instances-table.html?c375*","webpack:///./src/app/pages/shared/components/organizaton-details-table/organization-details-table.component.ts?2a4e*","webpack:///./src/app/pages/shared/components/organizaton-details-table/organization-details-table.html?0ef1*","webpack:///./src/app/pages/shared/components/service-details-view/service-details-view.component.ts?ff71*","webpack:///./src/app/pages/shared/components/service-details-view/service-details-view.html?e0c6*","webpack:///./src/app/pages/shared/components/service-registry-search/service-registry-search.component.ts?c1a4*","webpack:///./src/app/pages/shared/components/service-registry-search/service-registry-search.html?4ed3*","webpack:///./src/app/pages/shared/components/service-registry-search/service-registry-search.scss?370b*","webpack:///./src/app/pages/shared/components/services-table/services-table.component.ts?dc51*","webpack:///./src/app/pages/shared/components/services-table/services-table.html?441e*","webpack:///./src/app/pages/shared/components/specifications-table/specifications-table.component.ts?6ac4*","webpack:///./src/app/pages/shared/components/specifications-table/specifications-table.html?334b*","webpack:///./src/app/pages/shared/services/organization-view-model.service.ts?5d8c*","webpack:///./src/app/pages/shared/shared.module.ts?42d6*"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromBER = fromBER;\nexports.compareSchema = compareSchema;\nexports.verifySchema = verifySchema;\nexports.fromJSON = fromJSON;\nexports.RawData = exports.Repeated = exports.Any = exports.Choice = exports.TIME = exports.Duration = exports.DateTime = exports.TimeOfDay = exports.DATE = exports.GeneralizedTime = exports.UTCTime = exports.CharacterString = exports.GeneralString = exports.VisibleString = exports.GraphicString = exports.IA5String = exports.VideotexString = exports.TeletexString = exports.PrintableString = exports.NumericString = exports.UniversalString = exports.BmpString = exports.RelativeObjectIdentifier = exports.Utf8String = exports.ObjectIdentifier = exports.Enumerated = exports.Integer = exports.BitString = exports.OctetString = exports.Null = exports.Set = exports.Sequence = exports.Boolean = exports.EndOfContent = exports.Constructed = exports.Primitive = exports.BaseBlock = exports.ValueBlock = exports.HexBlock = void 0;\n\nvar _pvutils = require(\"pvutils\");\n\n/* eslint-disable indent */\n\n/*\r\n * Copyright (c) 2016-2018, Peculiar Ventures\r\n * All rights reserved.\r\n *\r\n * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of the copyright holder nor the names of its contributors\r\n *    may be used to endorse or promote products derived from this software without\r\n *    specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\r\n * OF SUCH DAMAGE.\r\n *\r\n */\n//**************************************************************************************\n//**************************************************************************************\n//region Declaration of global variables\n//**************************************************************************************\nconst powers2 = [new Uint8Array([1])];\nconst digitsString = \"0123456789\"; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration for \"LocalBaseBlock\" class\n//**************************************************************************************\n\n/**\r\n * Class used as a base block for all remaining ASN.1 classes\r\n * @typedef LocalBaseBlock\r\n * @interface\r\n * @property {number} blockLength\r\n * @property {string} error\r\n * @property {Array.<string>} warnings\r\n * @property {ArrayBuffer} valueBeforeDecode\r\n */\n\nclass LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBaseBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueBeforeDecode]\r\n   */\n  constructor(parameters = {}) {\n    /**\r\n     * @type {number} blockLength\r\n     */\n    this.blockLength = (0, _pvutils.getParametersValue)(parameters, \"blockLength\", 0);\n    /**\r\n     * @type {string} error\r\n     */\n\n    this.error = (0, _pvutils.getParametersValue)(parameters, \"error\", \"\");\n    /**\r\n     * @type {Array.<string>} warnings\r\n     */\n\n    this.warnings = (0, _pvutils.getParametersValue)(parameters, \"warnings\", []); //noinspection JSCheckFunctionSignatures\n\n    /**\r\n     * @type {ArrayBuffer} valueBeforeDecode\r\n     */\n\n    if (\"valueBeforeDecode\" in parameters) this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);else this.valueBeforeDecode = new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"baseBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    return {\n      blockName: this.constructor.blockName(),\n      blockLength: this.blockLength,\n      error: this.error,\n      warnings: this.warnings,\n      valueBeforeDecode: (0, _pvutils.bufferToHexCodes)(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Description for \"HexBlock\" class\n//**************************************************************************************\n\n/**\r\n * Class used as a base block for all remaining ASN.1 classes\r\n * @extends LocalBaseBlock\r\n * @typedef HexBlock\r\n * @property {number} blockLength\r\n * @property {string} error\r\n * @property {Array.<string>} warnings\r\n * @property {ArrayBuffer} valueBeforeDecode\r\n * @property {boolean} isHexOnly\r\n * @property {ArrayBuffer} valueHex\r\n */\n//noinspection JSUnusedLocalSymbols\n\n\nconst HexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass {\n  //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Constructor for \"HexBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    /**\r\n     * @type {boolean}\r\n     */\n\n    this.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", false);\n    /**\r\n     * @type {ArrayBuffer}\r\n     */\n\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"hexBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Copy input buffer to internal buffer\n\n\n    this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength); //endregion\n\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    if (this.isHexOnly !== true) {\n      this.error = \"Flag \\\"isHexOnly\\\" is not set, abort\";\n      return new ArrayBuffer(0);\n    }\n\n    if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength); //noinspection JSCheckFunctionSignatures\n\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n}; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of identification block class\n//**************************************************************************************\n\n\nexports.HexBlock = HexBlock;\n\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBaseBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Object} [idBlock]\r\n   */\n  constructor(parameters = {}) {\n    super();\n\n    if (\"idBlock\" in parameters) {\n      //region Properties from hexBlock class\n      this.isHexOnly = (0, _pvutils.getParametersValue)(parameters.idBlock, \"isHexOnly\", false);\n      this.valueHex = (0, _pvutils.getParametersValue)(parameters.idBlock, \"valueHex\", new ArrayBuffer(0)); //endregion\n\n      this.tagClass = (0, _pvutils.getParametersValue)(parameters.idBlock, \"tagClass\", -1);\n      this.tagNumber = (0, _pvutils.getParametersValue)(parameters.idBlock, \"tagNumber\", -1);\n      this.isConstructed = (0, _pvutils.getParametersValue)(parameters.idBlock, \"isConstructed\", false);\n    } else {\n      this.tagClass = -1;\n      this.tagNumber = -1;\n      this.isConstructed = false;\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"identificationBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let firstOctet = 0;\n    let retBuf;\n    let retView; //endregion\n\n    switch (this.tagClass) {\n      case 1:\n        firstOctet |= 0x00; // UNIVERSAL\n\n        break;\n\n      case 2:\n        firstOctet |= 0x40; // APPLICATION\n\n        break;\n\n      case 3:\n        firstOctet |= 0x80; // CONTEXT-SPECIFIC\n\n        break;\n\n      case 4:\n        firstOctet |= 0xC0; // PRIVATE\n\n        break;\n\n      default:\n        this.error = \"Unknown tag class\";\n        return new ArrayBuffer(0);\n    }\n\n    if (this.isConstructed) firstOctet |= 0x20;\n\n    if (this.tagNumber < 31 && !this.isHexOnly) {\n      retBuf = new ArrayBuffer(1);\n      retView = new Uint8Array(retBuf);\n\n      if (!sizeOnly) {\n        let number = this.tagNumber;\n        number &= 0x1F;\n        firstOctet |= number;\n        retView[0] = firstOctet;\n      }\n\n      return retBuf;\n    }\n\n    if (this.isHexOnly === false) {\n      const encodedBuf = (0, _pvutils.utilToBase)(this.tagNumber, 7);\n      const encodedView = new Uint8Array(encodedBuf);\n      const size = encodedBuf.byteLength;\n      retBuf = new ArrayBuffer(size + 1);\n      retView = new Uint8Array(retBuf);\n      retView[0] = firstOctet | 0x1F;\n\n      if (!sizeOnly) {\n        for (let i = 0; i < size - 1; i++) retView[i + 1] = encodedView[i] | 0x80;\n\n        retView[size] = encodedView[size - 1];\n      }\n\n      return retBuf;\n    }\n\n    retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n    retView = new Uint8Array(retBuf);\n    retView[0] = firstOctet | 0x1F;\n\n    if (sizeOnly === false) {\n      const curView = new Uint8Array(this.valueHex);\n\n      for (let i = 0; i < curView.length - 1; i++) retView[i + 1] = curView[i] | 0x80;\n\n      retView[this.valueHex.byteLength] = curView[curView.length - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.error = \"Zero buffer length\";\n      return -1;\n    } //endregion\n    //region Find tag class\n\n\n    const tagClassMask = intBuffer[0] & 0xC0;\n\n    switch (tagClassMask) {\n      case 0x00:\n        this.tagClass = 1; // UNIVERSAL\n\n        break;\n\n      case 0x40:\n        this.tagClass = 2; // APPLICATION\n\n        break;\n\n      case 0x80:\n        this.tagClass = 3; // CONTEXT-SPECIFIC\n\n        break;\n\n      case 0xC0:\n        this.tagClass = 4; // PRIVATE\n\n        break;\n\n      default:\n        this.error = \"Unknown tag class\";\n        return -1;\n    } //endregion\n    //region Find it's constructed or not\n\n\n    this.isConstructed = (intBuffer[0] & 0x20) === 0x20; //endregion\n    //region Find tag number\n\n    this.isHexOnly = false;\n    const tagNumberMask = intBuffer[0] & 0x1F; //region Simple case (tag number < 31)\n\n    if (tagNumberMask !== 0x1F) {\n      this.tagNumber = tagNumberMask;\n      this.blockLength = 1;\n    } //endregion\n    //region Tag number bigger or equal to 31\n    else {\n        let count = 1;\n        this.valueHex = new ArrayBuffer(255);\n        let tagNumberBufferMaxLength = 255;\n        let intTagNumberBuffer = new Uint8Array(this.valueHex); //noinspection JSBitwiseOperatorUsage\n\n        while (intBuffer[count] & 0x80) {\n          intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n          count++;\n\n          if (count >= intBuffer.length) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n          } //region In case if tag number length is greater than 255 bytes (rare but possible case)\n\n\n          if (count === tagNumberBufferMaxLength) {\n            tagNumberBufferMaxLength += 255;\n            const tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);\n            const tempBufferView = new Uint8Array(tempBuffer);\n\n            for (let i = 0; i < intTagNumberBuffer.length; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n            this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);\n            intTagNumberBuffer = new Uint8Array(this.valueHex);\n          } //endregion\n\n        }\n\n        this.blockLength = count + 1;\n        intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer\n        //region Cut buffer\n\n        const tempBuffer = new ArrayBuffer(count);\n        const tempBufferView = new Uint8Array(tempBuffer);\n\n        for (let i = 0; i < count; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n        this.valueHex = new ArrayBuffer(count);\n        intTagNumberBuffer = new Uint8Array(this.valueHex);\n        intTagNumberBuffer.set(tempBufferView); //endregion\n        //region Try to convert long tag number to short form\n\n        if (this.blockLength <= 9) this.tagNumber = (0, _pvutils.utilFromBase)(intTagNumberBuffer, 7);else {\n          this.isHexOnly = true;\n          this.warnings.push(\"Tag too long, represented as hex-coded\");\n        } //endregion\n      } //endregion\n    //endregion\n    //region Check if constructed encoding was using for primitive type\n\n\n    if (this.tagClass === 1 && this.isConstructed) {\n      switch (this.tagNumber) {\n        case 1: // Boolean\n\n        case 2: // REAL\n\n        case 5: // Null\n\n        case 6: // OBJECT IDENTIFIER\n\n        case 9: // REAL\n\n        case 13: // RELATIVE OBJECT IDENTIFIER\n\n        case 14: // Time\n\n        case 23:\n        case 24:\n        case 31:\n        case 32:\n        case 33:\n        case 34:\n          this.error = \"Constructed encoding used for primitive type\";\n          return -1;\n\n        default:\n      }\n    } //endregion\n\n\n    return inputOffset + this.blockLength; // Return current offset in input buffer\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName: string,\r\n   *  tagClass: number,\r\n   *  tagNumber: number,\r\n   *  isConstructed: boolean,\r\n   *  isHexOnly: boolean,\r\n   *  valueHex: ArrayBuffer,\r\n   *  blockLength: number,\r\n   *  error: string, warnings: Array.<string>,\r\n   *  valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.tagClass = this.tagClass;\n    object.tagNumber = this.tagNumber;\n    object.isConstructed = this.isConstructed;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of length block class\n//**************************************************************************************\n\n\nclass LocalLengthBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalLengthBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Object} [lenBlock]\r\n   */\n  constructor(parameters = {}) {\n    super();\n\n    if (\"lenBlock\" in parameters) {\n      this.isIndefiniteForm = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"isIndefiniteForm\", false);\n      this.longFormUsed = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"longFormUsed\", false);\n      this.length = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"length\", 0);\n    } else {\n      this.isIndefiniteForm = false;\n      this.longFormUsed = false;\n      this.length = 0;\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"lengthBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.error = \"Zero buffer length\";\n      return -1;\n    }\n\n    if (intBuffer[0] === 0xFF) {\n      this.error = \"Length block 0xFF is reserved by standard\";\n      return -1;\n    } //endregion\n    //region Check for length form type\n\n\n    this.isIndefiniteForm = intBuffer[0] === 0x80; //endregion\n    //region Stop working in case of indefinite length form\n\n    if (this.isIndefiniteForm === true) {\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    } //endregion\n    //region Check is long form of length encoding using\n\n\n    this.longFormUsed = !!(intBuffer[0] & 0x80); //endregion\n    //region Stop working in case of short form of length value\n\n    if (this.longFormUsed === false) {\n      this.length = intBuffer[0];\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    } //endregion\n    //region Calculate length value in case of long form\n\n\n    const count = intBuffer[0] & 0x7F;\n\n    if (count > 8) // Too big length value\n      {\n        this.error = \"Too big integer\";\n        return -1;\n      }\n\n    if (count + 1 > intBuffer.length) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    const lengthBufferView = new Uint8Array(count);\n\n    for (let i = 0; i < count; i++) lengthBufferView[i] = intBuffer[i + 1];\n\n    if (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n    this.length = (0, _pvutils.utilFromBase)(lengthBufferView, 8);\n    if (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unneccesary usage of long length form\");\n    this.blockLength = count + 1; //endregion\n\n    return inputOffset + this.blockLength; // Return current offset in input buffer\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.length > 127) this.longFormUsed = true;\n\n    if (this.isIndefiniteForm) {\n      retBuf = new ArrayBuffer(1);\n\n      if (sizeOnly === false) {\n        retView = new Uint8Array(retBuf);\n        retView[0] = 0x80;\n      }\n\n      return retBuf;\n    }\n\n    if (this.longFormUsed === true) {\n      const encodedBuf = (0, _pvutils.utilToBase)(this.length, 8);\n\n      if (encodedBuf.byteLength > 127) {\n        this.error = \"Too big length\";\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n      if (sizeOnly === true) return retBuf;\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n      retView[0] = encodedBuf.byteLength | 0x80;\n\n      for (let i = 0; i < encodedBuf.byteLength; i++) retView[i + 1] = encodedView[i];\n\n      return retBuf;\n    }\n\n    retBuf = new ArrayBuffer(1);\n\n    if (sizeOnly === false) {\n      retView = new Uint8Array(retBuf);\n      retView[0] = this.length;\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.isIndefiniteForm = this.isIndefiniteForm;\n    object.longFormUsed = this.longFormUsed;\n    object.length = this.length;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of value block class\n//**************************************************************************************\n\n\nclass ValueBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"ValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"valueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Throw an exception for a function which needs to be specified in extended classes\n    throw TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\"); //endregion\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Throw an exception for a function which needs to be specified in extended classes\n    throw TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\"); //endregion\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic ASN.1 block class\n//**************************************************************************************\n\n\nexports.ValueBlock = ValueBlock;\n\nclass BaseBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"BaseBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Object} [primitiveSchema]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   * @param valueBlockType Type of value block\r\n   */\n  constructor(parameters = {}, valueBlockType = ValueBlock) {\n    super(parameters);\n    if (\"name\" in parameters) this.name = parameters.name;\n    if (\"optional\" in parameters) this.optional = parameters.optional;\n    if (\"primitiveSchema\" in parameters) this.primitiveSchema = parameters.primitiveSchema;\n    this.idBlock = new LocalIdentificationBlock(parameters);\n    this.lenBlock = new LocalLengthBlock(parameters);\n    this.valueBlock = new valueBlockType(parameters);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BaseBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf;\n    const idBlockBuf = this.idBlock.toBER(sizeOnly);\n    const valueBlockSizeBuf = this.valueBlock.toBER(true);\n    this.lenBlock.length = valueBlockSizeBuf.byteLength;\n    const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n    retBuf = (0, _pvutils.utilConcatBuf)(idBlockBuf, lenBlockBuf);\n    let valueBlockBuf;\n    if (sizeOnly === false) valueBlockBuf = this.valueBlock.toBER(sizeOnly);else valueBlockBuf = new ArrayBuffer(this.lenBlock.length);\n    retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBlockBuf);\n\n    if (this.lenBlock.isIndefiniteForm === true) {\n      const indefBuf = new ArrayBuffer(2);\n\n      if (sizeOnly === false) {\n        const indefView = new Uint8Array(indefBuf);\n        indefView[0] = 0x00;\n        indefView[1] = 0x00;\n      }\n\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, indefBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.idBlock = this.idBlock.toJSON();\n    object.lenBlock = this.lenBlock.toJSON();\n    object.valueBlock = this.valueBlock.toJSON();\n    if (\"name\" in this) object.name = this.name;\n    if (\"optional\" in this) object.optional = this.optional;\n    if (\"primitiveSchema\" in this) object.primitiveSchema = this.primitiveSchema.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all PRIMITIVE types\n//**************************************************************************************\n\n\nexports.BaseBlock = BaseBlock;\n\nclass LocalPrimitiveValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalPrimitiveValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueBeforeDecode]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters); //region Variables from \"hexBlock\" class\n\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n    this.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", true); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Copy input buffer into internal buffer\n\n\n    this.valueHex = new ArrayBuffer(intBuffer.length);\n    const valueHexView = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < intBuffer.length; i++) valueHexView[i] = intBuffer[i]; //endregion\n\n\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"PrimitiveValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    object.isHexOnly = this.isHexOnly;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Primitive extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Primitive\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalPrimitiveValueBlock);\n    this.idBlock.isConstructed = false;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"PRIMITIVE\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all CONSTRUCTED types\n//**************************************************************************************\n\n\nexports.Primitive = Primitive;\n\nclass LocalConstructedValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalConstructedValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", []);\n    this.isIndefiniteForm = (0, _pvutils.getParametersValue)(parameters, \"isIndefiniteForm\", false);\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Store initial offset and length\n    const initialOffset = inputOffset;\n    const initialLength = inputLength; //endregion\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Aux function\n\n\n    function checkLen(indefiniteLength, length) {\n      if (indefiniteLength === true) return 1;\n      return length;\n    } //endregion\n\n\n    let currentOffset = inputOffset;\n\n    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\n      const returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);\n\n      if (returnObject.offset === -1) {\n        this.error = returnObject.result.error;\n        this.warnings.concat(returnObject.result.warnings);\n        return -1;\n      }\n\n      currentOffset = returnObject.offset;\n      this.blockLength += returnObject.result.blockLength;\n      inputLength -= returnObject.result.blockLength;\n      this.value.push(returnObject.result);\n      if (this.isIndefiniteForm === true && returnObject.result.constructor.blockName() === EndOfContent.blockName()) break;\n    }\n\n    if (this.isIndefiniteForm === true) {\n      if (this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName()) this.value.pop();else this.warnings.push(\"No EndOfContent block encoded\");\n    } //region Copy \"inputBuffer\" to \"valueBeforeDecode\"\n\n\n    this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength); //endregion\n\n    return currentOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"ConstructedValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.isIndefiniteForm = this.isIndefiniteForm;\n    object.value = [];\n\n    for (let i = 0; i < this.value.length; i++) object.value.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Constructed extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Constructed\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalConstructedValueBlock);\n    this.idBlock.isConstructed = true;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"CONSTRUCTED\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 EndOfContent type class\n//**************************************************************************************\n\n\nexports.Constructed = Constructed;\n\nclass LocalEndOfContentValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalEndOfContentValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region There is no \"value block\" for EndOfContent type and we need to return the same offset\n    return inputOffset; //endregion\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"EndOfContentValueBlock\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass EndOfContent extends BaseBlock {\n  //**********************************************************************************\n  constructor(paramaters = {}) {\n    super(paramaters, LocalEndOfContentValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 0; // EndOfContent\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"EndOfContent\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Boolean type class\n//**************************************************************************************\n\n\nexports.EndOfContent = EndOfContent;\n\nclass LocalBooleanValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBooleanValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", false);\n    this.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", false);\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else {\n      this.valueHex = new ArrayBuffer(1);\n\n      if (this.value === true) {\n        const view = new Uint8Array(this.valueHex);\n        view[0] = 0xFF;\n      }\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n\n    if (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n    this.isHexOnly = true; //region Copy input buffer to internal array\n\n    this.valueHex = new ArrayBuffer(intBuffer.length);\n    const view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < intBuffer.length; i++) view[i] = intBuffer[i]; //endregion\n\n\n    if (_pvutils.utilDecodeTC.call(this) !== 0) this.value = true;else this.value = false;\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return this.valueHex;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BooleanValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Boolean extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Boolean\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBooleanValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 1; // Boolean\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Boolean\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Sequence and Set type classes\n//**************************************************************************************\n\n\nexports.Boolean = Boolean;\n\nclass Sequence extends Constructed {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Sequence\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 16; // Sequence\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Sequence\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.Sequence = Sequence;\n\nclass Set extends Constructed {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Set\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 17; // Set\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Set\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Null type class\n//**************************************************************************************\n\n\nexports.Set = Set;\n\nclass Null extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Null\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBaseBlock); // We will not have a call to \"Null value block\" because of specified \"fromBER\" and \"toBER\" functions\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 5; // Null\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Null\";\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    this.blockLength += inputLength;\n\n    if (inputOffset + inputLength > inputBuffer.byteLength) {\n      this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n      return -1;\n    }\n\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    const retBuf = new ArrayBuffer(2);\n    if (sizeOnly === true) return retBuf;\n    const retView = new Uint8Array(retBuf);\n    retView[0] = 0x05;\n    retView[1] = 0x00;\n    return retBuf;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 OctetString type class\n//**************************************************************************************\n\n\nexports.Null = Null;\n\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalOctetStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isConstructed = (0, _pvutils.getParametersValue)(parameters, \"isConstructed\", false);\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = 0;\n\n    if (this.isConstructed === true) {\n      this.isHexOnly = false;\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1) return resultOffset;\n\n      for (let i = 0; i < this.value.length; i++) {\n        const currentBlockName = this.value[i].constructor.blockName();\n\n        if (currentBlockName === EndOfContent.blockName()) {\n          if (this.isIndefiniteForm === true) break;else {\n            this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n            return -1;\n          }\n        }\n\n        if (currentBlockName !== OctetString.blockName()) {\n          this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n          return -1;\n        }\n      }\n    } else {\n      this.isHexOnly = true;\n      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n      this.blockLength = inputLength;\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n    let retBuf = new ArrayBuffer(this.valueHex.byteLength);\n    if (sizeOnly === true) return retBuf;\n    if (this.valueHex.byteLength === 0) return retBuf;\n    retBuf = this.valueHex.slice(0);\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"OctetStringValueBlock\";\n  } //**********************************************************************************\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.isConstructed = this.isConstructed;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass OctetString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"OctetString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalOctetStringValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 4; // OctetString\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm; //region Ability to encode empty OCTET STRING\n\n    if (inputLength === 0) {\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      return inputOffset;\n    } //endregion\n\n\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"OctetString\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Checking that two OCTETSTRINGs are equal\r\n   * @param {OctetString} octetString\r\n   */\n\n\n  isEqual(octetString) {\n    //region Check input type\n    if (octetString instanceof OctetString === false) return false; //endregion\n    //region Compare two JSON strings\n\n    if (JSON.stringify(this) !== JSON.stringify(octetString)) return false; //endregion\n\n    return true;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 BitString type class\n//**************************************************************************************\n\n\nexports.OctetString = OctetString;\n\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBitStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.unusedBits = (0, _pvutils.getParametersValue)(parameters, \"unusedBits\", 0);\n    this.isConstructed = (0, _pvutils.getParametersValue)(parameters, \"isConstructed\", false);\n    this.blockLength = this.valueHex.byteLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Ability to decode zero-length BitString value\n    if (inputLength === 0) return inputOffset; //endregion\n\n    let resultOffset = -1; //region If the BISTRING supposed to be a constructed value\n\n    if (this.isConstructed === true) {\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1) return resultOffset;\n\n      for (let i = 0; i < this.value.length; i++) {\n        const currentBlockName = this.value[i].constructor.blockName();\n\n        if (currentBlockName === EndOfContent.blockName()) {\n          if (this.isIndefiniteForm === true) break;else {\n            this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n            return -1;\n          }\n        }\n\n        if (currentBlockName !== BitString.blockName()) {\n          this.error = \"BIT STRING may consists of BIT STRINGs only\";\n          return -1;\n        }\n\n        if (this.unusedBits > 0 && this.value[i].valueBlock.unusedBits > 0) {\n          this.error = \"Usign of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n          return -1;\n        }\n\n        this.unusedBits = this.value[i].valueBlock.unusedBits;\n\n        if (this.unusedBits > 7) {\n          this.error = \"Unused bits for BitString must be in range 0-7\";\n          return -1;\n        }\n      }\n\n      return resultOffset;\n    } //endregion\n    //region If the BitString supposed to be a primitive value\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.unusedBits = intBuffer[0];\n\n    if (this.unusedBits > 7) {\n      this.error = \"Unused bits for BitString must be in range 0-7\";\n      return -1;\n    } //region Copy input buffer to internal buffer\n\n\n    this.valueHex = new ArrayBuffer(intBuffer.length - 1);\n    const view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength - 1; i++) view[i] = intBuffer[i + 1]; //endregion\n\n\n    this.blockLength = intBuffer.length;\n    return inputOffset + inputLength; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n    if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength + 1);\n    if (this.valueHex.byteLength === 0) return new ArrayBuffer(0);\n    const curView = new Uint8Array(this.valueHex);\n    const retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n    const retView = new Uint8Array(retBuf);\n    retView[0] = this.unusedBits;\n\n    for (let i = 0; i < this.valueHex.byteLength; i++) retView[i + 1] = curView[i];\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BitStringValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.unusedBits = this.unusedBits;\n    object.isConstructed = this.isConstructed;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass BitString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"BitString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBitStringValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 3; // BitString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BitString\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Ability to encode empty BitString\n    if (inputLength === 0) return inputOffset; //endregion\n\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  } //**********************************************************************************\n\n  /**\r\n   * Checking that two BITSTRINGs are equal\r\n   * @param {BitString} bitString\r\n   */\n\n\n  isEqual(bitString) {\n    //region Check input type\n    if (bitString instanceof BitString === false) return false; //endregion\n    //region Compare two JSON strings\n\n    if (JSON.stringify(this) !== JSON.stringify(bitString)) return false; //endregion\n\n    return true;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Integer type class\n//**************************************************************************************\n\n/**\r\n * @extends ValueBlock\r\n */\n\n\nexports.BitString = BitString;\n\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalIntegerValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    if (\"value\" in parameters) this.valueDec = parameters.value;\n  } //**********************************************************************************\n\n  /**\r\n   * Setter for \"valueHex\"\r\n   * @param {ArrayBuffer} _value\r\n   */\n\n\n  set valueHex(_value) {\n    this._valueHex = _value.slice(0);\n\n    if (_value.byteLength >= 4) {\n      this.warnings.push(\"Too big Integer for decoding, hex only\");\n      this.isHexOnly = true;\n      this._valueDec = 0;\n    } else {\n      this.isHexOnly = false;\n      if (_value.byteLength > 0) this._valueDec = _pvutils.utilDecodeTC.call(this);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Getter for \"valueHex\"\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  get valueHex() {\n    return this._valueHex;\n  } //**********************************************************************************\n\n  /**\r\n   * Getter for \"valueDec\"\r\n   * @param {number} _value\r\n   */\n\n\n  set valueDec(_value) {\n    this._valueDec = _value;\n    this.isHexOnly = false;\n    this._valueHex = (0, _pvutils.utilEncodeTC)(_value);\n  } //**********************************************************************************\n\n  /**\r\n   * Getter for \"valueDec\"\r\n   * @returns {number}\r\n   */\n\n\n  get valueDec() {\n    return this._valueDec;\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from DER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @param {number} [expectedLength=0] Expected length of converted \"valueHex\" buffer\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\n    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n    if (offset === -1) return offset;\n    const view = new Uint8Array(this._valueHex);\n\n    if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n      const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n      const updatedView = new Uint8Array(updatedValueHex);\n      updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n      this._valueHex = updatedValueHex.slice(0);\n    } else {\n      if (expectedLength !== 0) {\n        if (this._valueHex.byteLength < expectedLength) {\n          if (expectedLength - this._valueHex.byteLength > 1) expectedLength = this._valueHex.byteLength + 1;\n          const updatedValueHex = new ArrayBuffer(expectedLength);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView.set(view, expectedLength - this._valueHex.byteLength);\n          this._valueHex = updatedValueHex.slice(0);\n        }\n      }\n    }\n\n    return offset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toDER(sizeOnly = false) {\n    const view = new Uint8Array(this._valueHex);\n\n    switch (true) {\n      case (view[0] & 0x80) !== 0:\n        {\n          const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView[0] = 0x00;\n          updatedView.set(view, 1);\n          this._valueHex = updatedValueHex.slice(0);\n        }\n        break;\n\n      case view[0] === 0x00 && (view[1] & 0x80) === 0:\n        {\n          const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n          this._valueHex = updatedValueHex.slice(0);\n        }\n        break;\n\n      default:\n    }\n\n    return this.toBER(sizeOnly);\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n    if (resultOffset === -1) return resultOffset;\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //noinspection JSCheckFunctionSignatures\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"IntegerValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    return object;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current value to decimal string representation\r\n   */\n\n\n  toString() {\n    //region Aux functions\n    function viewAdd(first, second) {\n      //region Initial variables\n      const c = new Uint8Array([0]);\n      let firstView = new Uint8Array(first);\n      let secondView = new Uint8Array(second);\n      let firstViewCopy = firstView.slice(0);\n      const firstViewCopyLength = firstViewCopy.length - 1;\n      let secondViewCopy = secondView.slice(0);\n      const secondViewCopyLength = secondViewCopy.length - 1;\n      let value = 0;\n      const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n      let counter = 0; //endregion\n\n      for (let i = max; i >= 0; i--, counter++) {\n        switch (true) {\n          case counter < secondViewCopy.length:\n            value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n            break;\n\n          default:\n            value = firstViewCopy[firstViewCopyLength - counter] + c[0];\n        }\n\n        c[0] = value / 10;\n\n        switch (true) {\n          case counter >= firstViewCopy.length:\n            firstViewCopy = (0, _pvutils.utilConcatView)(new Uint8Array([value % 10]), firstViewCopy);\n            break;\n\n          default:\n            firstViewCopy[firstViewCopyLength - counter] = value % 10;\n        }\n      }\n\n      if (c[0] > 0) firstViewCopy = (0, _pvutils.utilConcatView)(c, firstViewCopy);\n      return firstViewCopy.slice(0);\n    }\n\n    function power2(n) {\n      if (n >= powers2.length) {\n        for (let p = powers2.length; p <= n; p++) {\n          const c = new Uint8Array([0]);\n          let digits = powers2[p - 1].slice(0);\n\n          for (let i = digits.length - 1; i >= 0; i--) {\n            const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\n            c[0] = newValue[0] / 10;\n            digits[i] = newValue[0] % 10;\n          }\n\n          if (c[0] > 0) digits = (0, _pvutils.utilConcatView)(c, digits);\n          powers2.push(digits);\n        }\n      }\n\n      return powers2[n];\n    }\n\n    function viewSub(first, second) {\n      //region Initial variables\n      let b = 0;\n      let firstView = new Uint8Array(first);\n      let secondView = new Uint8Array(second);\n      let firstViewCopy = firstView.slice(0);\n      const firstViewCopyLength = firstViewCopy.length - 1;\n      let secondViewCopy = secondView.slice(0);\n      const secondViewCopyLength = secondViewCopy.length - 1;\n      let value;\n      let counter = 0; //endregion\n\n      for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n\n        switch (true) {\n          case value < 0:\n            b = 1;\n            firstViewCopy[firstViewCopyLength - counter] = value + 10;\n            break;\n\n          default:\n            b = 0;\n            firstViewCopy[firstViewCopyLength - counter] = value;\n        }\n      }\n\n      if (b > 0) {\n        for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {\n          value = firstViewCopy[firstViewCopyLength - counter] - b;\n\n          if (value < 0) {\n            b = 1;\n            firstViewCopy[firstViewCopyLength - counter] = value + 10;\n          } else {\n            b = 0;\n            firstViewCopy[firstViewCopyLength - counter] = value;\n            break;\n          }\n        }\n      }\n\n      return firstViewCopy.slice();\n    } //endregion\n    //region Initial variables\n\n\n    const firstBit = this._valueHex.byteLength * 8 - 1;\n    let digits = new Uint8Array(this._valueHex.byteLength * 8 / 3);\n    let bitNumber = 0;\n    let currentByte;\n    const asn1View = new Uint8Array(this._valueHex);\n    let result = \"\";\n    let flag = false; //endregion\n    //region Calculate number\n\n    for (let byteNumber = this._valueHex.byteLength - 1; byteNumber >= 0; byteNumber--) {\n      currentByte = asn1View[byteNumber];\n\n      for (let i = 0; i < 8; i++) {\n        if ((currentByte & 1) === 1) {\n          switch (bitNumber) {\n            case firstBit:\n              digits = viewSub(power2(bitNumber), digits);\n              result = \"-\";\n              break;\n\n            default:\n              digits = viewAdd(digits, power2(bitNumber));\n          }\n        }\n\n        bitNumber++;\n        currentByte >>= 1;\n      }\n    } //endregion\n    //region Print number\n\n\n    for (let i = 0; i < digits.length; i++) {\n      if (digits[i]) flag = true;\n      if (flag) result += digitsString.charAt(digits[i]);\n    }\n\n    if (flag === false) result += digitsString.charAt(0); //endregion\n\n    return result;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Integer extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Integer\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalIntegerValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 2; // Integer\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Integer\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Compare two Integer object, or Integer and ArrayBuffer objects\r\n   * @param {!Integer|ArrayBuffer} otherValue\r\n   * @returns {boolean}\r\n   */\n\n\n  isEqual(otherValue) {\n    if (otherValue instanceof Integer) {\n      if (this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers\n        return (0, _pvutils.isEqualBuffer)(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);\n      if (this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly) return this.valueBlock.valueDec === otherValue.valueBlock.valueDec;\n      return false;\n    }\n\n    if (otherValue instanceof ArrayBuffer) return (0, _pvutils.isEqualBuffer)(this.valueBlock.valueHex, otherValue);\n    return false;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current Integer value from BER into DER format\r\n   * @returns {Integer}\r\n   */\n\n\n  convertToDER() {\n    const integer = new Integer({\n      valueHex: this.valueBlock.valueHex\n    });\n    integer.valueBlock.toDER();\n    return integer;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current Integer value from DER to BER format\r\n   * @returns {Integer}\r\n   */\n\n\n  convertFromDER() {\n    const expectedLength = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength;\n    const integer = new Integer({\n      valueHex: this.valueBlock.valueHex\n    });\n    integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);\n    return integer;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Enumerated type class\n//**************************************************************************************\n\n\nexports.Integer = Integer;\n\nclass Enumerated extends Integer {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Enumerated\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 10; // Enumerated\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Enumerated\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 ObjectIdentifier type class\n//**************************************************************************************\n\n\nexports.Enumerated = Enumerated;\n\nclass LocalSidValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalSidValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {number} [valueDec]\r\n   * @property {boolean} [isFirstSid]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.valueDec = (0, _pvutils.getParametersValue)(parameters, \"valueDec\", -1);\n    this.isFirstSid = (0, _pvutils.getParametersValue)(parameters, \"isFirstSid\", false);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"sidBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (inputLength === 0) return inputOffset; //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.valueHex = new ArrayBuffer(inputLength);\n    let view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength; i++) {\n      view[i] = intBuffer[i] & 0x7F;\n      this.blockLength++;\n      if ((intBuffer[i] & 0x80) === 0x00) break;\n    } //region Ajust size of valueHex buffer\n\n\n    const tempValueHex = new ArrayBuffer(this.blockLength);\n    const tempView = new Uint8Array(tempValueHex);\n\n    for (let i = 0; i < this.blockLength; i++) tempView[i] = view[i]; //noinspection JSCheckFunctionSignatures\n\n\n    this.valueHex = tempValueHex.slice(0);\n    view = new Uint8Array(this.valueHex); //endregion\n\n    if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    if (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n    if (this.blockLength <= 8) this.valueDec = (0, _pvutils.utilFromBase)(view, 7);else {\n      this.isHexOnly = true;\n      this.warnings.push(\"Too big SID for decoding, hex only\");\n    }\n    return inputOffset + this.blockLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.isHexOnly) {\n      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n      const curView = new Uint8Array(this.valueHex);\n      retBuf = new ArrayBuffer(this.blockLength);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n      retView[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retBuf;\n    }\n\n    const encodedBuf = (0, _pvutils.utilToBase)(this.valueDec, 7);\n\n    if (encodedBuf.byteLength === 0) {\n      this.error = \"Error during encoding SID value\";\n      return new ArrayBuffer(0);\n    }\n\n    retBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n    if (sizeOnly === false) {\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < encodedBuf.byteLength - 1; i++) retView[i] = encodedView[i] | 0x80;\n\n      retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create string representation of current SID block\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    if (this.isHexOnly === true) result = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);else {\n      if (this.isFirstSid) {\n        let sidValue = this.valueDec;\n        if (this.valueDec <= 39) result = \"0.\";else {\n          if (this.valueDec <= 79) {\n            result = \"1.\";\n            sidValue -= 40;\n          } else {\n            result = \"2.\";\n            sidValue -= 80;\n          }\n        }\n        result += sidValue.toString();\n      } else result = this.valueDec.toString();\n    }\n    return result;\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    object.isFirstSid = this.isFirstSid;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalObjectIdentifierValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.fromString((0, _pvutils.getParametersValue)(parameters, \"value\", \"\"));\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n\n    while (inputLength > 0) {\n      const sidBlock = new LocalSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n\n      if (this.value.length === 0) sidBlock.isFirstSid = true;\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create \"LocalObjectIdentifierValueBlock\" class from string\r\n   * @param {string} string Input string to convert from\r\n   * @returns {boolean}\r\n   */\n\n\n  fromString(string) {\n    this.value = []; // Clear existing SID values\n\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = \"\";\n    let flag = false;\n\n    do {\n      pos2 = string.indexOf(\".\", pos1);\n      if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n      pos1 = pos2 + 1;\n\n      if (flag) {\n        const sidBlock = this.value[0];\n        let plus = 0;\n\n        switch (sidBlock.valueDec) {\n          case 0:\n            break;\n\n          case 1:\n            plus = 40;\n            break;\n\n          case 2:\n            plus = 80;\n            break;\n\n          default:\n            this.value = []; // clear SID array\n\n            return false;\n          // ???\n        }\n\n        const parsedSID = parseInt(sid, 10);\n        if (isNaN(parsedSID)) return true;\n        sidBlock.valueDec = parsedSID + plus;\n        flag = false;\n      } else {\n        const sidBlock = new LocalSidValueBlock();\n        sidBlock.valueDec = parseInt(sid, 10);\n        if (isNaN(sidBlock.valueDec)) return true;\n\n        if (this.value.length === 0) {\n          sidBlock.isFirstSid = true;\n          flag = true;\n        }\n\n        this.value.push(sidBlock);\n      }\n    } while (pos2 !== -1);\n\n    return true;\n  } //**********************************************************************************\n\n  /**\r\n   * Converts \"LocalObjectIdentifierValueBlock\" class to string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    let isHexOnly = false;\n\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0) result = `${result}.`;\n\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;else result += sidStr;\n      } else result += sidStr;\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"ObjectIdentifierValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.toString();\n    object.sidArray = [];\n\n    for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass ObjectIdentifier extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"ObjectIdentifier\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 6; // OBJECT IDENTIFIER\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"ObjectIdentifier\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all string's classes\n//**************************************************************************************\n\n\nexports.ObjectIdentifier = ObjectIdentifier;\n\nclass LocalUtf8StringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Constructor for \"LocalUtf8StringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\"; // String representation of decoded ArrayBuffer\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Utf8StringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass Utf8String extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Utf8String\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalUtf8StringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 12; // Utf8String\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Utf8String\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\n    try {\n      //noinspection JSDeprecatedSymbols\n      this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));\n    } catch (ex) {\n      this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    //noinspection JSDeprecatedSymbols\n    const str = unescape(encodeURIComponent(inputString));\n    const strLen = str.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLen);\n    const view = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLen; i++) view[i] = str.charCodeAt(i);\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//region Declaration of ASN.1 RelativeObjectIdentifier type class\n//**************************************************************************************\n\n\nexports.Utf8String = Utf8String;\n\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalRelativeSidValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {number} [valueDec]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.valueDec = (0, _pvutils.getParametersValue)(parameters, \"valueDec\", -1);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"relativeSidBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (inputLength === 0) return inputOffset; //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.valueHex = new ArrayBuffer(inputLength);\n    let view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength; i++) {\n      view[i] = intBuffer[i] & 0x7F;\n      this.blockLength++;\n      if ((intBuffer[i] & 0x80) === 0x00) break;\n    } //region Ajust size of valueHex buffer\n\n\n    const tempValueHex = new ArrayBuffer(this.blockLength);\n    const tempView = new Uint8Array(tempValueHex);\n\n    for (let i = 0; i < this.blockLength; i++) tempView[i] = view[i]; //noinspection JSCheckFunctionSignatures\n\n\n    this.valueHex = tempValueHex.slice(0);\n    view = new Uint8Array(this.valueHex); //endregion\n\n    if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    if (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n    if (this.blockLength <= 8) this.valueDec = (0, _pvutils.utilFromBase)(view, 7);else {\n      this.isHexOnly = true;\n      this.warnings.push(\"Too big SID for decoding, hex only\");\n    }\n    return inputOffset + this.blockLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.isHexOnly) {\n      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n      const curView = new Uint8Array(this.valueHex);\n      retBuf = new ArrayBuffer(this.blockLength);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n      retView[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retBuf;\n    }\n\n    const encodedBuf = (0, _pvutils.utilToBase)(this.valueDec, 7);\n\n    if (encodedBuf.byteLength === 0) {\n      this.error = \"Error during encoding SID value\";\n      return new ArrayBuffer(0);\n    }\n\n    retBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n    if (sizeOnly === false) {\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < encodedBuf.byteLength - 1; i++) retView[i] = encodedView[i] | 0x80;\n\n      retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create string representation of current SID block\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    if (this.isHexOnly === true) result = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);else {\n      result = this.valueDec.toString();\n    }\n    return result;\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalRelativeObjectIdentifierValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.fromString((0, _pvutils.getParametersValue)(parameters, \"value\", \"\"));\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n\n    while (inputLength > 0) {\n      const sidBlock = new LocalRelativeSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create \"LocalRelativeObjectIdentifierValueBlock\" class from string\r\n   * @param {string} string Input string to convert from\r\n   * @returns {boolean}\r\n   */\n\n\n  fromString(string) {\n    this.value = []; // Clear existing SID values\n\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = \"\";\n\n    do {\n      pos2 = string.indexOf(\".\", pos1);\n      if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n      pos1 = pos2 + 1;\n      const sidBlock = new LocalRelativeSidValueBlock();\n      sidBlock.valueDec = parseInt(sid, 10);\n      if (isNaN(sidBlock.valueDec)) return true;\n      this.value.push(sidBlock);\n    } while (pos2 !== -1);\n\n    return true;\n  } //**********************************************************************************\n\n  /**\r\n   * Converts \"LocalRelativeObjectIdentifierValueBlock\" class to string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    let isHexOnly = false;\n\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0) result = `${result}.`;\n\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        result += sidStr;\n      } else result += sidStr;\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"RelativeObjectIdentifierValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.toString();\n    object.sidArray = [];\n\n    for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass RelativeObjectIdentifier extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"RelativeObjectIdentifier\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalRelativeObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 13; // RELATIVE OBJECT IDENTIFIER\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"RelativeObjectIdentifier\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n\n/**\r\n * @extends LocalBaseBlock\r\n * @extends HexBlock\r\n */\n\n\nexports.RelativeObjectIdentifier = RelativeObjectIdentifier;\n\nclass LocalBmpStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBmpStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\";\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BmpStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass BmpString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"BmpString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBmpStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 30; // BmpString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BmpString\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    //noinspection JSCheckFunctionSignatures\n    const copyBuffer = inputBuffer.slice(0);\n    const valueView = new Uint8Array(copyBuffer);\n\n    for (let i = 0; i < valueView.length; i += 2) {\n      const temp = valueView[i];\n      valueView[i] = valueView[i + 1];\n      valueView[i + 1] = temp;\n    }\n\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    const strLength = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);\n    const valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLength; i++) {\n      const codeBuf = (0, _pvutils.utilToBase)(inputString.charCodeAt(i), 8);\n      const codeView = new Uint8Array(codeBuf);\n      if (codeView.length > 2) continue;\n      const dif = 2 - codeView.length;\n\n      for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 2 + j + dif] = codeView[j];\n    }\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.BmpString = BmpString;\n\nclass LocalUniversalStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalUniversalStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\";\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"UniversalStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass UniversalString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"UniversalString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalUniversalStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 28; // UniversalString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"UniversalString\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    //noinspection JSCheckFunctionSignatures\n    const copyBuffer = inputBuffer.slice(0);\n    const valueView = new Uint8Array(copyBuffer);\n\n    for (let i = 0; i < valueView.length; i += 4) {\n      valueView[i] = valueView[i + 3];\n      valueView[i + 1] = valueView[i + 2];\n      valueView[i + 2] = 0x00;\n      valueView[i + 3] = 0x00;\n    }\n\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    const strLength = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);\n    const valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLength; i++) {\n      const codeBuf = (0, _pvutils.utilToBase)(inputString.charCodeAt(i), 8);\n      const codeView = new Uint8Array(codeBuf);\n      if (codeView.length > 4) continue;\n      const dif = 4 - codeView.length;\n\n      for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 4 + j + dif] = codeView[j];\n    }\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.UniversalString = UniversalString;\n\nclass LocalSimpleStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalSimpleStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.value = \"\";\n    this.isHexOnly = true;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"SimpleStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass LocalSimpleStringBlock extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalSimpleStringBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalSimpleStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"SIMPLESTRING\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    const strLen = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLen);\n    const view = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLen; i++) view[i] = inputString.charCodeAt(i);\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nclass NumericString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"NumericString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 18; // NumericString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"NumericString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.NumericString = NumericString;\n\nclass PrintableString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"PrintableString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 19; // PrintableString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"PrintableString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.PrintableString = PrintableString;\n\nclass TeletexString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"TeletexString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 20; // TeletexString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"TeletexString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.TeletexString = TeletexString;\n\nclass VideotexString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"VideotexString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 21; // VideotexString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"VideotexString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.VideotexString = VideotexString;\n\nclass IA5String extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"IA5String\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 22; // IA5String\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"IA5String\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.IA5String = IA5String;\n\nclass GraphicString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"GraphicString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 25; // GraphicString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"GraphicString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.GraphicString = GraphicString;\n\nclass VisibleString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"VisibleString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 26; // VisibleString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"VisibleString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.VisibleString = VisibleString;\n\nclass GeneralString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"GeneralString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 27; // GeneralString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"GeneralString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.GeneralString = GeneralString;\n\nclass CharacterString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"CharacterString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 29; // CharacterString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"CharacterString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all date and time classes\n//**************************************************************************************\n\n/**\r\n * @extends VisibleString\r\n */\n\n\nexports.CharacterString = CharacterString;\n\nclass UTCTime extends VisibleString {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"UTCTime\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [value] String representatio of the date\r\n   * @property {Date} [valueDate] JavaScript \"Date\" object\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0; //region Create UTCTime from ASN.1 UTC string value\n\n    if (\"value\" in parameters) {\n      this.fromString(parameters.value);\n      this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n      const view = new Uint8Array(this.valueBlock.valueHex);\n\n      for (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);\n    } //endregion\n    //region Create GeneralizedTime from JavaScript Date type\n\n\n    if (\"valueDate\" in parameters) {\n      this.fromDate(parameters.valueDate);\n      this.valueBlock.valueHex = this.toBuffer();\n    } //endregion\n\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 23; // UTCTime\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal string into ArrayBuffer\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n\n    for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting \"Date\" object into ASN.1 internal string\r\n   * @param {!Date} inputDate JavaScript \"Date\" object\r\n   */\n\n\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Function converting ASN.1 internal string into \"Date\" object\r\n   * @returns {Date}\r\n   */\n\n\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    //region Parse input string\n    const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n    const parserArray = parser.exec(inputString);\n\n    if (parserArray === null) {\n      this.error = \"Wrong input string for convertion\";\n      return;\n    } //endregion\n    //region Store parsed values\n\n\n    const year = parseInt(parserArray[1], 10);\n    if (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;\n    this.month = parseInt(parserArray[2], 10);\n    this.day = parseInt(parserArray[3], 10);\n    this.hour = parseInt(parserArray[4], 10);\n    this.minute = parseInt(parserArray[5], 10);\n    this.second = parseInt(parserArray[6], 10); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal class into JavaScript string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    const outputArray = new Array(7);\n    outputArray[0] = (0, _pvutils.padNumber)(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n    outputArray[1] = (0, _pvutils.padNumber)(this.month, 2);\n    outputArray[2] = (0, _pvutils.padNumber)(this.day, 2);\n    outputArray[3] = (0, _pvutils.padNumber)(this.hour, 2);\n    outputArray[4] = (0, _pvutils.padNumber)(this.minute, 2);\n    outputArray[5] = (0, _pvutils.padNumber)(this.second, 2);\n    outputArray[6] = \"Z\";\n    return outputArray.join(\"\");\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"UTCTime\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.year = this.year;\n    object.month = this.month;\n    object.day = this.day;\n    object.hour = this.hour;\n    object.minute = this.minute;\n    object.second = this.second;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends VisibleString\r\n */\n\n\nexports.UTCTime = UTCTime;\n\nclass GeneralizedTime extends VisibleString {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"GeneralizedTime\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [value] String representatio of the date\r\n   * @property {Date} [valueDate] JavaScript \"Date\" object\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0;\n    this.millisecond = 0; //region Create UTCTime from ASN.1 UTC string value\n\n    if (\"value\" in parameters) {\n      this.fromString(parameters.value);\n      this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n      const view = new Uint8Array(this.valueBlock.valueHex);\n\n      for (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);\n    } //endregion\n    //region Create GeneralizedTime from JavaScript Date type\n\n\n    if (\"valueDate\" in parameters) {\n      this.fromDate(parameters.valueDate);\n      this.valueBlock.valueHex = this.toBuffer();\n    } //endregion\n\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 24; // GeneralizedTime\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal string into ArrayBuffer\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n\n    for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting \"Date\" object into ASN.1 internal string\r\n   * @param {!Date} inputDate JavaScript \"Date\" object\r\n   */\n\n\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n    this.millisecond = inputDate.getUTCMilliseconds();\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Function converting ASN.1 internal string into \"Date\" object\r\n   * @returns {Date}\r\n   */\n\n\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    //region Initial variables\n    let isUTC = false;\n    let timeString = \"\";\n    let dateTimeString = \"\";\n    let fractionPart = 0;\n    let parser;\n    let hourDifference = 0;\n    let minuteDifference = 0; //endregion\n    //region Convert as UTC time\n\n    if (inputString[inputString.length - 1] === \"Z\") {\n      timeString = inputString.substr(0, inputString.length - 1);\n      isUTC = true;\n    } //endregion\n    //region Convert as local time\n    else {\n        //noinspection JSPrimitiveTypeWrapperUsage\n        const number = new Number(inputString[inputString.length - 1]);\n        if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n        timeString = inputString;\n      } //endregion\n    //region Check that we do not have a \"+\" and \"-\" symbols inside UTC time\n\n\n    if (isUTC) {\n      if (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for convertion\");\n      if (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for convertion\");\n    } //endregion\n    //region Get \"UTC time difference\" in case of local time\n    else {\n        let multiplier = 1;\n        let differencePosition = timeString.indexOf(\"+\");\n        let differenceString = \"\";\n\n        if (differencePosition === -1) {\n          differencePosition = timeString.indexOf(\"-\");\n          multiplier = -1;\n        }\n\n        if (differencePosition !== -1) {\n          differenceString = timeString.substr(differencePosition + 1);\n          timeString = timeString.substr(0, differencePosition);\n          if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for convertion\"); //noinspection JSPrimitiveTypeWrapperUsage\n\n          let number = new Number(differenceString.substr(0, 2));\n          if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n          hourDifference = multiplier * number;\n\n          if (differenceString.length === 4) {\n            //noinspection JSPrimitiveTypeWrapperUsage\n            number = new Number(differenceString.substr(2, 2));\n            if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n            minuteDifference = multiplier * number;\n          }\n        }\n      } //endregion\n    //region Get position of fraction point\n\n\n    let fractionPointPosition = timeString.indexOf(\".\"); // Check for \"full stop\" symbol\n\n    if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\"); // Check for \"comma\" symbol\n    //endregion\n    //region Get fraction part\n\n    if (fractionPointPosition !== -1) {\n      //noinspection JSPrimitiveTypeWrapperUsage\n      const fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);\n      if (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for convertion\");\n      fractionPart = fractionPartCheck.valueOf();\n      dateTimeString = timeString.substr(0, fractionPointPosition);\n    } else dateTimeString = timeString; //endregion\n    //region Parse internal date\n\n\n    switch (true) {\n      case dateTimeString.length === 8:\n        // \"YYYYMMDD\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) throw new Error(\"Wrong input string for convertion\"); // Here we should not have a \"fraction point\"\n\n        break;\n\n      case dateTimeString.length === 10:\n        // \"YYYYMMDDHH\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.minute = Math.floor(fractionResult);\n          fractionResult = 60 * (fractionResult - this.minute);\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      case dateTimeString.length === 12:\n        // \"YYYYMMDDHHMM\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      case dateTimeString.length === 14:\n        // \"YYYYMMDDHHMMSS\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          const fractionResult = 1000 * fractionPart;\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Wrong input string for convertion\");\n    } //endregion\n    //region Put parsed values at right places\n\n\n    const parserArray = parser.exec(dateTimeString);\n    if (parserArray === null) throw new Error(\"Wrong input string for convertion\");\n\n    for (let j = 1; j < parserArray.length; j++) {\n      switch (j) {\n        case 1:\n          this.year = parseInt(parserArray[j], 10);\n          break;\n\n        case 2:\n          this.month = parseInt(parserArray[j], 10);\n          break;\n\n        case 3:\n          this.day = parseInt(parserArray[j], 10);\n          break;\n\n        case 4:\n          this.hour = parseInt(parserArray[j], 10) + hourDifference;\n          break;\n\n        case 5:\n          this.minute = parseInt(parserArray[j], 10) + minuteDifference;\n          break;\n\n        case 6:\n          this.second = parseInt(parserArray[j], 10);\n          break;\n\n        default:\n          throw new Error(\"Wrong input string for convertion\");\n      }\n    } //endregion\n    //region Get final date\n\n\n    if (isUTC === false) {\n      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n      this.year = tempDate.getUTCFullYear();\n      this.month = tempDate.getUTCMonth();\n      this.day = tempDate.getUTCDay();\n      this.hour = tempDate.getUTCHours();\n      this.minute = tempDate.getUTCMinutes();\n      this.second = tempDate.getUTCSeconds();\n      this.millisecond = tempDate.getUTCMilliseconds();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal class into JavaScript string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    const outputArray = [];\n    outputArray.push((0, _pvutils.padNumber)(this.year, 4));\n    outputArray.push((0, _pvutils.padNumber)(this.month, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.day, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.hour, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.minute, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.second, 2));\n\n    if (this.millisecond !== 0) {\n      outputArray.push(\".\");\n      outputArray.push((0, _pvutils.padNumber)(this.millisecond, 3));\n    }\n\n    outputArray.push(\"Z\");\n    return outputArray.join(\"\");\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"GeneralizedTime\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.year = this.year;\n    object.month = this.month;\n    object.day = this.day;\n    object.hour = this.hour;\n    object.minute = this.minute;\n    object.second = this.second;\n    object.millisecond = this.millisecond;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.GeneralizedTime = GeneralizedTime;\n\nclass DATE extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"DATE\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 31; // DATE\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"DATE\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.DATE = DATE;\n\nclass TimeOfDay extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"TimeOfDay\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 32; // TimeOfDay\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"TimeOfDay\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.TimeOfDay = TimeOfDay;\n\nclass DateTime extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"DateTime\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 33; // DateTime\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"DateTime\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.DateTime = DateTime;\n\nclass Duration extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Duration\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 34; // Duration\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Duration\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.Duration = Duration;\n\nclass TIME extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Time\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 14; // Time\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"TIME\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Choice\n//**************************************************************************************\n\n\nexports.TIME = TIME;\n\nclass Choice {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Choice\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Array} [value] Array of ASN.1 types for make a choice from\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", []);\n    this.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Any\n//**************************************************************************************\n\n\nexports.Choice = Choice;\n\nclass Any {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Any\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.name = (0, _pvutils.getParametersValue)(parameters, \"name\", \"\");\n    this.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Repeated\n//**************************************************************************************\n\n\nexports.Any = Any;\n\nclass Repeated {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Repeated\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.name = (0, _pvutils.getParametersValue)(parameters, \"name\", \"\");\n    this.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", new Any());\n    this.local = (0, _pvutils.getParametersValue)(parameters, \"local\", false); // Could local or global array to store elements\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type RawData\n//**************************************************************************************\n\n/**\r\n * @description Special class providing ability to have \"toBER/fromBER\" for raw ArrayBuffer\r\n */\n\n\nexports.Repeated = Repeated;\n\nclass RawData {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Repeated\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.data = (0, _pvutils.getParametersValue)(parameters, \"data\", new ArrayBuffer(0));\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.data = inputBuffer.slice(inputOffset, inputLength);\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return this.data;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major ASN.1 BER decoding function\n//**************************************************************************************\n\n/**\r\n * Internal library function for decoding ASN.1 BER\r\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n * @returns {{offset: number, result: Object}}\r\n */\n\n\nexports.RawData = RawData;\n\nfunction LocalFromBER(inputBuffer, inputOffset, inputLength) {\n  const incomingOffset = inputOffset; // Need to store initial offset since \"inputOffset\" is changing in the function\n  //region Local function changing a type for ASN.1 classes\n\n  function localChangeType(inputObject, newType) {\n    if (inputObject instanceof newType) return inputObject;\n    const newObject = new newType();\n    newObject.idBlock = inputObject.idBlock;\n    newObject.lenBlock = inputObject.lenBlock;\n    newObject.warnings = inputObject.warnings; //noinspection JSCheckFunctionSignatures\n\n    newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);\n    return newObject;\n  } //endregion\n  //region Create a basic ASN.1 type since we need to return errors and warnings from the function\n\n\n  let returnObject = new BaseBlock({}, Object); //endregion\n  //region Basic check for parameters\n\n  const baseBlock = new LocalBaseBlock();\n\n  if ((0, _pvutils.checkBufferParams)(baseBlock, inputBuffer, inputOffset, inputLength) === false) {\n    returnObject.error = baseBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Getting Uint8Array from ArrayBuffer\n\n\n  const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n  //region Initial checks\n\n  if (intBuffer.length === 0) {\n    this.error = \"Zero buffer length\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Decode indentifcation block of ASN.1 BER structure\n\n\n  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  returnObject.warnings.concat(returnObject.idBlock.warnings);\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.idBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.idBlock.blockLength; //endregion\n  //region Decode length block of ASN.1 BER structure\n\n  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  returnObject.warnings.concat(returnObject.lenBlock.warnings);\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.lenBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.lenBlock.blockLength; //endregion\n  //region Check for usign indefinite length form in encoding for primitive types\n\n  if (returnObject.idBlock.isConstructed === false && returnObject.lenBlock.isIndefiniteForm === true) {\n    returnObject.error = \"Indefinite length form used for primitive encoding form\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Switch ASN.1 block type\n\n\n  let newASN1Type = BaseBlock;\n\n  switch (returnObject.idBlock.tagClass) {\n    //region UNIVERSAL\n    case 1:\n      //region Check for reserved tag numbers\n      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n        returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n        return {\n          offset: -1,\n          result: returnObject\n        };\n      } //endregion\n\n\n      switch (returnObject.idBlock.tagNumber) {\n        //region EndOfContent type\n        case 0:\n          //region Check for EndOfContent type\n          if (returnObject.idBlock.isConstructed === true && returnObject.lenBlock.length > 0) {\n            returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n            return {\n              offset: -1,\n              result: returnObject\n            };\n          } //endregion\n\n\n          newASN1Type = EndOfContent;\n          break;\n        //endregion\n        //region Boolean type\n\n        case 1:\n          newASN1Type = Boolean;\n          break;\n        //endregion\n        //region Integer type\n\n        case 2:\n          newASN1Type = Integer;\n          break;\n        //endregion\n        //region BitString type\n\n        case 3:\n          newASN1Type = BitString;\n          break;\n        //endregion\n        //region OctetString type\n\n        case 4:\n          newASN1Type = OctetString;\n          break;\n        //endregion\n        //region Null type\n\n        case 5:\n          newASN1Type = Null;\n          break;\n        //endregion\n        //region OBJECT IDENTIFIER type\n\n        case 6:\n          newASN1Type = ObjectIdentifier;\n          break;\n        //endregion\n        //region Enumerated type\n\n        case 10:\n          newASN1Type = Enumerated;\n          break;\n        //endregion\n        //region Utf8String type\n\n        case 12:\n          newASN1Type = Utf8String;\n          break;\n        //endregion\n        //region Time type\n        //region RELATIVE OBJECT IDENTIFIER type\n\n        case 13:\n          newASN1Type = RelativeObjectIdentifier;\n          break;\n        //endregion\n\n        case 14:\n          newASN1Type = TIME;\n          break;\n        //endregion\n        //region ASN.1 reserved type\n\n        case 15:\n          returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n          return {\n            offset: -1,\n            result: returnObject\n          };\n        //endregion\n        //region Sequence type\n\n        case 16:\n          newASN1Type = Sequence;\n          break;\n        //endregion\n        //region Set type\n\n        case 17:\n          newASN1Type = Set;\n          break;\n        //endregion\n        //region NumericString type\n\n        case 18:\n          newASN1Type = NumericString;\n          break;\n        //endregion\n        //region PrintableString type\n\n        case 19:\n          newASN1Type = PrintableString;\n          break;\n        //endregion\n        //region TeletexString type\n\n        case 20:\n          newASN1Type = TeletexString;\n          break;\n        //endregion\n        //region VideotexString type\n\n        case 21:\n          newASN1Type = VideotexString;\n          break;\n        //endregion\n        //region IA5String type\n\n        case 22:\n          newASN1Type = IA5String;\n          break;\n        //endregion\n        //region UTCTime type\n\n        case 23:\n          newASN1Type = UTCTime;\n          break;\n        //endregion\n        //region GeneralizedTime type\n\n        case 24:\n          newASN1Type = GeneralizedTime;\n          break;\n        //endregion\n        //region GraphicString type\n\n        case 25:\n          newASN1Type = GraphicString;\n          break;\n        //endregion\n        //region VisibleString type\n\n        case 26:\n          newASN1Type = VisibleString;\n          break;\n        //endregion\n        //region GeneralString type\n\n        case 27:\n          newASN1Type = GeneralString;\n          break;\n        //endregion\n        //region UniversalString type\n\n        case 28:\n          newASN1Type = UniversalString;\n          break;\n        //endregion\n        //region CharacterString type\n\n        case 29:\n          newASN1Type = CharacterString;\n          break;\n        //endregion\n        //region BmpString type\n\n        case 30:\n          newASN1Type = BmpString;\n          break;\n        //endregion\n        //region DATE type\n\n        case 31:\n          newASN1Type = DATE;\n          break;\n        //endregion\n        //region TimeOfDay type\n\n        case 32:\n          newASN1Type = TimeOfDay;\n          break;\n        //endregion\n        //region Date-Time type\n\n        case 33:\n          newASN1Type = DateTime;\n          break;\n        //endregion\n        //region Duration type\n\n        case 34:\n          newASN1Type = Duration;\n          break;\n        //endregion\n        //region default\n\n        default:\n          {\n            let newObject;\n            if (returnObject.idBlock.isConstructed === true) newObject = new Constructed();else newObject = new Primitive();\n            newObject.idBlock = returnObject.idBlock;\n            newObject.lenBlock = returnObject.lenBlock;\n            newObject.warnings = returnObject.warnings;\n            returnObject = newObject;\n            resultOffset = returnObject.fromBER(inputBuffer, inputOffset, inputLength);\n          }\n        //endregion\n      }\n\n      break;\n    //endregion\n    //region All other tag classes\n\n    case 2: // APPLICATION\n\n    case 3: // CONTEXT-SPECIFIC\n\n    case 4: // PRIVATE\n\n    default:\n      {\n        if (returnObject.idBlock.isConstructed === true) newASN1Type = Constructed;else newASN1Type = Primitive;\n      }\n    //endregion\n  } //endregion\n  //region Change type and perform BER decoding\n\n\n  returnObject = localChangeType(returnObject, newASN1Type);\n  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm === true ? inputLength : returnObject.lenBlock.length); //endregion\n  //region Coping incoming buffer for entire ASN.1 block\n\n  returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength); //endregion\n\n  return {\n    offset: resultOffset,\n    result: returnObject\n  };\n} //**************************************************************************************\n\n/**\r\n * Major function for decoding ASN.1 BER array into internal library structuries\r\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes\r\n */\n\n\nfunction fromBER(inputBuffer) {\n  if (inputBuffer.byteLength === 0) {\n    const result = new BaseBlock({}, Object);\n    result.error = \"Input buffer has zero length\";\n    return {\n      offset: -1,\n      result\n    };\n  }\n\n  return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major scheme verification function\n//**************************************************************************************\n\n/**\r\n * Compare of two ASN.1 object trees\r\n * @param {!Object} root Root of input ASN.1 object tree\r\n * @param {!Object} inputData Input ASN.1 object tree\r\n * @param {!Object} inputSchema Input ASN.1 schema to compare with\r\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\r\n */\n\n\nfunction compareSchema(root, inputData, inputSchema) {\n  //region Special case for Choice schema element type\n  if (inputSchema instanceof Choice) {\n    const choiceResult = false;\n\n    for (let j = 0; j < inputSchema.value.length; j++) {\n      const result = compareSchema(root, inputData, inputSchema.value[j]);\n\n      if (result.verified === true) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n    }\n\n    if (choiceResult === false) {\n      const _result = {\n        verified: false,\n        result: {\n          error: \"Wrong values for Choice type\"\n        }\n      };\n      if (inputSchema.hasOwnProperty(\"name\")) _result.name = inputSchema.name;\n      return _result;\n    }\n  } //endregion\n  //region Special case for Any schema element type\n\n\n  if (inputSchema instanceof Any) {\n    //region Add named component of ASN.1 schema\n    if (inputSchema.hasOwnProperty(\"name\")) root[inputSchema.name] = inputData; //endregion\n\n    return {\n      verified: true,\n      result: root\n    };\n  } //endregion\n  //region Initial check\n\n\n  if (root instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong root object\"\n      }\n    };\n  }\n\n  if (inputData instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 data\"\n      }\n    };\n  }\n\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (\"idBlock\" in inputSchema === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  } //endregion\n  //region Comparing idBlock properties in ASN.1 data and ASN.1 schema\n  //region Encode and decode ASN.1 schema idBlock\n  /// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>\n\n\n  if (\"fromBER\" in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (\"toBER\" in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  const encodedId = inputSchema.idBlock.toBER(false);\n\n  if (encodedId.byteLength === 0) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error encoding idBlock for ASN.1 schema\"\n      }\n    };\n  }\n\n  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n\n  if (decodedOffset === -1) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error decoding idBlock for ASN.1 schema\"\n      }\n    };\n  } //endregion\n  //region tagClass\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"tagClass\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region tagNumber\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"tagNumber\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region isConstructed\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"isConstructed\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region isHexOnly\n\n\n  if (\"isHexOnly\" in inputSchema.idBlock === false) // Since 'isHexOnly' is an inhirited property\n    {\n      return {\n        verified: false,\n        result: {\n          error: \"Wrong ASN.1 schema\"\n        }\n      };\n    }\n\n  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region valueHex\n\n\n  if (inputSchema.idBlock.isHexOnly === true) {\n    if (\"valueHex\" in inputSchema.idBlock === false) // Since 'valueHex' is an inhirited property\n      {\n        return {\n          verified: false,\n          result: {\n            error: \"Wrong ASN.1 schema\"\n          }\n        };\n      }\n\n    const schemaView = new Uint8Array(inputSchema.idBlock.valueHex);\n    const asn1View = new Uint8Array(inputData.idBlock.valueHex);\n\n    if (schemaView.length !== asn1View.length) {\n      return {\n        verified: false,\n        result: root\n      };\n    }\n\n    for (let i = 0; i < schemaView.length; i++) {\n      if (schemaView[i] !== asn1View[1]) {\n        return {\n          verified: false,\n          result: root\n        };\n      }\n    }\n  } //endregion\n  //endregion\n  //region Add named component of ASN.1 schema\n\n\n  if (inputSchema.hasOwnProperty(\"name\")) {\n    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n    if (inputSchema.name !== \"\") root[inputSchema.name] = inputData;\n  } //endregion\n  //region Getting next ASN.1 block for comparition\n\n\n  if (inputSchema.idBlock.isConstructed === true) {\n    let admission = 0;\n    let result = {\n      verified: false\n    };\n    let maxLength = inputSchema.valueBlock.value.length;\n\n    if (maxLength > 0) {\n      if (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;\n    } //region Special case when constructive value has no elements\n\n\n    if (maxLength === 0) {\n      return {\n        verified: true,\n        result: root\n      };\n    } //endregion\n    //region Special case when \"inputData\" has no values and \"inputSchema\" has all optional values\n\n\n    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n      let _optional = true;\n\n      for (let i = 0; i < inputSchema.valueBlock.value.length; i++) _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n\n      if (_optional === true) {\n        return {\n          verified: true,\n          result: root\n        };\n      } //region Delete early added name of block\n\n\n      if (inputSchema.hasOwnProperty(\"name\")) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n        if (inputSchema.name !== \"\") delete root[inputSchema.name];\n      } //endregion\n\n\n      root.error = \"Inconsistent object length\";\n      return {\n        verified: false,\n        result: root\n      };\n    } //endregion\n\n\n    for (let i = 0; i < maxLength; i++) {\n      //region Special case when there is an \"optional\" element of ASN.1 schema at the end\n      if (i - admission >= inputData.valueBlock.value.length) {\n        if (inputSchema.valueBlock.value[i].optional === false) {\n          const _result = {\n            verified: false,\n            result: root\n          };\n          root.error = \"Inconsistent length between ASN.1 data and schema\"; //region Delete early added name of block\n\n          if (inputSchema.hasOwnProperty(\"name\")) {\n            inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n            if (inputSchema.name !== \"\") {\n              delete root[inputSchema.name];\n              _result.name = inputSchema.name;\n            }\n          } //endregion\n\n\n          return _result;\n        }\n      } //endregion\n      else {\n          //region Special case for Repeated type of ASN.1 schema element\n          if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n            result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n\n            if (result.verified === false) {\n              if (inputSchema.valueBlock.value[0].optional === true) admission++;else {\n                //region Delete early added name of block\n                if (inputSchema.hasOwnProperty(\"name\")) {\n                  inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n                  if (inputSchema.name !== \"\") delete root[inputSchema.name];\n                } //endregion\n\n\n                return result;\n              }\n            }\n\n            if (\"name\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n              let arrayRoot = {};\n              if (\"local\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local === true) arrayRoot = inputData;else arrayRoot = root;\n              if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n              arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n            }\n          } //endregion\n          else {\n              result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n\n              if (result.verified === false) {\n                if (inputSchema.valueBlock.value[i].optional === true) admission++;else {\n                  //region Delete early added name of block\n                  if (inputSchema.hasOwnProperty(\"name\")) {\n                    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n                    if (inputSchema.name !== \"\") delete root[inputSchema.name];\n                  } //endregion\n\n\n                  return result;\n                }\n              }\n            }\n        }\n    }\n\n    if (result.verified === false) // The situation may take place if last element is \"optional\" and verification failed\n      {\n        const _result = {\n          verified: false,\n          result: root\n        }; //region Delete early added name of block\n\n        if (inputSchema.hasOwnProperty(\"name\")) {\n          inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n          if (inputSchema.name !== \"\") {\n            delete root[inputSchema.name];\n            _result.name = inputSchema.name;\n          }\n        } //endregion\n\n\n        return _result;\n      }\n\n    return {\n      verified: true,\n      result: root\n    };\n  } //endregion\n  //region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)\n\n\n  if (\"primitiveSchema\" in inputSchema && \"valueHex\" in inputData.valueBlock) {\n    //region Decoding of raw ASN.1 data\n    const asn1 = fromBER(inputData.valueBlock.valueHex);\n\n    if (asn1.offset === -1) {\n      const _result = {\n        verified: false,\n        result: asn1.result\n      }; //region Delete early added name of block\n\n      if (inputSchema.hasOwnProperty(\"name\")) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n        if (inputSchema.name !== \"\") {\n          delete root[inputSchema.name];\n          _result.name = inputSchema.name;\n        }\n      } //endregion\n\n\n      return _result;\n    } //endregion\n\n\n    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n  }\n\n  return {\n    verified: true,\n    result: root\n  }; //endregion\n} //**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n\n/**\r\n * ASN.1 schema verification for ArrayBuffer data\r\n * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data\r\n * @param {!Object} inputSchema Input ASN.1 schema to verify against to\r\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\r\n */\n\n\nfunction verifySchema(inputBuffer, inputSchema) {\n  //region Initial check\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema type\"\n      }\n    };\n  } //endregion\n  //region Decoding of raw ASN.1 data\n\n\n  const asn1 = fromBER(inputBuffer);\n\n  if (asn1.offset === -1) {\n    return {\n      verified: false,\n      result: asn1.result\n    };\n  } //endregion\n  //region Compare ASN.1 struct with input schema\n\n\n  return compareSchema(asn1.result, asn1.result, inputSchema); //endregion\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major function converting JSON to ASN.1 objects\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n\n/**\r\n * Converting from JSON to ASN.1 objects\r\n * @param {string|Object} json JSON string or object to convert to ASN.1 objects\r\n */\n\n\nfunction fromJSON(json) {} // TODO Implement\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//# sourceMappingURL=asn1.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/asn1js/build/asn1.js\n// module id = ./node_modules/asn1js/build/asn1.js\n// module chunks = 0 1 2 3 4","/*\r\n * Copyright (c) 2016-2018, Peculiar Ventures\r\n * All rights reserved.\r\n *\r\n * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\r\n *\r\n */\r\n//**************************************************************************************\r\nexport class ByteStream\r\n{\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleLoopsJS\r\n\t/**\r\n\t * Constructor for ByteStream class\r\n\t * @param {{[length]: number, [stub]: number, [view]: Uint8Array, [buffer]: ArrayBuffer, [string]: string, [hexstring]: string}} parameters\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tthis.clear();\r\n\t\t\r\n\t\tfor(const key of Object.keys(parameters))\r\n\t\t{\r\n\t\t\tswitch(key)\r\n\t\t\t{\r\n\t\t\t\tcase \"length\":\r\n\t\t\t\t\tthis.length = parameters.length;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"stub\":\r\n\t\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\t\tfor(let i = 0; i < this._view.length; i++)\r\n\t\t\t\t\t\tthis._view[i] = parameters.stub;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"view\":\r\n\t\t\t\t\tthis.fromUint8Array(parameters.view);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"buffer\":\r\n\t\t\t\t\tthis.fromArrayBuffer(parameters.buffer);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tthis.fromString(parameters.string);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"hexstring\":\r\n\t\t\t\t\tthis.fromHexString(parameters.hexstring);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Setter for \"buffer\"\r\n\t * @param {ArrayBuffer} value\r\n\t */\r\n\tset buffer(value)\r\n\t{\r\n\t\tthis._buffer = value.slice(0);\r\n\t\tthis._view = new Uint8Array(this._buffer);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Getter for \"buffer\"\r\n\t * @returns {ArrayBuffer}\r\n\t */\r\n\tget buffer()\r\n\t{\r\n\t\treturn this._buffer;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Setter for \"view\"\r\n\t * @param {Uint8Array} value\r\n\t */\r\n\tset view(value)\r\n\t{\r\n\t\tthis._buffer = new ArrayBuffer(value.length);\r\n\t\tthis._view = new Uint8Array(this._buffer);\r\n\t\t\r\n\t\tthis._view.set(value);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Getter for \"view\"\r\n\t * @returns {Uint8Array}\r\n\t */\r\n\tget view()\r\n\t{\r\n\t\treturn this._view;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Getter for \"length\"\r\n\t * @returns {number}\r\n\t */\r\n\tget length()\r\n\t{\r\n\t\treturn this._buffer.byteLength;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Setter for \"length\"\r\n\t * @param {number} value\r\n\t */\r\n\tset length(value)\r\n\t{\r\n\t\tthis._buffer = new ArrayBuffer(value);\r\n\t\tthis._view = new Uint8Array(this._buffer);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Clear existing stream\r\n\t */\r\n\tclear()\r\n\t{\r\n\t\tthis._buffer = new ArrayBuffer(0);\r\n\t\tthis._view = new Uint8Array(this._buffer);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Initialize \"Stream\" object from existing \"ArrayBuffer\"\r\n\t * @param {!ArrayBuffer} array The ArrayBuffer to copy from\r\n\t */\r\n\tfromArrayBuffer(array)\r\n\t{\r\n\t\tthis.buffer = array;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionNamingConventionJS\r\n\t/**\r\n\t * Initialize \"Stream\" object from existing \"Uint8Array\"\r\n\t * @param {!Uint8Array} array The Uint8Array to copy from\r\n\t */\r\n\tfromUint8Array(array)\r\n\t{\r\n\t\tthis._buffer = new ArrayBuffer(array.length);\r\n\t\tthis._view = new Uint8Array(this._buffer);\r\n\t\t\r\n\t\tthis._view.set(array);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Initialize \"Stream\" object from existing string\r\n\t * @param {string} string The string to initialize from\r\n\t */\r\n\tfromString(string)\r\n\t{\r\n\t\tconst stringLength = string.length;\r\n\t\t\r\n\t\tthis.length = stringLength;\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tfor(let i = 0; i < stringLength; i++)\r\n\t\t\tthis.view[i] = string.charCodeAt(i);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Represent \"Stream\" object content as a string\r\n\t * @param {number} [start] Start position to convert to string\r\n\t * @param {number} [length] Length of array to convert to string\r\n\t * @returns {string}\r\n\t */\r\n\ttoString(start = 0, length = (this.view.length - start))\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet result = \"\";\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Check input parameters\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((start >= this.view.length) || (start < 0))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((length >= this.view.length) || (length < 0))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.view.length - start;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Convert array of bytes to string\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tfor(let i = start; i < (start + length); i++)\r\n\t\t\tresult += String.fromCharCode(this.view[i]);\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionTooLongJS\r\n\t/**\r\n\t * Initialize \"Stream\" object from existing hexdecimal string\r\n\t * @param {string} hexString String to initialize from\r\n\t */\r\n\tfromHexString(hexString)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst stringLength = hexString.length;\r\n\t\t\r\n\t\tthis.buffer = new ArrayBuffer(stringLength >> 1);\r\n\t\tthis.view = new Uint8Array(this.buffer);\r\n\t\t\r\n\t\tconst hexMap = new Map();\r\n\t\t\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"0\", 0x00);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"1\", 0x01);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"2\", 0x02);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"3\", 0x03);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"4\", 0x04);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"5\", 0x05);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"6\", 0x06);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"7\", 0x07);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"8\", 0x08);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"9\", 0x09);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"A\", 0x0A);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"a\", 0x0A);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"B\", 0x0B);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"b\", 0x0B);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"C\", 0x0C);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"c\", 0x0C);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"D\", 0x0D);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"d\", 0x0D);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"E\", 0x0E);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"e\", 0x0E);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"F\", 0x0F);\r\n\t\t// noinspection MagicNumberJS\r\n\t\thexMap.set(\"f\", 0x0F);\r\n\t\t\r\n\t\tlet j = 0;\r\n\t\t// noinspection MagicNumberJS\r\n\t\tlet temp = 0x00;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Convert char-by-char\r\n\t\tfor(let i = 0; i < stringLength; i++)\r\n\t\t{\r\n\t\t\t// noinspection NegatedIfStatementJS\r\n\t\t\tif(!(i % 2))\r\n\t\t\t{\r\n\t\t\t\t// noinspection NestedFunctionCallJS\r\n\t\t\t\ttemp = hexMap.get(hexString.charAt(i)) << 4;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// noinspection NestedFunctionCallJS\r\n\t\t\t\ttemp |= hexMap.get(hexString.charAt(i));\r\n\t\t\t\t\r\n\t\t\t\tthis.view[j] = temp;\r\n\t\t\t\tj++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Represent \"Stream\" object content as a hexdecimal string\r\n\t * @param {number} [start=0] Start position to convert to string\r\n\t * @param {number} [length=(this.view.length - start)] Length of array to convert to string\r\n\t * @returns {string}\r\n\t */\r\n\ttoHexString(start = 0, length = (this.view.length - start))\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet result = \"\";\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Check input parameters\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((start >= this.view.length) || (start < 0))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((length >= this.view.length) || (length < 0))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.view.length - start;\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\tfor(let i = start; i < (start + length); i++)\r\n\t\t{\r\n\t\t\t// noinspection ChainedFunctionCallJS\r\n\t\t\tconst str = this.view[i].toString(16).toUpperCase();\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS\r\n\t\t\tresult = result + ((str.length == 1) ? \"0\" : \"\") + str;\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Return copy of existing \"Stream\"\r\n\t * @param {number} [start=0] Start position of the copy\r\n\t * @param {number} [length=this.view.length] Length of the copy\r\n\t * @returns {ByteStream}\r\n\t */\r\n\tcopy(start = 0, length = (this._buffer.byteLength - start))\r\n\t{\r\n\t\t//region Check input parameters\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif((start === 0) && (this._buffer.byteLength === 0))\r\n\t\t\treturn new ByteStream();\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif((start < 0) || (start > (this._buffer.byteLength - 1)))\r\n\t\t\tthrow new Error(`Wrong start position: ${start}`);\r\n\t\t//endregion\r\n\t\t\r\n\t\tconst stream = new ByteStream();\r\n\t\t\r\n\t\tstream._buffer = this._buffer.slice(start, start + length);\r\n\t\tstream._view = new Uint8Array(stream._buffer);\r\n\t\t\r\n\t\treturn stream;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Return slice of existing \"Stream\"\r\n\t * @param {number} [start=0] Start position of the slice\r\n\t * @param {number} [end=this._buffer.byteLength] End position of the slice\r\n\t * @returns {ByteStream}\r\n\t */\r\n\tslice(start = 0, end = this._buffer.byteLength)\r\n\t{\r\n\t\t//region Check input parameters\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif((start === 0) && (this._buffer.byteLength === 0))\r\n\t\t\treturn new ByteStream();\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif((start < 0) || (start > (this._buffer.byteLength - 1)))\r\n\t\t\tthrow new Error(`Wrong start position: ${start}`);\r\n\t\t//endregion\r\n\t\t\r\n\t\tconst stream = new ByteStream();\r\n\t\t\r\n\t\tstream._buffer = this._buffer.slice(start, end);\r\n\t\tstream._view = new Uint8Array(stream._buffer);\r\n\t\t\r\n\t\treturn stream;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Change size of existing \"Stream\"\r\n\t * @param {!number} size Size for new \"Stream\"\r\n\t */\r\n\trealloc(size)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst buffer = new ArrayBuffer(size);\r\n\t\tconst view = new Uint8Array(buffer);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Create a new ArrayBuffer content\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(size > this._view.length)\r\n\t\t\tview.set(this._view);\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection NestedFunctionCallJS\r\n\t\t\tview.set(new Uint8Array(this._buffer, 0, size));\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Initialize \"Stream\" with new \"ArrayBuffer\"\r\n\t\tthis._buffer = buffer.slice(0);\r\n\t\tthis._view = new Uint8Array(this._buffer);\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Append a new \"Stream\" content to the current \"Stream\"\r\n\t * @param {ByteStream} stream A new \"stream\" to append to current \"stream\"\r\n\t */\r\n\tappend(stream)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst initialSize = this._buffer.byteLength;\r\n\t\tconst streamViewLength = stream._buffer.byteLength;\r\n\t\t\r\n\t\tconst copyView = stream._view.slice();\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Re-allocate current internal buffer\r\n\t\tthis.realloc(initialSize + streamViewLength);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Copy input stream content to a new place\r\n\t\tthis._view.set(copyView, initialSize);\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Insert \"Stream\" content to the current \"Stream\" at specific position\r\n\t * @param {ByteStream} stream A new \"stream\" to insert to current \"stream\"\r\n\t * @param {number} [start=0] Start position to insert to\r\n\t * @param {number} [length]\r\n\t * @returns {boolean}\r\n\t */\r\n\tinsert(stream, start = 0, length = (this._buffer.byteLength - start))\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(start > (this._buffer.byteLength - 1))\r\n\t\t\treturn false;\r\n\t\t\r\n\t\tif(length > (this._buffer.byteLength - start))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this._buffer.byteLength - start;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Check input variables\r\n\t\tif(length > stream._buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = stream._buffer.byteLength;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Update content of the current stream\r\n\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(length == stream._buffer.byteLength)\r\n\t\t\tthis._view.set(stream._view, start);\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection NestedFunctionCallJS\r\n\t\t\tthis._view.set(stream._view.slice(0, length), start);\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Check that two \"Stream\" objects has equal content\r\n\t * @param {ByteStream} stream Stream to compare with\r\n\t * @returns {boolean}\r\n\t */\r\n\tisEqual(stream)\r\n\t{\r\n\t\t//region Check length of both buffers\r\n\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(this._buffer.byteLength != stream._buffer.byteLength)\r\n\t\t\treturn false;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Compare each byte of both buffers\r\n\t\tfor(let i = 0; i < stream._buffer.byteLength; i++)\r\n\t\t{\r\n\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\t\tif(this.view[i] != stream.view[i])\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Check that current \"Stream\" objects has equal content with input \"Uint8Array\"\r\n\t * @param {Uint8Array} view View to compare with\r\n\t * @returns {boolean}\r\n\t */\r\n\tisEqualView(view)\r\n\t{\r\n\t\t//region Check length of both buffers\r\n\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(view.length != this.view.length)\r\n\t\t\treturn false;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Compare each byte of both buffers\r\n\t\tfor(let i = 0; i < view.length; i++)\r\n\t\t{\r\n\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\t\tif(this.view[i] != view[i])\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS\r\n\t/**\r\n\t * Find any byte pattern in \"Stream\"\r\n\t * @param {ByteStream} pattern Stream having pattern value\r\n\t * @param {?number} [start] Start position to search from\r\n\t * @param {?number} [length] Length of byte block to search at\r\n\t * @param {boolean} [backward] Flag to search in backward order\r\n\t * @returns {number}\r\n\t */\r\n\tfindPattern(pattern, start = null, length = null, backward = false)\r\n\t{\r\n\t\t//region Check input variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\r\n\t\t\tstart = (backward) ? this.buffer.byteLength : 0;\r\n\t\t}\r\n\t\t\r\n\t\tif(start > this.buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = this.buffer.byteLength;\r\n\t\t}\r\n\t\t\r\n\t\tif(backward)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > start)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Initial variables\r\n\t\tconst patternLength = pattern.buffer.byteLength;\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(patternLength > length)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Make a \"pre-read\" array for pattern\r\n\t\tconst patternArray = [];\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tfor(let i = 0; i < patternLength; i++)\r\n\t\t\tpatternArray.push(pattern.view[i]);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Search for pattern\r\n\t\tfor(let i = 0; i <= (length - patternLength); i++)\r\n\t\t{\r\n\t\t\tlet equal = true;\r\n\t\t\t// noinspection ConditionalExpressionJS\r\n\t\t\tconst equalStart = (backward) ? (start - patternLength - i) : (start + i);\r\n\t\t\t\r\n\t\t\tfor(let j = 0; j < patternLength; j++)\r\n\t\t\t{\r\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\t\tif(this.view[j + equalStart] != patternArray[j])\r\n\t\t\t\t{\r\n\t\t\t\t\tequal = false;\r\n\t\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(equal)\r\n\t\t\t{\r\n\t\t\t\t// noinspection ConditionalExpressionJS\r\n\t\t\t\treturn (backward) ? (start - patternLength - i) : (start + patternLength + i); // Position after the pattern found\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn (-1);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection OverlyComplexFunctionJS\r\n\t/**\r\n\t * Find first position of any pattern from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be found\r\n\t * @param {?number} [start] Start position to search from\r\n\t * @param {?number} [length] Length of byte block to search at\r\n\t * @param {boolean} [backward=false] Flag to search in backward order\r\n\t * @returns {{id: number, position: number}}\r\n\t */\r\n\tfindFirstIn(patterns, start = null, length = null, backward = false)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\r\n\t\t\tstart = (backward) ? this.buffer.byteLength : 0;\r\n\t\t}\r\n\t\t\r\n\t\tif(start > this.buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = this.buffer.byteLength;\r\n\t\t}\r\n\t\t\r\n\t\tif(backward)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > start)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tconst result = {\r\n\t\t\tid: (-1),\r\n\t\t\tposition: (backward) ? 0 : (start + length),\r\n\t\t\tlength: 0\r\n\t\t};\r\n\t\t//endregion\r\n\t\t\r\n\t\tfor(let i = 0; i < patterns.length; i++)\r\n\t\t{\r\n\t\t\tconst position = this.findPattern(patterns[i], start, length, backward);\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\tif(position != (-1))\r\n\t\t\t{\r\n\t\t\t\tlet valid = false;\r\n\t\t\t\tconst patternLength = patterns[i].length;\r\n\r\n\t\t\t\tif(backward)\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\t\tif((position - patternLength) >= (result.position - result.length))\r\n\t\t\t\t\t\tvalid = true;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\t\tif((position - patternLength) <= (result.position - result.length))\r\n\t\t\t\t\t\tvalid = true;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(valid)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult.position = position;\r\n\t\t\t\t\tresult.id = i;\r\n\t\t\t\t\tresult.length = patternLength;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Find all positions of any pattern from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be found\r\n\t * @param {?number} [start] Start position to search from\r\n\t * @param {?number} [length] Length of byte block to search at\r\n\t * @returns {Array}\r\n\t */\r\n\tfindAllIn(patterns, start = 0, length = (this.buffer.byteLength - start))\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst result = [];\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(start > (this.buffer.byteLength - 1))\r\n\t\t\treturn result;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(length == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\r\n\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tlet patternFound = {\r\n\t\t\tid: (-1),\r\n\t\t\tposition: start\r\n\t\t};\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find all accurences of patterns\r\n\t\tdo\r\n\t\t{\r\n\t\t\tconst position = patternFound.position;\r\n\t\t\t\r\n\t\t\tpatternFound = this.findFirstIn(patterns, patternFound.position, length);\r\n\t\t\t\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\tif(patternFound.id == (-1))\r\n\t\t\t{\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength -= (patternFound.position - position);\r\n\t\t\t\r\n\t\t\tresult.push({\r\n\t\t\t\tid: patternFound.id,\r\n\t\t\t\tposition: patternFound.position\r\n\t\t\t});\r\n\t\t} while(true); // eslint-disable-line\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Find all positions of a pattern\r\n\t * @param {ByteStream} pattern Stream having pattern value\r\n\t * @param {?number} [start] Start position to search from\r\n\t * @param {?number} [length] Length of byte block to search at\r\n\t * @returns {Array|number} Array with all pattern positions or (-1) if failed\r\n\t */\r\n\tfindAllPatternIn(pattern, start = 0, length = (this.buffer.byteLength - start))\r\n\t{\r\n\t\t//region Check input variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\tif(start > this.buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = this.buffer.byteLength;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(length == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Initial variables\r\n\t\tconst result = [];\r\n\t\t\r\n\t\tconst patternLength = pattern.buffer.byteLength;\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(patternLength > length)\r\n\t\t\treturn (-1);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Make a \"pre-read\" array for pattern\r\n\t\tconst patternArray = Array.from(pattern.view);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Search for pattern\r\n\t\tfor(let i = 0; i <= (length - patternLength); i++)\r\n\t\t{\r\n\t\t\tlet equal = true;\r\n\t\t\tconst equalStart = start + i;\r\n\t\t\t\r\n\t\t\tfor(let j = 0; j < patternLength; j++)\r\n\t\t\t{\r\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\t\tif(this.view[j + equalStart] != patternArray[j])\r\n\t\t\t\t{\r\n\t\t\t\t\tequal = false;\r\n\t\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(equal)\r\n\t\t\t{\r\n\t\t\t\tresult.push(start + patternLength + i); // Position after the pattern found\r\n\t\t\t\ti += (patternLength - 1); // On next step of \"for\" we will have \"i++\"\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection OverlyComplexFunctionJS, FunctionTooLongJS\r\n\t/**\r\n\t * Find first position of data, not included in patterns from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\r\n\t * @param {?number} [start] Start position to search from\r\n\t * @param {?number} [length] Length of byte block to search at\r\n\t * @param {boolean} [backward=false] Flag to search in backward order\r\n\t * @returns {{left: {id: number, position: *}, right: {id: number, position: number}, value: ByteStream}}\r\n\t */\r\n\tfindFirstNotIn(patterns, start = null, length = null, backward = false)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\r\n\t\t\tstart = (backward) ? this.buffer.byteLength : 0;\r\n\t\t}\r\n\t\t\r\n\t\tif(start > this.buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = this.buffer.byteLength;\r\n\t\t}\r\n\t\t\r\n\t\tif(backward)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > start)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tconst result = {\r\n\t\t\tleft: {\r\n\t\t\t\tid: (-1),\r\n\t\t\t\tposition: start\r\n\t\t\t},\r\n\t\t\tright: {\r\n\t\t\t\tid: (-1),\r\n\t\t\t\tposition: 0\r\n\t\t\t},\r\n\t\t\tvalue: new ByteStream()\r\n\t\t};\r\n\t\t\r\n\t\tlet currentLength = length;\r\n\t\t//endregion\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\twhile(currentLength > 0)\r\n\t\t{\r\n\t\t\t//region Search for nearest \"pattern\"\r\n\t\t\t// noinspection ConditionalExpressionJS\r\n\t\t\tresult.right = this.findFirstIn(patterns,\r\n\t\t\t\t(backward) ? (start - length + currentLength) : (start + length - currentLength),\r\n\t\t\t\tcurrentLength,\r\n\t\t\t\tbackward);\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\t//region No pattern at all\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\tif(result.right.id == (-1))\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = currentLength;\r\n\t\t\t\t\r\n\t\t\t\tif(backward)\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\t\tstart -= length;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\t\tstart = result.left.position;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tresult.value = new ByteStream();\r\n\t\t\t\t\r\n\t\t\t\tresult.value._buffer = this._buffer.slice(start, start + length);\r\n\t\t\t\tresult.value._view = new Uint8Array(result.value._buffer);\r\n\t\t\t\t\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\t//region Check distance between two patterns\r\n\t\t\t// noinspection ConditionalExpressionJS, EqualityComparisonWithCoercionJS\r\n\t\t\tif(result.right.position != ((backward) ? (result.left.position - patterns[result.right.id].buffer.byteLength) : (result.left.position + patterns[result.right.id].buffer.byteLength)))\r\n\t\t\t{\r\n\t\t\t\tif(backward)\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\t\tstart = result.right.position + patterns[result.right.id].buffer.byteLength;\r\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\t\tlength = result.left.position - result.right.position - patterns[result.right.id].buffer.byteLength;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\t\tstart = result.left.position;\r\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\t\tlength = result.right.position - result.left.position - patterns[result.right.id].buffer.byteLength;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tresult.value = new ByteStream();\r\n\t\t\t\t\r\n\t\t\t\tresult.value._buffer = this._buffer.slice(start, start + length);\r\n\t\t\t\tresult.value._view = new Uint8Array(result.value._buffer);\r\n\t\t\t\t\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\t//region Store information about previous pattern\r\n\t\t\tresult.left = result.right;\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\t//region Change current length\r\n\t\t\tcurrentLength -= patterns[result.right.id]._buffer.byteLength;\r\n\t\t\t//endregion\r\n\t\t}\r\n\t\t\r\n\t\t//region Swap \"patterns\" in case of backward order\r\n\t\tif(backward)\r\n\t\t{\r\n\t\t\tconst temp = result.right;\r\n\t\t\tresult.right = result.left;\r\n\t\t\tresult.left = temp;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Find all positions of data, not included in patterns from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\r\n\t * @param {?number} [start] Start position to search from\r\n\t * @param {?number} [length] Length of byte block to search at\r\n\t * @returns {Array}\r\n\t */\r\n\tfindAllNotIn(patterns, start = null, length = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst result = [];\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(start > (this.buffer.byteLength - 1))\r\n\t\t\treturn result;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(length == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tlet patternFound = {\r\n\t\t\tleft: {\r\n\t\t\t\tid: (-1),\r\n\t\t\t\tposition: start\r\n\t\t\t},\r\n\t\t\tright: {\r\n\t\t\t\tid: (-1),\r\n\t\t\t\tposition: start\r\n\t\t\t},\r\n\t\t\tvalue: new ByteStream()\r\n\t\t};\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find all accurences of patterns\r\n\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\tdo\r\n\t\t{\r\n\t\t\tconst position = patternFound.right.position;\r\n\t\t\t\r\n\t\t\tpatternFound = this.findFirstNotIn(patterns, patternFound.right.position, length);\r\n\t\t\t\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength -= (patternFound.right.position - position);\r\n\t\t\t\r\n\t\t\tresult.push({\r\n\t\t\t\tleft: {\r\n\t\t\t\t\tid: patternFound.left.id,\r\n\t\t\t\t\tposition: patternFound.left.position\r\n\t\t\t\t},\r\n\t\t\t\tright: {\r\n\t\t\t\t\tid: patternFound.right.id,\r\n\t\t\t\t\tposition: patternFound.right.position\r\n\t\t\t\t},\r\n\t\t\t\tvalue: patternFound.value\r\n\t\t\t});\r\n\t\t} while(patternFound.right.id != (-1));\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS\r\n\t/**\r\n\t * Find position of a sequence of any patterns from input array\r\n\t * @param {Array.<ByteStream>} patterns Array of pattern to look for\r\n\t * @param {?number} [start] Start position to search from\r\n\t * @param {?number} [length] Length of byte block to search at\r\n\t * @param {boolean} [backward=false] Flag to search in backward order\r\n\t * @returns {*}\r\n\t */\r\n\tfindFirstSequence(patterns, start = null, length = null, backward = false)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\r\n\t\t\tstart = (backward) ? this.buffer.byteLength : 0;\r\n\t\t}\r\n\t\t\r\n\t\tif(start > this.buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = this.buffer.byteLength;\r\n\t\t}\r\n\t\t\r\n\t\tif(backward)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > start)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find first byte from sequence\r\n\t\tconst firstIn = this.skipNotPatterns(patterns, start, length, backward);\r\n\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\tif(firstIn == (-1))\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tposition: (-1),\r\n\t\t\t\tvalue: new ByteStream()\r\n\t\t\t};\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find first byte not in sequence\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tconst firstNotIn = this.skipPatterns(patterns,\r\n\t\t\tfirstIn,\r\n\t\t\tlength - ((backward) ? (start - firstIn) : (firstIn - start)),\r\n\t\t\tbackward);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Make output value\r\n\t\tif(backward)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = firstNotIn;\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = (firstIn - firstNotIn);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = firstIn;\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = (firstNotIn - firstIn);\r\n\t\t}\r\n\t\t\r\n\t\tconst value = new ByteStream();\r\n\t\t\r\n\t\tvalue._buffer = this._buffer.slice(start, start + length);\r\n\t\tvalue._view = new Uint8Array(value._buffer);\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn {\r\n\t\t\tposition: firstNotIn,\r\n\t\t\tvalue\r\n\t\t};\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Find all positions of a sequence of any patterns from input array\r\n\t * @param {Array.<ByteStream>} patterns Array of patterns to search for\r\n\t * @param {?number} [start] Start position to search from\r\n\t * @param {?number} [length] Length of byte block to search at\r\n\t * @returns {Array}\r\n\t */\r\n\tfindAllSequences(patterns, start = null, length = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst result = [];\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(start > (this.buffer.byteLength - 1))\r\n\t\t\treturn result;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(length == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tlet patternFound = {\r\n\t\t\tposition: start,\r\n\t\t\tvalue: new ByteStream()\r\n\t\t};\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find all accurences of patterns\r\n\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\tdo\r\n\t\t{\r\n\t\t\tconst position = patternFound.position;\r\n\t\t\t\r\n\t\t\tpatternFound = this.findFirstSequence(patterns, patternFound.position, length);\r\n\t\t\t\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\tif(patternFound.position != (-1))\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength -= (patternFound.position - position);\r\n\t\t\t\t\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\tposition: patternFound.position,\r\n\t\t\t\t\tvalue: patternFound.value\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} while(patternFound.position != (-1));\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS\r\n\t/**\r\n\t * Find all paired patterns in the stream\r\n\t * @param {ByteStream} leftPattern Left pattern to search for\r\n\t * @param {ByteStream} rightPattern Right pattern to search for\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @returns {Array}\r\n\t */\r\n\tfindPairedPatterns(leftPattern, rightPattern, start = null, length = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst result = [];\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(leftPattern.isEqual(rightPattern))\r\n\t\t\treturn result;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(start > (this.buffer.byteLength - 1))\r\n\t\t\treturn result;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(length == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tlet currentPositionLeft = 0;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find all \"left patterns\" as sorted array\r\n\t\tconst leftPatterns = this.findAllPatternIn(leftPattern, start, length);\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(leftPatterns.length == 0)\r\n\t\t\treturn result;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find all \"right patterns\" as sorted array\r\n\t\tconst rightPatterns = this.findAllPatternIn(rightPattern, start, length);\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(rightPatterns.length == 0)\r\n\t\t\treturn result;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Combine patterns\r\n\t\twhile(currentPositionLeft < leftPatterns.length)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS\r\n\t\t\tif(rightPatterns.length == 0)\r\n\t\t\t{\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\tif(leftPatterns[0] == rightPatterns[0])\r\n\t\t\t{\r\n\t\t\t\t// Possible situation when one pattern is a part of another\r\n\t\t\t\t// For example \"stream\" and \"endstream\"\r\n\t\t\t\t// In case when we have only \"endstream\" in fact \"stream\" will be also found at the same position\r\n\t\t\t\t// (position of the pattern is an index AFTER the pattern)\r\n\t\t\t\t\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\tleft: leftPatterns[0],\r\n\t\t\t\t\tright: rightPatterns[0]\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tleftPatterns.splice(0, 1);\r\n\t\t\t\trightPatterns.splice(0, 1);\r\n\t\t\t\t\r\n\t\t\t\t// noinspection ContinueStatementJS\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(leftPatterns[currentPositionLeft] > rightPatterns[0])\r\n\t\t\t{\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\twhile(leftPatterns[currentPositionLeft] < rightPatterns[0])\r\n\t\t\t{\r\n\t\t\t\tcurrentPositionLeft++;\r\n\t\t\t\t\r\n\t\t\t\tif(currentPositionLeft >= leftPatterns.length)\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresult.push({\r\n\t\t\t\tleft: leftPatterns[currentPositionLeft - 1],\r\n\t\t\t\tright: rightPatterns[0]\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tleftPatterns.splice(currentPositionLeft - 1, 1);\r\n\t\t\trightPatterns.splice(0, 1);\r\n\t\t\t\r\n\t\t\tcurrentPositionLeft = 0;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Sort result\r\n\t\tresult.sort((a, b) => (a.left - b.left));\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS\r\n\t/**\r\n\t * Find all paired patterns in the stream\r\n\t * @param {Array.<ByteStream>} inputLeftPatterns Array of left patterns to search for\r\n\t * @param {Array.<ByteStream>} inputRightPatterns Array of right patterns to search for\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @returns {Array}\r\n\t */\r\n\tfindPairedArrays(inputLeftPatterns, inputRightPatterns, start = null, length = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst result = [];\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(start > (this.buffer.byteLength - 1))\r\n\t\t\treturn result;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(length == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tlet currentPositionLeft = 0;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find all \"left patterns\" as sorted array\r\n\t\tconst leftPatterns = this.findAllIn(inputLeftPatterns, start, length);\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(leftPatterns.length == 0)\r\n\t\t\treturn result;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find all \"right patterns\" as sorted array\r\n\t\tconst rightPatterns = this.findAllIn(inputRightPatterns, start, length);\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(rightPatterns.length == 0)\r\n\t\t\treturn result;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Combine patterns\r\n\t\twhile(currentPositionLeft < leftPatterns.length)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS\r\n\t\t\tif(rightPatterns.length == 0)\r\n\t\t\t{\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\tif(leftPatterns[0].position == rightPatterns[0].position)\r\n\t\t\t{\r\n\t\t\t\t// Possible situation when one pattern is a part of another\r\n\t\t\t\t// For example \"stream\" and \"endstream\"\r\n\t\t\t\t// In case when we have only \"endstream\" in fact \"stream\" will be also found at the same position\r\n\t\t\t\t// (position of the pattern is an index AFTER the pattern)\r\n\t\t\t\t\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\tleft: leftPatterns[0],\r\n\t\t\t\t\tright: rightPatterns[0]\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tleftPatterns.splice(0, 1);\r\n\t\t\t\trightPatterns.splice(0, 1);\r\n\t\t\t\t\r\n\t\t\t\t// noinspection ContinueStatementJS\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(leftPatterns[currentPositionLeft].position > rightPatterns[0].position)\r\n\t\t\t{\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\twhile(leftPatterns[currentPositionLeft].position < rightPatterns[0].position)\r\n\t\t\t{\r\n\t\t\t\tcurrentPositionLeft++;\r\n\t\t\t\t\r\n\t\t\t\tif(currentPositionLeft >= leftPatterns.length)\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresult.push({\r\n\t\t\t\tleft: leftPatterns[currentPositionLeft - 1],\r\n\t\t\t\tright: rightPatterns[0]\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tleftPatterns.splice(currentPositionLeft - 1, 1);\r\n\t\t\trightPatterns.splice(0, 1);\r\n\t\t\t\r\n\t\t\tcurrentPositionLeft = 0;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Sort result\r\n\t\tresult.sort((a, b) => (a.left.position - b.left.position));\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS, FunctionTooLongJS\r\n\t/**\r\n\t * Replace one patter with other\r\n\t * @param {ByteStream} searchPattern The pattern to search for\r\n\t * @param {ByteStream} replacePattern The pattern to replace initial pattern\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @param {Array|null} [findAllResult=null] Pre-calculated results of \"findAllIn\"\r\n\t * @returns {*}\r\n\t */\r\n\treplacePattern(searchPattern, replacePattern, start = null, length = null, findAllResult = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet result;\r\n\t\t\r\n\t\tlet i;\r\n\t\tconst output = {\r\n\t\t\tstatus: (-1),\r\n\t\t\tsearchPatternPositions: [],\r\n\t\t\treplacePatternPositions: []\r\n\t\t};\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(start > (this.buffer.byteLength - 1))\r\n\t\t\treturn false;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(length == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t\r\n\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find a pattern to search for\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif(findAllResult == null)\r\n\t\t{\r\n\t\t\tresult = this.findAllIn([searchPattern], start, length);\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\t\tif(result.length == 0)\r\n\t\t\t\treturn output;\r\n\t\t}\r\n\t\telse\r\n\t\t\tresult = findAllResult;\r\n\t\t\r\n\t\t// noinspection NestedFunctionCallJS\r\n\t\toutput.searchPatternPositions.push(...Array.from(result, element => element.position));\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Variables for new buffer initialization\r\n\t\tconst patternDifference = searchPattern.buffer.byteLength - replacePattern.buffer.byteLength;\r\n\t\t\r\n\t\tconst changedBuffer = new ArrayBuffer(this.view.length - (result.length * patternDifference));\r\n\t\tconst changedView = new Uint8Array(changedBuffer);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Copy data from 0 to start\r\n\t\t// noinspection NestedFunctionCallJS\r\n\t\tchangedView.set(new Uint8Array(this.buffer, 0, start));\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Replace pattern\r\n\t\tfor(i = 0; i < result.length; i++)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS\r\n\t\t\tconst currentPosition = (i == 0) ? start : result[i - 1].position;\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\t//region Copy bytes other then search pattern\r\n\t\t\t// noinspection NestedFunctionCallJS\r\n\t\t\tchangedView.set(new Uint8Array(this.buffer, currentPosition, result[i].position - searchPattern.buffer.byteLength - currentPosition), currentPosition - i * patternDifference);\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\t//region Put replace pattern in a new buffer\r\n\t\t\tchangedView.set(replacePattern.view, result[i].position - searchPattern.buffer.byteLength - i * patternDifference);\r\n\t\t\t\r\n\t\t\toutput.replacePatternPositions.push(result[i].position - searchPattern.buffer.byteLength - i * patternDifference);\r\n\t\t\t//endregion\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Copy data from the end of old buffer\r\n\t\ti--;\r\n\t\t// noinspection NestedFunctionCallJS\r\n\t\tchangedView.set(new Uint8Array(this.buffer, result[i].position, this.buffer.byteLength - result[i].position), result[i].position - searchPattern.buffer.byteLength + replacePattern.buffer.byteLength - i * patternDifference);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Re-initialize existing buffer\r\n\t\tthis.buffer = changedBuffer;\r\n\t\tthis.view = new Uint8Array(this.buffer);\r\n\t\t//endregion\r\n\t\t\r\n\t\toutput.status = 1;\r\n\t\t\r\n\t\treturn output;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS\r\n\t/**\r\n\t * Skip any pattern from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @param {boolean} [backward=false] Flag to search in backward order\r\n\t * @returns {*}\r\n\t */\r\n\tskipPatterns(patterns, start = null, length = null, backward = false)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\r\n\t\t\tstart = (backward) ? this.buffer.byteLength : 0;\r\n\t\t}\r\n\t\t\r\n\t\tif(start > this.buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = this.buffer.byteLength;\r\n\t\t}\r\n\t\t\r\n\t\tif(backward)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > start)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tlet result = start;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Search for pattern\r\n\t\tfor(let k = 0; k < patterns.length; k++)\r\n\t\t{\r\n\t\t\tconst patternLength = patterns[k].buffer.byteLength;\r\n\t\t\t// noinspection ConditionalExpressionJS\r\n\t\t\tconst equalStart = (backward) ? (result - patternLength) : (result);\r\n\t\t\tlet equal = true;\r\n\t\t\t\r\n\t\t\tfor(let j = 0; j < patternLength; j++)\r\n\t\t\t{\r\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\t\tif(this.view[j + equalStart] != patterns[k].view[j])\r\n\t\t\t\t{\r\n\t\t\t\t\tequal = false;\r\n\t\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(equal)\r\n\t\t\t{\r\n\t\t\t\tk = (-1);\r\n\t\t\t\t\r\n\t\t\t\tif(backward)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult -= patternLength;\r\n\t\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\t\t\t\tif(result <= 0)\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tresult += patternLength;\r\n\t\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\t\tif(result >= (start + length))\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionTooLongJS\r\n\t/**\r\n\t * Skip any pattern not from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should not be ommited\r\n\t * @param start\r\n\t * @param length\r\n\t * @param backward\r\n\t * @returns {number}\r\n\t */\r\n\tskipNotPatterns(patterns, start = null, length = null, backward = false)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\r\n\t\t\tstart = (backward) ? this.buffer.byteLength : 0;\r\n\t\t}\r\n\t\t\r\n\t\tif(start > this.buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = this.buffer.byteLength;\r\n\t\t}\r\n\t\t\r\n\t\tif(backward)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > start)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = start;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\t\tif(length == null)\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(length > (this.buffer.byteLength - start))\r\n\t\t\t{\r\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\t\tlength = this.buffer.byteLength - start;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tlet result = (-1);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Search for pattern\r\n\t\tfor(let i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tfor(let k = 0; k < patterns.length; k++)\r\n\t\t\t{\r\n\t\t\t\tconst patternLength = patterns[k].buffer.byteLength;\r\n\t\t\t\t// noinspection ConditionalExpressionJS\r\n\t\t\t\tconst equalStart = (backward) ? (start - i - patternLength) : (start + i);\r\n\t\t\t\tlet equal = true;\r\n\t\t\t\t\r\n\t\t\t\tfor(let j = 0; j < patternLength; j++)\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\t\t\tif(this.view[j + equalStart] != patterns[k].view[j])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tequal = false;\r\n\t\t\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(equal)\r\n\t\t\t\t{\r\n\t\t\t\t\t// noinspection ConditionalExpressionJS\r\n\t\t\t\t\tresult = (backward) ? (start - i) : (start + i); // Exact position of pattern found\r\n\t\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\tif(result != (-1))\r\n\t\t\t{\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nexport class SeqStream \r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"SeqStream\" class\r\n\t * @param {{[stream]: ByteStream, [length]: number, [backward]: boolean, [start]: number, [appendBlock]: number}} parameters\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\t/**\r\n\t\t * Major stream\r\n\t\t * @type {ByteStream}\r\n\t\t */\r\n\t\tthis.stream = new ByteStream();\r\n\t\t/**\r\n\t\t * Length of the major stream\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis._length = 0;\r\n\t\t/**\r\n\t\t * Flag to search in backward direction\r\n\t\t * @type {boolean}\r\n\t\t */\r\n\t\tthis.backward = false;\r\n\t\t/**\r\n\t\t * Start position to search\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis._start = 0;\r\n\t\t/**\r\n\t\t * Length of a block when append information to major stream\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis.appendBlock = 0;\r\n\t\t\r\n\t\tthis.prevLength = 0;\r\n\t\tthis.prevStart = 0;\r\n\t\t\r\n\t\tfor(const key of Object.keys(parameters))\r\n\t\t{\r\n\t\t\tswitch(key)\r\n\t\t\t{\r\n\t\t\t\tcase \"stream\":\r\n\t\t\t\t\tthis.stream = parameters.stream;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"backward\":\r\n\t\t\t\t\tthis.backward = parameters.backward;\r\n\t\t\t\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\t\t\t\tthis._start = this.stream.buffer.byteLength;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"length\":\r\n\t\t\t\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\t\t\t\tthis._length = parameters.length;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"start\":\r\n\t\t\t\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\t\t\t\tthis._start = parameters.start;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"appendBlock\":\r\n\t\t\t\t\tthis.appendBlock = parameters.appendBlock;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"view\":\r\n\t\t\t\t\tthis.stream = new ByteStream({ view: parameters.view});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"buffer\":\r\n\t\t\t\t\tthis.stream = new ByteStream({ buffer: parameters.buffer});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tthis.stream = new ByteStream({ string: parameters.string});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"hexstring\":\r\n\t\t\t\t\tthis.stream = new ByteStream({ hexstring: parameters.hexstring});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Setter for \"stream\" property\r\n\t * @param {ByteStream} value\r\n\t */\r\n\tset stream(value)\r\n\t{\r\n\t\tthis._stream = value;\r\n\t\t\r\n\t\tthis.prevLength = this._length;\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis._length = value._buffer.byteLength;\r\n\t\t\r\n\t\tthis.prevStart = this._start;\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis._start = 0;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Getter for \"stream\" property\r\n\t * @returns {ByteStream}\r\n\t */\r\n\tget stream()\r\n\t{\r\n\t\treturn this._stream;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Setter for \"length\" property\r\n\t * @param {number} value\r\n\t */\r\n\tset length(value)\r\n\t{\r\n\t\tthis.prevLength = this._length;\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis._length = value;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Getter for \"length\" property\r\n\t * @returns {number}\r\n\t */\r\n\tget length()\r\n\t{\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(this.appendBlock)\r\n\t\t\treturn this.start;\r\n\t\t\r\n\t\treturn this._length;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Setter for \"start\" property\r\n\t * @param {number} value\r\n\t */\r\n\tset start(value)\r\n\t{\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(value > this.stream.buffer.byteLength)\r\n\t\t\treturn;\r\n\t\t\r\n\t\t//region Initialization of \"prev\" internal variables\r\n\t\tthis.prevStart = this._start;\r\n\t\tthis.prevLength = this._length;\r\n\t\t//endregion\r\n\t\t\r\n\t\t// noinspection JSUnusedGlobalSymbols, ConditionalExpressionJS\r\n\t\tthis._length -= ((this.backward) ? (this._start - value) : (value - this._start));\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis._start = value;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Getter for \"start\" property\r\n\t * @returns {number}\r\n\t */\r\n\tget start()\r\n\t{\r\n\t\treturn this._start;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Return ArrayBuffer with having value of existing SeqStream length\r\n\t * @return {ArrayBuffer}\r\n\t */\r\n\tget buffer()\r\n\t{\r\n\t\treturn this._stream._buffer.slice(0, this._length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Reset current position of the \"SeqStream\"\r\n\t */\r\n\tresetPosition()\r\n\t{\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis._start = this.prevStart;\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis._length = this.prevLength;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Find any byte pattern in \"ByteStream\"\r\n\t * @param {ByteStream} pattern Stream having pattern value\r\n\t * @param {?number} [gap] Maximum gap between start position and position of nearest object\r\n\t * @returns {number}\r\n\t */\r\n\tfindPattern(pattern, gap = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((gap == null) || (gap > this.length))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tgap = this.length;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Find pattern\r\n\t\tconst result = this.stream.findPattern(pattern, this.start, this.length, this.backward);\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(result == (-1))\r\n\t\t\treturn result;\r\n\t\t\r\n\t\tif(this.backward)\r\n\t\t{\r\n\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\tif(result < (this.start - pattern.buffer.byteLength - gap))\r\n\t\t\t\treturn (-1);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\tif(result > (this.start + pattern.buffer.byteLength + gap))\r\n\t\t\t\treturn (-1);\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Create new values\r\n\t\tthis.start = result;\r\n\t\t//endregion ;\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Find first position of any pattern from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be found\r\n\t * @param {?number} [gap] Maximum gap between start position and position of nearest object\r\n\t * @returns {{id: number, position: number}}\r\n\t */\r\n\tfindFirstIn(patterns, gap = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((gap == null) || (gap > this.length))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tgap = this.length;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Search for patterns\r\n\t\tconst result = this.stream.findFirstIn(patterns, this.start, this.length, this.backward);\r\n\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(result.id == (-1))\r\n\t\t\treturn result;\r\n\t\t\r\n\t\tif(this.backward)\r\n\t\t{\r\n\t\t\tif(result.position < (this.start - patterns[result.id].buffer.byteLength - gap))\r\n\t\t\t{\r\n\t\t\t\t// noinspection ConditionalExpressionJS\r\n\t\t\t\treturn {\r\n\t\t\t\t\tid: (-1),\r\n\t\t\t\t\tposition: (this.backward) ? 0 : (this.start + this.length)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(result.position > (this.start + patterns[result.id].buffer.byteLength + gap))\r\n\t\t\t{\r\n\t\t\t\t// noinspection ConditionalExpressionJS\r\n\t\t\t\treturn {\r\n\t\t\t\t\tid: (-1),\r\n\t\t\t\t\tposition: (this.backward) ? 0 : (this.start + this.length)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Create new values\r\n\t\tthis.start = result.position;\r\n\t\t//endregion ;\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find all positions of any pattern from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be found\r\n\t * @returns {Array}\r\n\t */\r\n\tfindAllIn(patterns)\r\n\t{\r\n\t\t// In case of \"backward order\" the start position is at the end on stream.\r\n\t\t// In case of \"normal order\" the start position is at the begging of the stream.\r\n\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tconst start = (this.backward) ? (this.start - this.length) : this.start;\r\n\t\t\r\n\t\treturn this.stream.findAllIn(patterns, start, this.length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS\r\n\t/**\r\n\t * Find first position of data, not included in patterns from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\r\n\t * @param {?number} gap Maximum gap between start position and position of nearest object\r\n\t * @returns {*}\r\n\t */\r\n\tfindFirstNotIn(patterns, gap = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((gap == null) || (gap > this._length))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tgap = this._length;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Search for patterns\r\n\t\tconst result = this._stream.findFirstNotIn(patterns, this._start, this._length, this.backward);\r\n\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif((result.left.id == (-1)) && (result.right.id == (-1)))\r\n\t\t\treturn result;\r\n\t\t\r\n\t\tif(this.backward)\r\n\t\t{\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\tif(result.right.id != (-1))\r\n\t\t\t{\r\n\t\t\t\tif(result.right.position < (this._start - patterns[result.right.id]._buffer.byteLength - gap))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tleft: {\r\n\t\t\t\t\t\t\tid: (-1),\r\n\t\t\t\t\t\t\tposition: this._start\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tright: {\r\n\t\t\t\t\t\t\tid: (-1),\r\n\t\t\t\t\t\t\tposition: 0\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tvalue: new ByteStream()\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\tif(result.left.id != (-1))\r\n\t\t\t{\r\n\t\t\t\tif(result.left.position > (this._start + patterns[result.left.id]._buffer.byteLength + gap))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tleft: {\r\n\t\t\t\t\t\t\tid: (-1),\r\n\t\t\t\t\t\t\tposition: this._start\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tright: {\r\n\t\t\t\t\t\t\tid: (-1),\r\n\t\t\t\t\t\t\tposition: 0\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tvalue: new ByteStream()\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Create new values\r\n\t\tif(this.backward)\r\n\t\t{\r\n\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\t\tif(result.left.id == (-1))\r\n\t\t\t\tthis.start = 0;\r\n\t\t\telse\r\n\t\t\t\tthis.start = result.left.position;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\t\tif(result.right.id == (-1))\r\n\t\t\t\tthis.start = (this._start + this._length);\r\n\t\t\telse\r\n\t\t\t\tthis.start = result.right.position;\r\n\t\t}\r\n\t\t//endregion ;\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find all positions of data, not included in patterns from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\r\n\t * @returns {Array}\r\n\t */\r\n\tfindAllNotIn(patterns)\r\n\t{\r\n\t\t// In case of \"backward order\" the start position is at the end on stream.\r\n\t\t// In case of \"normal order\" the start position is at the begging of the stream.\r\n\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tconst start = (this.backward) ? (this._start - this._length) : this._start;\r\n\t\t\r\n\t\treturn this._stream.findAllNotIn(patterns, start, this._length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Find position of a sequence of any patterns from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\r\n\t * @param {?number} [length] Length to search sequence for\r\n\t * @param {?number} [gap] Maximum gap between start position and position of nearest object\r\n\t * @returns {*}\r\n\t */\r\n\tfindFirstSequence(patterns, length = null, gap = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((length == null) || (length > this._length))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this._length;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((gap == null) || (gap > length))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tgap = length;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Search for sequence\r\n\t\tconst result = this._stream.findFirstSequence(patterns, this._start, length, this.backward);\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(result.value.buffer.byteLength == 0)\r\n\t\t\treturn result;\r\n\t\t\r\n\t\tif(this.backward)\r\n\t\t{\r\n\t\t\tif(result.position < (this._start - result.value._buffer.byteLength - gap))\r\n\t\t\t{\r\n\t\t\t\treturn {\r\n\t\t\t\t\tposition: (-1),\r\n\t\t\t\t\tvalue: new ByteStream()\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(result.position > (this._start + result.value._buffer.byteLength + gap))\r\n\t\t\t{\r\n\t\t\t\treturn {\r\n\t\t\t\t\tposition: (-1),\r\n\t\t\t\t\tvalue: new ByteStream()\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Create new values\r\n\t\tthis.start = result.position;\r\n\t\t//endregion ;\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find position of a sequence of any patterns from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be found\r\n\t * @returns {Array}\r\n\t */\r\n\tfindAllSequences(patterns)\r\n\t{\r\n\t\t// In case of \"backward order\" the start position is at the end on stream.\r\n\t\t// In case of \"normal order\" the start position is at the begging of the stream.\r\n\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tconst start = (this.backward) ? (this.start - this.length) : this.start;\r\n\t\t\r\n\t\treturn this.stream.findAllSequences(patterns, start, this.length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Find all paired patterns in the stream\r\n\t * @param {ByteStream} leftPattern Left pattern to search for\r\n\t * @param {ByteStream} rightPattern Right pattern to search for\r\n\t * @param {?number} [gap] Maximum gap between start position and position of nearest object\r\n\t * @returns {Array}\r\n\t */\r\n\tfindPairedPatterns(leftPattern, rightPattern, gap = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((gap == null) || (gap > this.length))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tgap = this.length;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t// In case of \"backward order\" the start position is at the end on stream.\r\n\t\t// In case of \"normal order\" the start position is at the begging of the stream.\r\n\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tconst start = (this.backward) ? (this.start - this.length) : this.start;\r\n\t\t\r\n\t\t//region Search for patterns\r\n\t\tconst result = this.stream.findPairedPatterns(leftPattern, rightPattern, start, this.length);\r\n\t\tif(result.length)\r\n\t\t{\r\n\t\t\tif(this.backward)\r\n\t\t\t{\r\n\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\tif(result[0].right < (this.start - rightPattern.buffer.byteLength - gap))\r\n\t\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\tif(result[0].left > (this.start + leftPattern.buffer.byteLength + gap))\r\n\t\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Find all paired patterns in the stream\r\n\t * @param {Array.<ByteStream>} leftPatterns Array of left patterns to search for\r\n\t * @param {Array.<ByteStream>} rightPatterns Array of right patterns to search for\r\n\t * @param {?number} [gap] Maximum gap between start position and position of nearest object\r\n\t * @returns {Array}\r\n\t */\r\n\tfindPairedArrays(leftPatterns, rightPatterns, gap = null)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((gap == null) || (gap > this.length))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tgap = this.length;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t// In case of \"backward order\" the start position is at the end on stream.\r\n\t\t// In case of \"normal order\" the start position is at the begging of the stream.\r\n\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tconst start = (this.backward) ? (this.start - this.length) : this.start;\r\n\t\t\r\n\t\t//region Search for patterns\r\n\t\tconst result = this.stream.findPairedArrays(leftPatterns, rightPatterns, start, this.length);\r\n\t\tif(result.length)\r\n\t\t{\r\n\t\t\tif(this.backward)\r\n\t\t\t{\r\n\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\tif(result[0].right.position < (this.start - rightPatterns[result[0].right.id].buffer.byteLength - gap))\r\n\t\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\tif(result[0].left.position > (this.start + leftPatterns[result[0].left.id].buffer.byteLength + gap))\r\n\t\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Replace one patter with other\r\n\t * @param {ByteStream} searchPattern The pattern to search for\r\n\t * @param {ByteStream} replacePattern The pattern to replace initial pattern\r\n\t * @returns {*}\r\n\t */\r\n\treplacePattern(searchPattern, replacePattern)\r\n\t{\r\n\t\t// In case of \"backward order\" the start position is at the end on stream.\r\n\t\t// In case of \"normal order\" the start position is at the begging of the stream.\r\n\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tconst start = (this.backward) ? (this.start - this.length) : this.start;\r\n\t\t\r\n\t\treturn this.stream.replacePattern(searchPattern, replacePattern, start, this.length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Skip of any pattern from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\r\n\t * @returns {*}\r\n\t */\r\n\tskipPatterns(patterns)\r\n\t{\r\n\t\tconst result = this.stream.skipPatterns(patterns, this.start, this.length, this.backward);\r\n\t\t\r\n\t\t//region Create new values\r\n\t\tthis.start = result;\r\n\t\t//endregion ;\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Skip of any pattern from input array\r\n\t * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\r\n\t * @returns {number}\r\n\t */\r\n\tskipNotPatterns(patterns)\r\n\t{\r\n\t\tconst result = this.stream.skipNotPatterns(patterns, this.start, this.length, this.backward);\r\n\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\tif(result == (-1))\r\n\t\t\treturn (-1);\r\n\t\t\r\n\t\t//region Create new values\r\n\t\tthis.start = result;\r\n\t\t//endregion ;\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Append a new \"Stream\" content to the current \"Stream\"\r\n\t * @param {ByteStream} stream A new \"stream\" to append to current \"stream\"\r\n\t */\r\n\tappend(stream)\r\n\t{\r\n\t\tif((this._start + stream._buffer.byteLength) > this._stream._buffer.byteLength)\r\n\t\t{\r\n\t\t\tif(stream._buffer.byteLength > this.appendBlock)\r\n\t\t\t{\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tthis.appendBlock = (stream._buffer.byteLength + 1000);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\r\n\t\t}\r\n\t\t\r\n\t\tthis._stream._view.set(stream._view, this._start);\r\n\t\t\r\n\t\tthis._length += (stream._buffer.byteLength * 2);\r\n\t\tthis.start = (this._start + stream._buffer.byteLength);\r\n\t\tthis.prevLength -= (stream._buffer.byteLength * 2);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Append a \"view\" content to the current \"Stream\"\r\n\t * @param {Uint8Array} view A new \"view\" to append to current \"stream\"\r\n\t */\r\n\tappendView(view)\r\n\t{\r\n\t\tif((this._start + view.length) > this._stream._buffer.byteLength)\r\n\t\t{\r\n\t\t\tif(view.length > this.appendBlock)\r\n\t\t\t{\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tthis.appendBlock = (view.length + 1000);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\r\n\t\t}\r\n\t\t\r\n\t\tthis._stream._view.set(view, this._start);\r\n\t\t\r\n\t\tthis._length += (view.length * 2);\r\n\t\tthis.start = (this._start + view.length);\r\n\t\tthis.prevLength -= (view.length * 2);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Append a new char to the current \"Stream\"\r\n\t * @param {number} char A new char to append to current \"stream\"\r\n\t */\r\n\tappendChar(char)\r\n\t{\r\n\t\tif((this._start + 1) > this._stream._buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnLefSideOfComparisonJS\r\n\t\t\tif(1 > this.appendBlock)\r\n\t\t\t{\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tthis.appendBlock = 1000;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\r\n\t\t}\r\n\t\t\r\n\t\tthis._stream._view[this._start] = char;\r\n\t\t\r\n\t\tthis._length += 2;\r\n\t\tthis.start = (this._start + 1);\r\n\t\tthis.prevLength -= 2;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionNamingConventionJS\r\n\t/**\r\n\t * Append a new number to the current \"Stream\"\r\n\t * @param {number} number A new unsigned 16-bit integer to append to current \"stream\"\r\n\t */\r\n\tappendUint16(number)\r\n\t{\r\n\t\tif((this._start + 2) > this._stream._buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnLefSideOfComparisonJS\r\n\t\t\tif(2 > this.appendBlock)\r\n\t\t\t{\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tthis.appendBlock = 1000;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\r\n\t\t}\r\n\t\t\r\n\t\tconst value = new Uint16Array([number]);\r\n\t\tconst view = new Uint8Array(value.buffer);\r\n\t\t\r\n\t\tthis._stream._view[this._start] = view[1];\r\n\t\tthis._stream._view[this._start + 1] = view[0];\r\n\t\t\r\n\t\tthis._length += 4;\r\n\t\tthis.start = (this._start + 2);\r\n\t\tthis.prevLength -= 4;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionNamingConventionJS\r\n\t/**\r\n\t * Append a new number to the current \"Stream\"\r\n\t * @param {number} number A new unsigned 24-bit integer to append to current \"stream\"\r\n\t */\r\n\tappendUint24(number)\r\n\t{\r\n\t\tif((this._start + 3) > this._stream._buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnLefSideOfComparisonJS\r\n\t\t\tif(3 > this.appendBlock)\r\n\t\t\t{\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tthis.appendBlock = 1000;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\r\n\t\t}\r\n\t\t\r\n\t\tconst value = new Uint32Array([number]);\r\n\t\tconst view = new Uint8Array(value.buffer);\r\n\t\t\r\n\t\tthis._stream._view[this._start] = view[2];\r\n\t\tthis._stream._view[this._start + 1] = view[1];\r\n\t\tthis._stream._view[this._start + 2] = view[0];\r\n\t\t\r\n\t\tthis._length += 6;\r\n\t\tthis.start = (this._start + 3);\r\n\t\tthis.prevLength -= 6;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionNamingConventionJS\r\n\t/**\r\n\t * Append a new number to the current \"Stream\"\r\n\t * @param {number} number A new unsigned 32-bit integer to append to current \"stream\"\r\n\t */\r\n\tappendUint32(number)\r\n\t{\r\n\t\tif((this._start + 4) > this._stream._buffer.byteLength)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnLefSideOfComparisonJS\r\n\t\t\tif(4 > this.appendBlock)\r\n\t\t\t{\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tthis.appendBlock = 1000;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\r\n\t\t}\r\n\t\t\r\n\t\tconst value = new Uint32Array([number]);\r\n\t\tconst view = new Uint8Array(value.buffer);\r\n\t\t\r\n\t\tthis._stream._view[this._start] = view[3];\r\n\t\tthis._stream._view[this._start + 1] = view[2];\r\n\t\tthis._stream._view[this._start + 2] = view[1];\r\n\t\tthis._stream._view[this._start + 3] = view[0];\r\n\t\t\r\n\t\tthis._length += 8;\r\n\t\tthis.start = (this._start + 4);\r\n\t\tthis.prevLength -= 8;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Get a block of data\r\n\t * @param {number} size Size of the data block to get\r\n\t * @param {boolean} [changeLength=true] Should we change \"length\" and \"start\" value after reading the data block\r\n\t * @returns {Array}\r\n\t */\r\n\tgetBlock(size, changeLength = true)\r\n\t{\r\n\t\t//region Check input parameters\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif(this._length <= 0)\r\n\t\t\treturn [];\r\n\t\t\r\n\t\tif(this._length < size)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tsize = this._length;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Initial variables\r\n\t\tlet result;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Getting result depends on \"backward\" flag\r\n\t\tif(this.backward)\r\n\t\t{\r\n\t\t\tconst buffer = this._stream._buffer.slice(this._length - size, this._length);\r\n\t\t\tconst view = new Uint8Array(buffer);\r\n\t\t\t\r\n\t\t\tresult = new Array(size);\r\n\t\t\t\r\n\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\tfor(let i = 0; i < size; i++)\r\n\t\t\t\tresult[size - 1 - i] = view[i];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tconst buffer = this._stream._buffer.slice(this._start, this._start + size);\r\n\t\t\t\r\n\t\t\t// noinspection NestedFunctionCallJS\r\n\t\t\tresult = Array.from(new Uint8Array(buffer));\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Change \"length\" value if needed\r\n\t\tif(changeLength)\r\n\t\t{\r\n\t\t\t// noinspection ConditionalExpressionJS\r\n\t\t\tthis.start += ((this.backward) ? ((-1) * size) : size);\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS\r\n\t/**\r\n\t * Get 2-byte unsigned integer value\r\n\t * @param {boolean} [changeLength=true] Should we change \"length\" and \"start\" value after reading the data block\r\n\t * @returns {number}\r\n\t */\r\n\tgetUint16(changeLength = true)\r\n\t{\r\n\t\tconst block = this.getBlock(2, changeLength);\r\n\t\t\r\n\t\t//region Check posibility for convertion\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif(block.length < 2)\r\n\t\t\treturn 0;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Convert byte array to \"Uint16Array\" value\r\n\t\tconst value = new Uint16Array(1);\r\n\t\tconst view = new Uint8Array(value.buffer);\r\n\t\t\r\n\t\tview[0] = block[1];\r\n\t\tview[1] = block[0];\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn value[0];\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS\r\n\t/**\r\n\t * Get 2-byte signed integer value\r\n\t * @param {boolean} [changeLength=true] Should we change \"length\" and \"start\" value after reading the data block\r\n\t * @returns {number}\r\n\t */\r\n\tgetInt16(changeLength = true)\r\n\t{\r\n\t\tconst block = this.getBlock(2, changeLength);\r\n\r\n\t\t//region Check posibility for convertion\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif(block.length < 2)\r\n\t\t\treturn 0;\r\n\t\t//endregion\r\n\r\n\t\t//region Convert byte array to \"Int16Array\" value\r\n\t\tconst value = new Int16Array(1);\r\n\t\tconst view = new Uint8Array(value.buffer);\r\n\r\n\t\tview[0] = block[1];\r\n\t\tview[1] = block[0];\r\n\t\t//endregion\r\n\r\n\t\treturn value[0];\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS\r\n\t/**\r\n\t * Get 3-byte unsigned integer value\r\n\t * @param {boolean} [changeLength=true] Should we change \"length\" and \"start\" value after reading the data block\r\n\t * @returns {number}\r\n\t */\r\n\tgetUint24(changeLength = true)\r\n\t{\r\n\t\tconst block = this.getBlock(3, changeLength);\r\n\t\t\r\n\t\t//region Check posibility for convertion\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif(block.length < 3)\r\n\t\t\treturn 0;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Convert byte array to \"Uint32Array\" value\r\n\t\tconst value = new Uint32Array(1);\r\n\t\tconst view = new Uint8Array(value.buffer);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tfor(let i = 3; i >= 1; i--)\r\n\t\t\tview[3 - i] = block[i - 1];\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn value[0];\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS\r\n\t/**\r\n\t * Get 4-byte unsigned integer value\r\n\t * @param {boolean} [changeLength=true] Should we change \"length\" and \"start\" value after reading the data block\r\n\t * @returns {number}\r\n\t */\r\n\tgetUint32(changeLength = true)\r\n\t{\r\n\t\tconst block = this.getBlock(4, changeLength);\r\n\t\t\r\n\t\t//region Check posibility for convertion\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif(block.length < 4)\r\n\t\t\treturn 0;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Convert byte array to \"Uint32Array\" value\r\n\t\tconst value = new Uint32Array(1);\r\n\t\tconst view = new Uint8Array(value.buffer);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tfor(let i = 3; i >= 0; i--)\r\n\t\t\tview[3 - i] = block[i];\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn value[0];\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Get 4-byte signed integer value\r\n\t * @param {boolean} [changeLength=true] Should we change \"length\" and \"start\" value after reading the data block\r\n\t * @returns {number}\r\n\t */\r\n\tgetInt32(changeLength = true)\r\n\t{\r\n\t\tconst block = this.getBlock(4, changeLength);\r\n\r\n\t\t//region Check posibility for convertion\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif(block.length < 4)\r\n\t\t\treturn 0;\r\n\t\t//endregion\r\n\r\n\t\t//region Convert byte array to \"Int32Array\" value\r\n\t\tconst value = new Int32Array(1);\r\n\t\tconst view = new Uint8Array(value.buffer);\r\n\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tfor(let i = 3; i >= 0; i--)\r\n\t\t\tview[3 - i] = block[i];\r\n\t\t//endregion\r\n\r\n\t\treturn value[0];\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS\r\n/**\r\n * Get parsed values from \"byte map\"\r\n * @param {ByteStream} stream Stream to parse data from\r\n * @param {Object} map Object with information how to parse \"byte map\"\r\n * @param {number} elements Number of elements in parsing byte map\r\n * @param {?number} [start=null] Start position to parse from\r\n * @param {?number} [length=null] Length of byte block to parse from\r\n * @returns {*}\r\n */\r\nexport function parseByteMap(stream, map, elements, start = null, length = null)\r\n{\r\n\t/*\r\n\t Map example:\r\n\t \r\n\t let map = [\r\n\t {\r\n\t type: \"string\",\r\n\t name: \"type\",\r\n\t minlength: 1,\r\n\t maxlength: 1,\r\n\t func: function(array)\r\n\t {\r\n\t let result = {\r\n\t status: (-1),\r\n\t length: 1\r\n\t };\r\n\t \r\n\t switch(array[0])\r\n\t {\r\n\t case 0x6E: // \"n\"\r\n\t result.value = \"n\";\r\n\t break;\r\n\t case 0x66: // \"f\"\r\n\t result.value = \"f\";\r\n\t break;\r\n\t default:\r\n\t return result;\r\n\t }\r\n\t \r\n\t result.status = 1;\r\n\t \r\n\t return result;\r\n\t }\r\n\t },\r\n\t {\r\n\t type: \"check\",\r\n\t minlength: 1,\r\n\t maxlength: 2,\r\n\t func: function(array)\r\n\t {\r\n\t let position = (-1);\r\n\t \r\n\t if(array[0] == 0x0A)\r\n\t position = 1;\r\n\t if(array[1] == 0x0A)\r\n\t position = 2;\r\n\t \r\n\t return {\r\n\t status: (position > 0) ? 1 : (-1),\r\n\t length: position\r\n\t };\r\n\t }\r\n\t }\r\n\t ];\r\n\t */\r\n\t\r\n\t//region Initial variables\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\tif(start === null)\r\n\t{\r\n\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\tstart = 0;\r\n\t}\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tif(start > (stream.buffer.byteLength - 1))\r\n\t\treturn false;\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\tif(length === null)\r\n\t{\r\n\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\tlength = stream.buffer.byteLength - start;\r\n\t}\r\n\t\r\n\tif(length > (stream.buffer.byteLength - start))\r\n\t{\r\n\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\tlength = stream.buffer.byteLength - start;\r\n\t}\r\n\t\r\n\tlet dataView;\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\tif((start == 0) && (length == stream.buffer.byteLength))\r\n\t\tdataView = stream.view;\r\n\telse\r\n\t\tdataView = new Uint8Array(stream.buffer, start, length);\r\n\t\r\n\tconst resultArray = new Array(elements);\r\n\tlet elementsCount = 0;\r\n\t\r\n\tlet count = 0;\r\n\tconst mapLength = map.length;\r\n\t//endregion\r\n\t\r\n\t//region Parse all byte, structure by structure\r\n\twhile(count < length)\r\n\t{\r\n\t\tlet structureLength = 0;\r\n\t\t\r\n\t\tresultArray[elementsCount] = {};\r\n\t\t\r\n\t\tfor(let i = 0; i < mapLength; i++)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, JSUnresolvedVariable, EqualityComparisonWithCoercionJS\r\n\t\t\tif(map[i].maxlength == 0)\r\n\t\t\t{\r\n\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\tif(\"defaultValue\" in map[i])\r\n\t\t\t\t\t(resultArray[elementsCount])[map[i].name] = map[i].defaultValue;\r\n\t\t\t\t\r\n\t\t\t\t// noinspection ContinueStatementJS\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// noinspection JSUnresolvedVariable\r\n\t\t\tconst array = new Array(map[i].maxlength);\r\n\t\t\t\r\n\t\t\t// noinspection JSUnresolvedVariable\r\n\t\t\tfor(let j = 0; j < map[i].maxlength; j++)\r\n\t\t\t{\r\n\t\t\t\t// noinspection IncrementDecrementResultUsedJS\r\n\t\t\t\tarray[j] = dataView[count++];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// noinspection JSUnresolvedVariable\r\n\t\t\tconst result = (map[i].func)(array);\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\t\tif(result.status == (-1))\r\n\t\t\t{\r\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\r\n\t\t\t\tif(resultArray.length == 1)\r\n\t\t\t\t\treturn [];\r\n\r\n\t\t\t\treturn resultArray.slice(0, resultArray.length - 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\t\tif(map[i].type != \"check\")\r\n\t\t\t\t(resultArray[elementsCount])[map[i].name] = result.value;\r\n\t\t\t\r\n\t\t\t// noinspection JSUnresolvedVariable\r\n\t\t\tcount -= (map[i].maxlength - result.length);\r\n\t\t\tstructureLength += result.length;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection IncrementDecrementResultUsedJS\r\n\t\t(resultArray[elementsCount++]).structureLength = structureLength;\r\n\t}\r\n\t//endregion\r\n\t\r\n\treturn resultArray;\r\n}\r\n//**************************************************************************************\r\n//region \"Bits-to-string\" array\r\nconst bitsToStringArray = [\r\n\t\"00000000\", \"00000001\", \"00000010\",\r\n\t\"00000011\", \"00000100\", \"00000101\",\r\n\t\"00000110\", \"00000111\", \"00001000\",\r\n\t\"00001001\", \"00001010\", \"00001011\",\r\n\t\"00001100\", \"00001101\", \"00001110\",\r\n\t\"00001111\", \"00010000\", \"00010001\",\r\n\t\"00010010\", \"00010011\", \"00010100\",\r\n\t\"00010101\", \"00010110\", \"00010111\",\r\n\t\"00011000\", \"00011001\", \"00011010\",\r\n\t\"00011011\", \"00011100\", \"00011101\",\r\n\t\"00011110\", \"00011111\", \"00100000\",\r\n\t\"00100001\", \"00100010\", \"00100011\",\r\n\t\"00100100\", \"00100101\", \"00100110\",\r\n\t\"00100111\", \"00101000\", \"00101001\",\r\n\t\"00101010\", \"00101011\", \"00101100\",\r\n\t\"00101101\", \"00101110\", \"00101111\",\r\n\t\"00110000\", \"00110001\", \"00110010\",\r\n\t\"00110011\", \"00110100\", \"00110101\",\r\n\t\"00110110\", \"00110111\", \"00111000\",\r\n\t\"00111001\", \"00111010\", \"00111011\",\r\n\t\"00111100\", \"00111101\", \"00111110\",\r\n\t\"00111111\", \"01000000\", \"01000001\",\r\n\t\"01000010\", \"01000011\", \"01000100\",\r\n\t\"01000101\", \"01000110\", \"01000111\",\r\n\t\"01001000\", \"01001001\", \"01001010\",\r\n\t\"01001011\", \"01001100\", \"01001101\",\r\n\t\"01001110\", \"01001111\", \"01010000\",\r\n\t\"01010001\", \"01010010\", \"01010011\",\r\n\t\"01010100\", \"01010101\", \"01010110\",\r\n\t\"01010111\", \"01011000\", \"01011001\",\r\n\t\"01011010\", \"01011011\", \"01011100\",\r\n\t\"01011101\", \"01011110\", \"01011111\",\r\n\t\"01100000\", \"01100001\", \"01100010\",\r\n\t\"01100011\", \"01100100\", \"01100101\",\r\n\t\"01100110\", \"01100111\", \"01101000\",\r\n\t\"01101001\", \"01101010\", \"01101011\",\r\n\t\"01101100\", \"01101101\", \"01101110\",\r\n\t\"01101111\", \"01110000\", \"01110001\",\r\n\t\"01110010\", \"01110011\", \"01110100\",\r\n\t\"01110101\", \"01110110\", \"01110111\",\r\n\t\"01111000\", \"01111001\", \"01111010\",\r\n\t\"01111011\", \"01111100\", \"01111101\",\r\n\t\"01111110\", \"01111111\", \"10000000\",\r\n\t\"10000001\", \"10000010\", \"10000011\",\r\n\t\"10000100\", \"10000101\", \"10000110\",\r\n\t\"10000111\", \"10001000\", \"10001001\",\r\n\t\"10001010\", \"10001011\", \"10001100\",\r\n\t\"10001101\", \"10001110\", \"10001111\",\r\n\t\"10010000\", \"10010001\", \"10010010\",\r\n\t\"10010011\", \"10010100\", \"10010101\",\r\n\t\"10010110\", \"10010111\", \"10011000\",\r\n\t\"10011001\", \"10011010\", \"10011011\",\r\n\t\"10011100\", \"10011101\", \"10011110\",\r\n\t\"10011111\", \"10100000\", \"10100001\",\r\n\t\"10100010\", \"10100011\", \"10100100\",\r\n\t\"10100101\", \"10100110\", \"10100111\",\r\n\t\"10101000\", \"10101001\", \"10101010\",\r\n\t\"10101011\", \"10101100\", \"10101101\",\r\n\t\"10101110\", \"10101111\", \"10110000\",\r\n\t\"10110001\", \"10110010\", \"10110011\",\r\n\t\"10110100\", \"10110101\", \"10110110\",\r\n\t\"10110111\", \"10111000\", \"10111001\",\r\n\t\"10111010\", \"10111011\", \"10111100\",\r\n\t\"10111101\", \"10111110\", \"10111111\",\r\n\t\"11000000\", \"11000001\", \"11000010\",\r\n\t\"11000011\", \"11000100\", \"11000101\",\r\n\t\"11000110\", \"11000111\", \"11001000\",\r\n\t\"11001001\", \"11001010\", \"11001011\",\r\n\t\"11001100\", \"11001101\", \"11001110\",\r\n\t\"11001111\", \"11010000\", \"11010001\",\r\n\t\"11010010\", \"11010011\", \"11010100\",\r\n\t\"11010101\", \"11010110\", \"11010111\",\r\n\t\"11011000\", \"11011001\", \"11011010\",\r\n\t\"11011011\", \"11011100\", \"11011101\",\r\n\t\"11011110\", \"11011111\", \"11100000\",\r\n\t\"11100001\", \"11100010\", \"11100011\",\r\n\t\"11100100\", \"11100101\", \"11100110\",\r\n\t\"11100111\", \"11101000\", \"11101001\",\r\n\t\"11101010\", \"11101011\", \"11101100\",\r\n\t\"11101101\", \"11101110\", \"11101111\",\r\n\t\"11110000\", \"11110001\", \"11110010\",\r\n\t\"11110011\", \"11110100\", \"11110101\",\r\n\t\"11110110\", \"11110111\", \"11111000\",\r\n\t\"11111001\", \"11111010\", \"11111011\",\r\n\t\"11111100\", \"11111101\", \"11111110\",\r\n\t\"11111111\"\r\n];\r\n//endregion\r\n//**************************************************************************************\r\nexport class BitStream\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for \"BitStream\" class\r\n\t * @param {{[byteStream]: ByteStream, [view]: Uint8Array, [buffer]: ArrayBuffer, [string]: string, [bitsCount]: number}} parameters\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\tthis.buffer = new ArrayBuffer(0);\r\n\t\tthis.view = new Uint8Array(this.buffer);\r\n\t\t\r\n\t\tthis.bitsCount = 0; // Number of bits stored in current \"BitStream\"\r\n\t\t\r\n\t\tfor(const key of Object.keys(parameters))\r\n\t\t{\r\n\t\t\tswitch(key)\r\n\t\t\t{\r\n\t\t\t\tcase \"byteStream\":\r\n\t\t\t\t\tthis.fromByteStream(parameters.byteStream);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"view\":\r\n\t\t\t\t\tthis.fromUint8Array(parameters.view);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"buffer\":\r\n\t\t\t\t\tthis.fromArrayBuffer(parameters.buffer);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tthis.fromString(parameters.string);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"uint32\":\r\n\t\t\t\t\tthis.fromUint32(parameters.uint32);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"bitsCount\":\r\n\t\t\t\t\tthis.bitsCount = parameters.bitsCount;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Clear existing stream\r\n\t */\r\n\tclear()\r\n\t{\r\n\t\tthis.buffer = new ArrayBuffer(0);\r\n\t\tthis.view = new Uint8Array(this.buffer);\r\n\t\t\r\n\t\tthis.bitsCount = 0;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Initialize \"BitStream\" by data from existing \"ByteStream\"\r\n\t * @param {ByteStream} stream\r\n\t */\r\n\tfromByteStream(stream)\r\n\t{\r\n\t\tthis.buffer = stream.buffer.slice(0);\r\n\t\tthis.view = new Uint8Array(this.buffer);\r\n\t\t\r\n\t\tthis.bitsCount = this.view.length << 3;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Initialize \"BitStream\" object from existing \"ArrayBuffer\"\r\n\t * @param {ArrayBuffer} array The ArrayBuffer to copy from\r\n\t */\r\n\tfromArrayBuffer(array)\r\n\t{\r\n\t\tthis.buffer = array.slice(0);\r\n\t\tthis.view = new Uint8Array(this.buffer);\r\n\t\t\r\n\t\tthis.bitsCount = this.view.length << 3;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionNamingConventionJS\r\n\t/**\r\n\t * Initialize \"BitStream\" object from existing \"Uint8Array\"\r\n\t * @param {Uint8Array} array The Uint8Array to copy from\r\n\t */\r\n\tfromUint8Array(array)\r\n\t{\r\n\t\tthis.buffer = new ArrayBuffer(array.length);\r\n\t\tthis.view = new Uint8Array(this.buffer);\r\n\t\t\r\n\t\tthis.view.set(array);\r\n\t\t\r\n\t\tthis.bitsCount = this.view.length << 3;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Initialize \"BitStream\" object from existing bit string\r\n\t * @param {string} string The string to initialize from\r\n\t */\r\n\tfromString(string)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst stringLength = string.length;\r\n\t\t\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tthis.buffer = new ArrayBuffer((stringLength >> 3) + ((stringLength % 8) ? 1 : 0));\r\n\t\tthis.view = new Uint8Array(this.buffer);\r\n\t\t\r\n\t\tthis.bitsCount = ((stringLength >> 3) + 1) << 3; // In order to handle correct shifting\r\n\t\t\r\n\t\tlet byteIndex = 0;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Convert from \"bit string\" to bytes\r\n\t\tfor(let i = 0; i < stringLength; i++)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\t\tif(string[i] == \"1\")\r\n\t\t\t\tthis.view[byteIndex] |= 1 << (7 - (i % 8));\r\n\t\t\t\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\t\tif(i && (((i + 1) % 8) == 0))\r\n\t\t\t\tbyteIndex++;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Shift \"BitStream\" into correct position\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(stringLength % 8)\r\n\t\t\tthis.shiftRight(8 - (stringLength % 8));\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Change \"bitsCount\"\r\n\t\tthis.bitsCount = stringLength;\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Initialize \"BitStream\" object from existing uint32 number\r\n\t * @param {Number} number The string to initialize from\r\n\t */\r\n\tfromUint32(uint32)\r\n\t{\r\n\t\tthis.buffer = new ArrayBuffer(4);\r\n\t\tthis.view = new Uint8Array(this.buffer);\r\n\r\n\t\tconst value = new Uint32Array([uint32]);\r\n\t\tconst view = new Uint8Array(value.buffer);\r\n\t\t\r\n\t\tfor(let i = 3; i >= 0; i--)\r\n\t\t\tthis.view[i] = view[3 - i];\r\n\r\n\t\tthis.bitsCount = 32;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Represent \"BitStream\" object content as a string\r\n\t * @param {?number} [start=null] Start number to convert to string from\r\n\t * @param {?number} [length=null] Length of BitStream to convert to string\r\n\t * @returns {string}\r\n\t */\r\n\ttoString(start = null, length = null)\r\n\t{\r\n\t\t//region Check input parameters\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((start >= this.view.length) || (start < 0))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(length == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.view.length - start;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif((length >= this.view.length) || (length < 0))\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = this.view.length - start;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Initial variables\r\n\t\tconst result = [];\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Convert from bytes to \"bit string\"\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tfor(let i = start; i < (start + length); i++)\r\n\t\t\tresult.push(bitsToStringArray[this.view[i]]);\r\n\t\t//endregion\r\n\t\t\r\n\t\t// noinspection ChainedFunctionCallJS\r\n\t\treturn result.join(\"\").slice((this.view.length << 3) - this.bitsCount);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Shift entire \"BitStream\" value right to number of bits\r\n\t * @param {number} shift Number of bits to shift value\r\n\t * @param {boolean} [needShrink=true] Need to shrink result or not\r\n\t */\r\n\tshiftRight(shift, needShrink = true)\r\n\t{\r\n\t\t//region Check parameters\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\tif(this.view.length == 0)\r\n\t\t\treturn;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif((shift < 0) || (shift > 8))\r\n\t\t\tthrow new Error(\"The \\\"shift\\\" parameter must be in range 0-8\");\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(shift > this.bitsCount)\r\n\t\t\tthrow new Error(\"The \\\"shift\\\" parameter can not be bigger than \\\"this.bitsCount\\\"\");\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Initial variables\r\n\t\t// noinspection MagicNumberJS\r\n\t\tconst shiftMask = 0xFF >> (8 - shift);\r\n\t\tthis.view[this.view.length - 1] >>= shift;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Shift value\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tfor(let i = (this.view.length - 2); i >= 0; i--)\r\n\t\t{\r\n\t\t\t// noinspection NonShortCircuitBooleanExpressionJS\r\n\t\t\tthis.view[i + 1] |= (this.view[i] & shiftMask) << (8 - shift);\r\n\t\t\tthis.view[i] >>= shift;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Decrease number of bits stored into value\r\n\t\tthis.bitsCount -= shift;\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\tif(this.bitsCount == 0)\r\n\t\t\tthis.clear();\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Change stream size if needed\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(needShrink)\r\n\t\t\tthis.shrink();\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Shift entire \"BitStream\" value left to number of bits\r\n\t * @param {number} shift Number of bits to shift value\r\n\t */\r\n\tshiftLeft(shift)\r\n\t{\r\n\t\t/*\r\n\t\t NOTE: We do not really shift value because of internal structure of \"BitStream\":\r\n\t\t all bytes inside \"BitStream\" are aligned to right position. So, even if we will\r\n\t\t really shift value to left after that we will need again shift it right to the\r\n\t\t same number of bits. Thus all that we do here is hiding of left bits and descresing\r\n\t\t the \"bitsCount\" number.\r\n\t\t */\r\n\t\t\r\n\t\t//region Check parameters\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\tif(this.view.length == 0)\r\n\t\t\treturn;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif((shift < 0) || (shift > 8))\r\n\t\t\tthrow new Error(\"The \\\"shift\\\" parameter must be in range 0-8\");\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(shift > this.bitsCount)\r\n\t\t\tthrow new Error(\"The \\\"shift\\\" parameter can not be bigger than \\\"this.bitsCount\\\"\");\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Remove shifted bits\r\n\t\t// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst bitsOffset = this.bitsCount & 0x07;\r\n\t\tif(bitsOffset > shift)\r\n\t\t{\r\n\t\t\t// noinspection MagicNumberJS\r\n\t\t\tthis.view[0] &= 0xFF >> (bitsOffset + shift);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//region Change size of buffer\r\n\t\t\tconst buffer = new ArrayBuffer(this.buffer.byteLength - 1);\r\n\t\t\tconst view = new Uint8Array(buffer);\r\n\t\t\t\r\n\t\t\t// noinspection NestedFunctionCallJS\r\n\t\t\tview.set(new Uint8Array(this.buffer, 1, this.buffer.byteLength - 1));\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\t//region Mask item with index 0\r\n\t\t\t// noinspection MagicNumberJS\r\n\t\t\tview[0] &= 0xFF >> (shift - bitsOffset);\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\t//region Store final array into current stream\r\n\t\t\tthis.buffer = buffer.slice(0);\r\n\t\t\tthis.view = new Uint8Array(this.buffer);\r\n\t\t\t//endregion\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Decrease number of bits stored into value\r\n\t\tthis.bitsCount -= shift;\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\tif(this.bitsCount == 0)\r\n\t\t\tthis.clear();\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS, FunctionTooLongJS\r\n\t/**\r\n\t * Return slice of existing \"BitStream\"\r\n\t * @param {?number} [start=null] Start position of the slice (in bits)\r\n\t * @param {?number} [end=null] End position of the slice (in bits)\r\n\t * @returns {BitStream}\r\n\t */\r\n\tslice(start = null, end = null)\r\n\t{\r\n\t\t//region Make ability to pass non-value bits\r\n\t\tlet valueShift = 0;\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(this.bitsCount % 8)\r\n\t\t\tvalueShift = (8 - (this.bitsCount % 8));\r\n\t\t\r\n\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\tstart += valueShift;\r\n\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\tend += valueShift;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Initial variables\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(start == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif((start < 0) || (start > ((this.view.length << 3) - 1)))\r\n\t\t\treturn new BitStream(); //(\"Wrong start position: \" + start);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(end == null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tend = (this.view.length << 3) - 1;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif((end < 0) || (end > ((this.view.length << 3) - 1)))\r\n\t\t\treturn new BitStream(); //(\"Wrong end position: \" + end);\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif((end - start + 1) > this.bitsCount)\r\n\t\t\treturn new BitStream(); //(\"Maximum length is \" + this.bitsCount);\r\n\t\t\r\n\t\tconst startIndex = start >> 3;\r\n\t\t// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst startOffset = start & 0x07;\r\n\t\t\r\n\t\tconst endIndex = end >> 3;\r\n\t\t// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst endOffset = end & 0x07;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS\r\n\t\tconst bitsLength = ((endIndex - startIndex) == 0) ? 1 : (endIndex - startIndex + 1);\r\n\t\t\r\n\t\tconst result = new BitStream();\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Store \"primary bytes\"\r\n\t\tresult.buffer = new ArrayBuffer(bitsLength);\r\n\t\tresult.view = new Uint8Array(result.buffer);\r\n\t\tresult.bitsCount = bitsLength << 3;\r\n\t\t\r\n\t\t// noinspection NestedFunctionCallJS\r\n\t\tresult.view.set(new Uint8Array(this.buffer, startIndex, bitsLength));\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Change \"start byte\"\r\n\t\t// noinspection MagicNumberJS\r\n\t\tresult.view[0] &= (0xFF >> startOffset);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Change \"end byte\"\r\n\t\t// noinspection MagicNumberJS\r\n\t\tresult.view[bitsLength] &= (0xFF << (7 - endOffset));\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Shift result array to right\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(7 - endOffset)\r\n\t\t\tresult.shiftRight(7 - endOffset, false);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Set final number of bits\r\n\t\tresult.bitsCount = (end - start + 1);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Cut unnecessary bytes from result\r\n\t\tresult.shrink();\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Return copy of existing \"BitStream\"\r\n\t * @param {?number} [start=null] Start position of the copy (in bits)\r\n\t * @param {?number} [length=null] Length of the copy (in bits)\r\n\t * @returns {BitStream}\r\n\t */\r\n\tcopy(start = null, length = null)\r\n\t{\r\n\t\t//region Check input parameters\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif((start < 0) || (start > ((this.view.length << 3) - 1)))\r\n\t\t\treturn new BitStream(); //(\"Wrong start position: \" + start);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\r\n\t\tif(length === null)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = (this.view.length << 3) - start - 1;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(length > this.bitsCount)\r\n\t\t\treturn new BitStream(); //(\"Maximum length is \" + this.bitsCount);\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn this.slice(start, start + length - 1);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Shrink unnecessary bytes in current stream accordingly to \"bitsCount\" value\r\n\t */\r\n\tshrink()\r\n\t{\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tconst currentLength = (this.bitsCount >> 3) + ((this.bitsCount % 8) ? 1 : 0);\r\n\t\tif(currentLength < this.buffer.byteLength)\r\n\t\t{\r\n\t\t\t//region Change size of buffer\r\n\t\t\tconst buffer = new ArrayBuffer(currentLength);\r\n\t\t\tconst view = new Uint8Array(buffer);\r\n\t\t\t\r\n\t\t\t// noinspection NestedFunctionCallJS\r\n\t\t\tview.set(new Uint8Array(this.buffer, this.buffer.byteLength - currentLength, currentLength));\r\n\t\t\t//endregion\r\n\t\t\t\r\n\t\t\t//region Store final array into current stream\r\n\t\t\tthis.buffer = buffer.slice(0);\r\n\t\t\tthis.view = new Uint8Array(this.buffer);\r\n\t\t\t//endregion\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Reverse bits order in each byte in the stream\r\n\t * Got it from here: http://graphics.stanford.edu/~seander/bithacks.html#ReverseByteWith32Bits\r\n\t */\r\n\treverseBytes()\r\n\t{\r\n\t\t//region Reverse bits order in each byte in the stream\r\n\t\tfor(let i = 0; i < this.view.length; i++)\r\n\t\t{\r\n\t\t\t// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\t\tthis.view[i] = ((this.view[i] * 0x0802 & 0x22110) | (this.view[i] * 0x8020 & 0x88440)) * 0x10101 >> 16;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Shift \"most significant\" byte\r\n\t\tif(this.bitsCount % 8)\r\n\t\t{\r\n\t\t\t// noinspection ConditionalExpressionJS\r\n\t\t\tconst currentLength = (this.bitsCount >> 3) + ((this.bitsCount % 8) ? 1 : 0);\r\n\t\t\t// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\t\tthis.view[this.view.length - currentLength] >>= (8 - (this.bitsCount & 0x07));\r\n\t\t}\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Reverse all bits in entire \"BitStream\"\r\n\t */\r\n\treverseValue()\r\n\t{\r\n\t\tconst initialValue = this.toString();\r\n\t\tconst initialValueLength = initialValue.length;\r\n\t\t\r\n\t\tconst reversedValue = new Array(initialValueLength);\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tfor(let i = 0; i < initialValueLength; i++)\r\n\t\t\treversedValue[initialValueLength - 1 - i] = initialValue[i];\r\n\t\t\r\n\t\t// noinspection NestedFunctionCallJS\r\n\t\tthis.fromString(reversedValue.join(\"\"));\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Trying to represent entire \"BitStream\" as an unsigned integer.\r\n\t * @return {number}\r\n\t */\r\n\tgetNumberValue()\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst byteLength = (this.buffer.byteLength - 1);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Check posibility for convertion\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif(byteLength > 3)\r\n\t\t\treturn (-1);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\tif(byteLength == (-1))\r\n\t\t\treturn 0;\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Convert byte array to \"Uint32Array\" value\r\n\t\tconst value = new Uint32Array(1);\r\n\t\tconst view = new Uint8Array(value.buffer);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tfor(let i = byteLength; i >= 0; i--)\r\n\t\t\tview[byteLength - i] = this.view[i];\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn value[0];\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find any bit pattern in \"BitStream\"\r\n\t * @param {BitStream} pattern Stream having pattern value\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @param {boolean} [backward=false] Flag to search in backward order\r\n\t * @returns {number}\r\n\t */\r\n\tfindPattern(pattern, start = null, length = null, backward = false)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\tconst stringPattern = new ByteStream({\r\n\t\t\tstring: pattern.toString()\r\n\t\t});\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.findPattern(stringPattern, start, length, backward);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find first position of any pattern from input array\r\n\t * @param {Array.<BitStream>} patterns Array with patterns which should be found\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @param {boolean} [backward=false] Flag to search in backward order\r\n\t * @returns {{id: number, position: number}}\r\n\t */\r\n\tfindFirstIn(patterns, start = null, length = null, backward = false)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\t\r\n\t\tconst stringPatterns = new Array(patterns.length);\r\n\t\t\r\n\t\tfor(let i = 0; i < patterns.length; i++)\r\n\t\t{\r\n\t\t\tstringPatterns[i] = new ByteStream({\r\n\t\t\t\tstring: patterns[i].toString()\r\n\t\t\t});\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.findFirstIn(stringPatterns, start, length, backward);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find all positions of any pattern from input array\r\n\t * @param {Array.<BitStream>} patterns Array with patterns which should be found\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @returns {Array}\r\n\t */\r\n\tfindAllIn(patterns, start = null, length = null)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\t\r\n\t\tconst stringPatterns = new Array(patterns.length);\r\n\t\t\r\n\t\tfor(let i = 0; i < patterns.length; i++)\r\n\t\t{\r\n\t\t\tstringPatterns[i] = new ByteStream({\r\n\t\t\t\tstring: patterns[i].toString()\r\n\t\t\t});\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.findAllIn(stringPatterns, start, length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find all positions of a pattern\r\n\t * @param {BitStream} pattern Stream having pattern value\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @returns {Array|number}\r\n\t */\r\n\tfindAllPatternIn(pattern, start = null, length = null)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\" \r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\tconst stringPattern = new ByteStream({\r\n\t\t\tstring: pattern.toString()\r\n\t\t});\r\n\t\t//endregion \r\n\t\t\r\n\t\treturn stringStream.findAllPatternIn(stringPattern, start, length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find first position of data, not included in patterns from input array\r\n\t * @param {Array.<BitStream>} patterns Array with patterns which should be found\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @param {boolean} [backward=false] Flag to search in backward order\r\n\t * @returns {{left: {id: number, position: *}, right: {id: number, position: number}, value: ByteStream}}\r\n\t */\r\n\tfindFirstNotIn(patterns, start = null, length = null, backward = false)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\t\r\n\t\tconst stringPatterns = new Array(patterns.length);\r\n\t\t\r\n\t\tfor(let i = 0; i < patterns.length; i++)\r\n\t\t{\r\n\t\t\tstringPatterns[i] = new ByteStream({\r\n\t\t\t\tstring: patterns[i].toString()\r\n\t\t\t});\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.findFirstNotIn(stringPatterns, start, length, backward);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find all positions of data, not included in patterns from input array\r\n\t * @param {Array.<BitStream>} patterns Array with patterns which should be found\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @returns {Array}\r\n\t */\r\n\tfindAllNotIn(patterns, start = null, length = null)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\t\r\n\t\tconst stringPatterns = new Array(patterns.length);\r\n\t\t\r\n\t\tfor(let i = 0; i < patterns.length; i++)\r\n\t\t{\r\n\t\t\tstringPatterns[i] = new ByteStream({\r\n\t\t\t\tstring: patterns[i].toString()\r\n\t\t\t});\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.findAllNotIn(stringPatterns, start, length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find position of a sequence of any patterns from input array\r\n\t * @param {Array.<BitStream>} patterns Array with patterns which should be found\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @param {boolean} [backward=false] Flag to search in backward order\r\n\t * @returns {{position, value}|*}\r\n\t */\r\n\tfindFirstSequence(patterns, start = null, length = null, backward = false)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\t\r\n\t\tconst stringPatterns = new Array(patterns.length);\r\n\t\t\r\n\t\tfor(let i = 0; i < patterns.length; i++)\r\n\t\t{\r\n\t\t\tstringPatterns[i] = new ByteStream({\r\n\t\t\t\tstring: patterns[i].toString()\r\n\t\t\t});\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.findFirstSequence(stringPatterns, start, length, backward);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find position of a sequence of any patterns from input array\r\n\t * @param {Array.<BitStream>} patterns Array with patterns which should be found\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @returns {Array}\r\n\t */\r\n\tfindAllSequences(patterns, start, length)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\t\r\n\t\tconst stringPatterns = new Array(patterns.length);\r\n\t\t\r\n\t\tfor(let i = 0; i < patterns.length; i++)\r\n\t\t{\r\n\t\t\tstringPatterns[i] = new ByteStream({\r\n\t\t\t\tstring: patterns[i].toString()\r\n\t\t\t});\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.findAllSequences(stringPatterns, start, length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Find all paired patterns in the stream\r\n\t * @param {BitStream} leftPattern Left pattern to search for\r\n\t * @param {BitStream} rightPattern Right pattern to search for\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @returns {Array}\r\n\t */\r\n\tfindPairedPatterns(leftPattern, rightPattern, start = null, length = null)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\tconst stringLeftPattern = new ByteStream({\r\n\t\t\tstring: leftPattern.toString()\r\n\t\t});\r\n\t\tconst stringRightPattern = new ByteStream({\r\n\t\t\tstring: rightPattern.toString()\r\n\t\t});\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.findPairedPatterns(stringLeftPattern, stringRightPattern, start, length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleLoopsJS\r\n\t/**\r\n\t * Find all paired patterns in the stream\r\n\t * @param {Array.<BitStream>} inputLeftPatterns Array of left patterns to search for\r\n\t * @param {Array.<BitStream>} inputRightPatterns Array of right patterns to search for\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @returns {Array}\r\n\t */\r\n\tfindPairedArrays(inputLeftPatterns, inputRightPatterns, start = null, length = null)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\t\r\n\t\tconst stringLeftPatterns = new Array(inputLeftPatterns.length);\r\n\t\t\r\n\t\tfor(let i = 0; i < inputLeftPatterns.length; i++)\r\n\t\t{\r\n\t\t\tstringLeftPatterns[i] = new ByteStream({\r\n\t\t\t\tstring: inputLeftPatterns[i].toString()\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tconst stringRightPatterns = new Array(inputRightPatterns.length);\r\n\t\t\r\n\t\tfor(let i = 0; i < inputRightPatterns.length; i++)\r\n\t\t{\r\n\t\t\tstringRightPatterns[i] = new ByteStream({\r\n\t\t\t\tstring: inputRightPatterns[i].toString()\r\n\t\t\t});\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.findPairedArrays(stringLeftPatterns, stringRightPatterns, start, length);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Replace one pattern with other\r\n\t * @param {BitStream} searchPattern The pattern to search for\r\n\t * @param {BitStream} replacePattern The pattern to replace initial pattern\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @returns {boolean}\r\n\t */\r\n\treplacePattern(searchPattern, replacePattern, start = null, length = null)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\tconst stringSearchPattern = new ByteStream({\r\n\t\t\tstring: searchPattern.toString()\r\n\t\t});\r\n\t\tconst stringReplacePattern = new ByteStream({\r\n\t\t\tstring: replacePattern.toString()\r\n\t\t});\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Re-initialize existing data\r\n\t\tif(stringStream.findPairedPatterns(stringSearchPattern, stringReplacePattern, start, length))\r\n\t\t{\r\n\t\t\t// noinspection NestedFunctionCallJS\r\n\t\t\tthis.fromString(stringStream.toString());\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Skip any pattern from input array\r\n\t * @param {Array.<BitStream>} patterns Array with patterns which should be ommited\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @param {boolean} [backward=false] Flag to search in backward order\r\n\t * @returns {*}\r\n\t */\r\n\tskipPatterns(patterns, start, length, backward)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\t\r\n\t\tconst stringPatterns = new Array(patterns.length);\r\n\t\t\r\n\t\tfor(let i = 0; i < patterns.length; i++)\r\n\t\t{\r\n\t\t\tstringPatterns[i] = new ByteStream({\r\n\t\t\t\tstring: patterns[i].toString()\r\n\t\t\t});\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.skipPatterns(stringPatterns, start, length, backward);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Skip any pattern not from input array\r\n\t * @param {Array.<BitStream>} patterns Array with patterns which should be ommited\r\n\t * @param {?number} [start=null] Start position to search from\r\n\t * @param {?number} [length=null] Length of byte block to search at\r\n\t * @param {boolean} [backward=false] Flag to search in backward order\r\n\t * @returns {number}\r\n\t */\r\n\tskipNotPatterns(patterns, start, length, backward)\r\n\t{\r\n\t\t//region Convert \"BitStream\" values to \"ByteStream\"\r\n\t\tconst stringStream = new ByteStream({\r\n\t\t\tstring: this.toString()\r\n\t\t});\r\n\t\t\r\n\t\tconst stringPatterns = new Array(patterns.length);\r\n\t\t\r\n\t\tfor(let i = 0; i < patterns.length; i++)\r\n\t\t{\r\n\t\t\tstringPatterns[i] = new ByteStream({\r\n\t\t\t\tstring: patterns[i].toString()\r\n\t\t\t});\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn stringStream.skipNotPatterns(stringPatterns, start, length, backward);\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Append a new \"BitStream\" content to the current \"BitStream\"\r\n\t * @param {BitStream} stream A new \"stream\" to append to current \"stream\"\r\n\t */\r\n\tappend(stream)\r\n\t{\r\n\t\t//region Initialize current stream with new data\r\n\t\t// noinspection NestedFunctionCallJS\r\n\t\tthis.fromString([\r\n\t\t\tthis.toString(),\r\n\t\t\tstream.toString()\r\n\t\t].join(\"\"));\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\nexport class SeqBitStream\r\n{\r\n\t//**********************************************************************************\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\t//region Internal variables\r\n\t\tthis.stream = new BitStream();\r\n\t\t\r\n\t\tthis._start = 0;\r\n\t\tthis._length = this.stream.bitsCount;\r\n\t\t\r\n\t\tthis.backward = false;\r\n\t\t\r\n\t\tthis.appendBlock = 0;\r\n\t\t//endregion\r\n\t\t\r\n\t\tfor(const key of Object.keys(parameters))\r\n\t\t{\r\n\t\t\tswitch(key)\r\n\t\t\t{\r\n\t\t\t\tcase \"stream\":\r\n\t\t\t\tcase \"start\":\r\n\t\t\t\tcase \"length\":\r\n\t\t\t\tcase \"backward\":\r\n\t\t\t\tcase \"appendBlock\":\r\n\t\t\t\t\tthis[key] = parameters[key];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\tset start(value)\r\n\t{\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(value > this.stream.bitsCount)\r\n\t\t\treturn;\r\n\t\t\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tthis._length -= ((this.backward) ? (this._start - value) : (value - this._start));\r\n\t\tthis._start = value;\r\n\t\t\r\n\t\t//region Initialization of \"prev\" internal variables\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis.prevStart = this._start;\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis.prevLength = this._length;\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\tget start()\r\n\t{\r\n\t\treturn this._start;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionWithMultipleReturnPointsJS\r\n\tset length(value)\r\n\t{\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(value > this.stream.bitsCount)\r\n\t\t\treturn;\r\n\t\t\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis.prevLength = this._length;\r\n\t\tthis._length = value;\r\n\t}\r\n\t//**********************************************************************************\r\n\tget length()\r\n\t{\r\n\t\treturn this._length;\r\n\t}\r\n\t//**********************************************************************************\r\n\tset stream(value)\r\n\t{\r\n\t\tthis._stream = value;\r\n\t\t\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis.prevLength = this._length;\r\n\t\tthis._length = value.bitsCount;\r\n\t\t\r\n\t\t// noinspection JSUnusedGlobalSymbols\r\n\t\tthis.prevStart = this._start;\r\n\t\t// noinspection ConditionalExpressionJS\r\n\t\tthis._start = (this.backward) ? this.length : 0;\r\n\t}\r\n\t//**********************************************************************************\r\n\tget stream()\r\n\t{\r\n\t\treturn this._stream;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * Get next \"length\" bits from the stream\r\n\t * @param {number} length Number of bits to read\r\n\t * @returns {*}\r\n\t */\r\n\tgetBits(length)\r\n\t{\r\n\t\t//region Check input parameters \r\n\t\tif((this.start + length) > this.stream.bitsCount)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = (this.stream.bitsCount - this.start);\r\n\t\t}\r\n\t\t//endregion \r\n\t\t\r\n\t\t//region Initial variables \r\n\t\tlet result;\r\n\t\t//endregion \r\n\t\t\r\n\t\t//region Copy necessary length of bits\r\n\t\tif(this.backward)\r\n\t\t{\r\n\t\t\tresult = this.stream.copy(this.start - length, length);\r\n\t\t\tthis.start -= result.bitsCount;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tresult = this.stream.copy(this.start, length);\r\n\t\t\tthis.start += result.bitsCount;\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection FunctionTooLongJS\r\n\t/**\r\n\t * Get string representation for the next \"length\" bits from the stream\r\n\t * @param {number} length Number of bits to read\r\n\t * @returns {string}\r\n\t */\r\n\tgetBitsString(length)\r\n\t{\r\n\t\t//region Check input parameters\r\n\t\tif((this.start + length) > this.stream.bitsCount)\r\n\t\t{\r\n\t\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\t\tlength = (this.stream.bitsCount - this.start);\r\n\t\t}\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Initial variables\r\n\t\tlet result = [];\r\n\t\t\r\n\t\tlet start;\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(this.backward)\r\n\t\t\tstart = this.start - length;\r\n\t\telse\r\n\t\t\tstart = this.start;\r\n\t\t\r\n\t\tlet end = this.start + length - 1;\r\n\t\t\r\n\t\t//region Make ability to pass non-value bits\r\n\t\tlet valueShift = 0;\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(this.stream.bitsCount % 8)\r\n\t\t\tvalueShift = (8 - (this.stream.bitsCount % 8));\r\n\t\t\r\n\t\tstart += valueShift;\r\n\t\tend += valueShift;\r\n\t\t//endregion\r\n\t\t\r\n\t\tconst startIndex = start >> 3;\r\n\t\t// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst startOffset = start & 0x07;\r\n\t\t\r\n\t\tconst endIndex = end >> 3;\r\n\t\t// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst endOffset = end & 0x07;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS\r\n\t\tconst bitsLengthIndex = startIndex + (((endIndex - startIndex) == 0) ? 1 : (endIndex - startIndex + 1));\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Get string representation of bits\r\n\t\tfor(let i = startIndex; i < bitsLengthIndex; i++)\r\n\t\t{\r\n\t\t\tlet value = bitsToStringArray[this.stream.view[i]];\r\n\t\t\t\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\t\tif(i == startIndex)\r\n\t\t\t\tvalue = value.slice(startOffset);\r\n\t\t\t\r\n\t\t\t// noinspection EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\t\tif(i == (bitsLengthIndex - 1))\r\n\t\t\t\tvalue = value.slice(0, endOffset - 7 + value.length);\r\n\t\t\t\r\n\t\t\tresult.push(value);\r\n\t\t}\r\n\t\t\r\n\t\tresult = result.join(\"\");\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Change internal values\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(this.backward)\r\n\t\t\tthis.start -= result.length;\r\n\t\telse\r\n\t\t\tthis.start += result.length;\r\n\t\t//endregion\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t//**********************************************************************************\r\n\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS\r\n\t/**\r\n\t * Get number value representation of the next \"length\" bits from the stream, preliminary reversed\r\n\t * @param {number} length Number of bits to read\r\n\t * @returns {*}\r\n\t */\r\n\tgetBitsReversedValue(length)\r\n\t{\r\n\t\t//region Initial variables \r\n\t\tconst initialValue = this.getBitsString(length);\r\n\t\tconst initialValueLength = initialValue.length;\r\n\t\t\r\n\t\tlet byteIndex;\r\n\t\t\r\n\t\tconst initialOffset = 8 - (initialValueLength % 8);\r\n\t\t\r\n\t\tconst reversedValue = new Array(initialValueLength);\r\n\t\t\r\n\t\tconst value = new Uint32Array(1);\r\n\t\tconst valueView = new Uint8Array(value.buffer, 0, 4);\r\n\t\t\r\n\t\tlet i;\r\n\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, MagicNumberJS, NonBlockStatementBodyJS\r\n\t\tif(initialValueLength > 32)\r\n\t\t\treturn (-1);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, MagicNumberJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\tif(length == 32)\r\n\t\t\tbyteIndex = 3;\r\n\t\telse\r\n\t\t\tbyteIndex = ((initialValueLength - 1) >> 3);\r\n\t\t//endregion\r\n\t\t\r\n\t\t//region Reverse value \r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tfor(i = 0; i < initialValueLength; i++)\r\n\t\t\treversedValue[initialValueLength - 1 - i] = initialValue[i];\r\n\t\t//endregion \r\n\t\t\r\n\t\t//region Convert byte array to \"Uint32Array\" value \r\n\t\tfor(i = initialOffset; i < (initialOffset + initialValueLength); i++)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS\r\n\t\t\tif(reversedValue[i - initialOffset] == \"1\")\r\n\t\t\t{\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tvalueView[byteIndex] |= 0x01 << (7 - (i % 8));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS\r\n\t\t\tif(i && (((i + 1) % 8) == 0))\r\n\t\t\t\tbyteIndex--;\r\n\t\t}\r\n\t\t//endregion \r\n\t\t\r\n\t\treturn value[0];\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Represent remaining bits in \"BitStream\" as a string\r\n\t * @return {string}\r\n\t */\r\n\ttoString()\r\n\t{\r\n\t\tconst streamToDisplay = this.stream.copy(this.start, this.length);\r\n\t\treturn streamToDisplay.toString();\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/bytestreamjs/src/bytestream.js\n// module id = ./node_modules/bytestreamjs/src/bytestream.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _GeneralName = _interopRequireDefault(require(\"./GeneralName.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass AccessDescription {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AccessDescription class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc The type and format of the information are specified by the accessMethod field. This profile defines two accessMethod OIDs: id-ad-caIssuers and id-ad-ocsp\r\n     */\n    this.accessMethod = (0, _pvutils.getParametersValue)(parameters, \"accessMethod\", AccessDescription.defaultValues(\"accessMethod\"));\n    /**\r\n     * @type {GeneralName}\r\n     * @desc The accessLocation field specifies the location of the information\r\n     */\n\n    this.accessLocation = (0, _pvutils.getParametersValue)(parameters, \"accessLocation\", AccessDescription.defaultValues(\"accessLocation\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"accessMethod\":\n        return \"\";\n\n      case \"accessLocation\":\n        return new _GeneralName.default();\n\n      default:\n        throw new Error(`Invalid member name for AccessDescription class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AccessDescription  ::=  SEQUENCE {\r\n   *    accessMethod          OBJECT IDENTIFIER,\r\n   *    accessLocation        GeneralName  }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [accessMethod]\r\n     * @property {string} [accessLocation]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.accessMethod || \"\"\n      }), _GeneralName.default.schema(names.accessLocation || {})]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"accessMethod\", \"accessLocation\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AccessDescription.schema({\n      names: {\n        accessMethod: \"accessMethod\",\n        accessLocation: {\n          names: {\n            blockName: \"accessLocation\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AccessDescription\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.accessMethod = asn1.result.accessMethod.valueBlock.toString();\n    this.accessLocation = new _GeneralName.default({\n      schema: asn1.result.accessLocation\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.accessMethod\n      }), this.accessLocation.toSchema()]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      accessMethod: this.accessMethod,\n      accessLocation: this.accessLocation.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = AccessDescription;\n//# sourceMappingURL=AccessDescription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/AccessDescription.js\n// module id = ./node_modules/pkijs/build/AccessDescription.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC3161. Accuracy represents the time deviation around the UTC time contained in GeneralizedTime.\r\n */\nclass Accuracy {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for Accuracy class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    if (\"seconds\" in parameters)\n      /**\r\n       * @type {number}\r\n       * @desc seconds\r\n       */\n      this.seconds = (0, _pvutils.getParametersValue)(parameters, \"seconds\", Accuracy.defaultValues(\"seconds\"));\n    if (\"millis\" in parameters)\n      /**\r\n       * @type {number}\r\n       * @desc millis\r\n       */\n      this.millis = (0, _pvutils.getParametersValue)(parameters, \"millis\", Accuracy.defaultValues(\"millis\"));\n    if (\"micros\" in parameters)\n      /**\r\n       * @type {number}\r\n       * @desc micros\r\n       */\n      this.micros = (0, _pvutils.getParametersValue)(parameters, \"micros\", Accuracy.defaultValues(\"micros\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"seconds\":\n      case \"millis\":\n      case \"micros\":\n        return 0;\n\n      default:\n        throw new Error(`Invalid member name for Accuracy class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"seconds\":\n      case \"millis\":\n      case \"micros\":\n        return memberValue === Accuracy.defaultValues(memberName);\n\n      default:\n        throw new Error(`Invalid member name for Accuracy class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * Accuracy ::= SEQUENCE {\r\n   *    seconds        INTEGER              OPTIONAL,\r\n   *    millis     [0] INTEGER  (1..999)    OPTIONAL,\r\n   *    micros     [1] INTEGER  (1..999)    OPTIONAL  }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [seconds]\r\n     * @property {string} [millis]\r\n     * @property {string} [micros]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      optional: true,\n      value: [new asn1js.Integer({\n        optional: true,\n        name: names.seconds || \"\"\n      }), new asn1js.Primitive({\n        name: names.millis || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        }\n      }), new asn1js.Primitive({\n        name: names.micros || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        }\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"seconds\", \"millis\", \"micros\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, Accuracy.schema({\n      names: {\n        seconds: \"seconds\",\n        millis: \"millis\",\n        micros: \"micros\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for Accuracy\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"seconds\" in asn1.result) this.seconds = asn1.result.seconds.valueBlock.valueDec;\n\n    if (\"millis\" in asn1.result) {\n      const intMillis = new asn1js.Integer({\n        valueHex: asn1.result.millis.valueBlock.valueHex\n      });\n      this.millis = intMillis.valueBlock.valueDec;\n    }\n\n    if (\"micros\" in asn1.result) {\n      const intMicros = new asn1js.Integer({\n        valueHex: asn1.result.micros.valueBlock.valueHex\n      });\n      this.micros = intMicros.valueBlock.valueDec;\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array of output sequence\n    const outputArray = [];\n    if (\"seconds\" in this) outputArray.push(new asn1js.Integer({\n      value: this.seconds\n    }));\n\n    if (\"millis\" in this) {\n      const intMillis = new asn1js.Integer({\n        value: this.millis\n      });\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        valueHex: intMillis.valueBlock.valueHex\n      }));\n    }\n\n    if (\"micros\" in this) {\n      const intMicros = new asn1js.Integer({\n        value: this.micros\n      });\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        valueHex: intMicros.valueBlock.valueHex\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {};\n    if (\"seconds\" in this) _object.seconds = this.seconds;\n    if (\"millis\" in this) _object.millis = this.millis;\n    if (\"micros\" in this) _object.micros = this.micros;\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = Accuracy;\n//# sourceMappingURL=Accuracy.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/Accuracy.js\n// module id = ./node_modules/pkijs/build/Accuracy.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass AlgorithmIdentifier {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AlgorithmIdentifier class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc ObjectIdentifier for algorithm (string representation)\r\n     */\n    this.algorithmId = (0, _pvutils.getParametersValue)(parameters, \"algorithmId\", AlgorithmIdentifier.defaultValues(\"algorithmId\"));\n    if (\"algorithmParams\" in parameters)\n      /**\r\n       * @type {Object}\r\n       * @desc Any algorithm parameters\r\n       */\n      this.algorithmParams = (0, _pvutils.getParametersValue)(parameters, \"algorithmParams\", AlgorithmIdentifier.defaultValues(\"algorithmParams\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"algorithmId\":\n        return \"\";\n\n      case \"algorithmParams\":\n        return new asn1js.Any();\n\n      default:\n        throw new Error(`Invalid member name for AlgorithmIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"algorithmId\":\n        return memberValue === \"\";\n\n      case \"algorithmParams\":\n        return memberValue instanceof asn1js.Any;\n\n      default:\n        throw new Error(`Invalid member name for AlgorithmIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AlgorithmIdentifier  ::=  Sequence  {\r\n   *    algorithm               OBJECT IDENTIFIER,\r\n   *    parameters              ANY DEFINED BY algorithm OPTIONAL  }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} algorithmIdentifier ObjectIdentifier for the algorithm\r\n     * @property {string} algorithmParams Any algorithm parameters\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      optional: names.optional || false,\n      value: [new asn1js.ObjectIdentifier({\n        name: names.algorithmIdentifier || \"\"\n      }), new asn1js.Any({\n        name: names.algorithmParams || \"\",\n        optional: true\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"algorithm\", \"params\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AlgorithmIdentifier.schema({\n      names: {\n        algorithmIdentifier: \"algorithm\",\n        algorithmParams: \"params\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AlgorithmIdentifier\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.algorithmId = asn1.result.algorithm.valueBlock.toString();\n    if (\"params\" in asn1.result) this.algorithmParams = asn1.result.params; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.ObjectIdentifier({\n      value: this.algorithmId\n    }));\n    if (\"algorithmParams\" in this && this.algorithmParams instanceof asn1js.Any === false) outputArray.push(this.algorithmParams); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      algorithmId: this.algorithmId\n    };\n    if (\"algorithmParams\" in this && this.algorithmParams instanceof asn1js.Any === false) object.algorithmParams = this.algorithmParams.toJSON();\n    return object;\n  } //**********************************************************************************\n\n  /**\r\n   * Check that two \"AlgorithmIdentifiers\" are equal\r\n   * @param {AlgorithmIdentifier} algorithmIdentifier\r\n   * @returns {boolean}\r\n   */\n\n\n  isEqual(algorithmIdentifier) {\n    //region Check input type\n    if (algorithmIdentifier instanceof AlgorithmIdentifier === false) return false; //endregion\n    //region Check \"algorithm_id\"\n\n    if (this.algorithmId !== algorithmIdentifier.algorithmId) return false; //endregion\n    //region Check \"algorithm_params\"\n\n    if (\"algorithmParams\" in this) {\n      if (\"algorithmParams\" in algorithmIdentifier) return JSON.stringify(this.algorithmParams) === JSON.stringify(algorithmIdentifier.algorithmParams);\n      return false;\n    }\n\n    if (\"algorithmParams\" in algorithmIdentifier) return false; //endregion\n\n    return true;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = AlgorithmIdentifier;\n//# sourceMappingURL=AlgorithmIdentifier.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/AlgorithmIdentifier.js\n// module id = ./node_modules/pkijs/build/AlgorithmIdentifier.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _GeneralName = _interopRequireDefault(require(\"./GeneralName.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass AltName {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AltName class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<GeneralName>}\r\n     * @desc Array of alternative names in GeneralName type\r\n     */\n    this.altNames = (0, _pvutils.getParametersValue)(parameters, \"altNames\", AltName.defaultValues(\"altNames\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"altNames\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for AltName class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AltName ::= GeneralNames\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [altNames]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.altNames || \"\",\n        value: _GeneralName.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"altNames\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AltName.schema({\n      names: {\n        altNames: \"altNames\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AltName\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"altNames\" in asn1.result) this.altNames = Array.from(asn1.result.altNames, element => new _GeneralName.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.altNames, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      altNames: Array.from(this.altNames, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = AltName;\n//# sourceMappingURL=AltName.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/AltName.js\n// module id = ./node_modules/pkijs/build/AltName.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC2986\r\n */\nclass Attribute {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for Attribute class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc ObjectIdentifier for attribute (string representation)\r\n     */\n    this.type = (0, _pvutils.getParametersValue)(parameters, \"type\", Attribute.defaultValues(\"type\"));\n    /**\r\n     * @type {Array}\r\n     * @desc Any attribute values\r\n     */\n\n    this.values = (0, _pvutils.getParametersValue)(parameters, \"values\", Attribute.defaultValues(\"values\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"type\":\n        return \"\";\n\n      case \"values\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for Attribute class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"type\":\n        return memberValue === \"\";\n\n      case \"values\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for Attribute class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {\r\n   *    type   ATTRIBUTE.&id({IOSet}),\r\n   *    values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [type]\r\n     * @property {string} [setName]\r\n     * @property {string} [values]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.type || \"\"\n      }), new asn1js.Set({\n        name: names.setName || \"\",\n        value: [new asn1js.Repeated({\n          name: names.values || \"\",\n          value: new asn1js.Any()\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"type\", \"values\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, Attribute.schema({\n      names: {\n        type: \"type\",\n        values: \"values\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for Attribute\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.type = asn1.result.type.valueBlock.toString();\n    this.values = asn1.result.values; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.type\n      }), new asn1js.Set({\n        value: this.values\n      })]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      type: this.type,\n      values: Array.from(this.values, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = Attribute;\n//# sourceMappingURL=Attribute.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/Attribute.js\n// module id = ./node_modules/pkijs/build/Attribute.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.AttributeCertificateInfoV1 = exports.IssuerSerial = exports.AttCertValidityPeriod = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _GeneralNames = _interopRequireDefault(require(\"./GeneralNames.js\"));\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _Attribute = _interopRequireDefault(require(\"./Attribute.js\"));\n\nvar _Extensions = _interopRequireDefault(require(\"./Extensions.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5755\r\n */\nclass AttCertValidityPeriod {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AttCertValidityPeriod class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {GeneralizedTime}\r\n     * @desc notBeforeTime\r\n     */\n    this.notBeforeTime = (0, _pvutils.getParametersValue)(parameters, \"notBeforeTime\", AttCertValidityPeriod.defaultValues(\"notBeforeTime\"));\n    /**\r\n     * @type {GeneralizedTime}\r\n     * @desc notAfterTime\r\n     */\n\n    this.notAfterTime = (0, _pvutils.getParametersValue)(parameters, \"notAfterTime\", AttCertValidityPeriod.defaultValues(\"notAfterTime\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"notBeforeTime\":\n      case \"notAfterTime\":\n        return new Date(0, 0, 0);\n\n      default:\n        throw new Error(`Invalid member name for AttCertValidityPeriod class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AttCertValidityPeriod  ::= SEQUENCE {\r\n   *   notBeforeTime  GeneralizedTime,\r\n   *   notAfterTime   GeneralizedTime\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [notBeforeTime]\r\n     * @property {string} [notAfterTime]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.GeneralizedTime({\n        name: names.notBeforeTime || \"\"\n      }), new asn1js.GeneralizedTime({\n        name: names.notAfterTime || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"notBeforeTime\", \"notAfterTime\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AttCertValidityPeriod.schema({\n      names: {\n        notBeforeTime: \"notBeforeTime\",\n        notAfterTime: \"notAfterTime\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AttCertValidityPeriod\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.notBeforeTime = asn1.result.notBeforeTime.toDate();\n    this.notAfterTime = asn1.result.notAfterTime.toDate(); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.GeneralizedTime({\n        valueDate: this.notBeforeTime\n      }), new asn1js.GeneralizedTime({\n        valueDate: this.notAfterTime\n      })]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      notBeforeTime: this.notBeforeTime,\n      notAfterTime: this.notAfterTime\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * Class from RFC5755\r\n */\n\n\nexports.AttCertValidityPeriod = AttCertValidityPeriod;\n\nclass IssuerSerial {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for IssuerSerial class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {RelativeDistinguishedNames}\r\n     * @desc issuer\r\n     */\n    this.issuer = (0, _pvutils.getParametersValue)(parameters, \"issuer\", IssuerSerial.defaultValues(\"issuer\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc serialNumber\r\n     */\n\n    this.serialNumber = (0, _pvutils.getParametersValue)(parameters, \"serialNumber\", IssuerSerial.defaultValues(\"serialNumber\"));\n    if (\"issuerUID\" in parameters)\n      /**\r\n       * @type {BitString}\r\n       * @desc issuerUID\r\n       */\n      this.issuerUID = (0, _pvutils.getParametersValue)(parameters, \"issuerUID\", IssuerSerial.defaultValues(\"issuerUID\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"issuer\":\n        return new _GeneralNames.default();\n\n      case \"serialNumber\":\n        return new asn1js.Integer();\n\n      case \"issuerUID\":\n        return new asn1js.BitString();\n\n      default:\n        throw new Error(`Invalid member name for IssuerSerial class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * IssuerSerial  ::=  SEQUENCE {\r\n   *   \tissuer         GeneralNames,\r\n   * \t\tserial         CertificateSerialNumber,\r\n   * \t\tissuerUID      UniqueIdentifier OPTIONAL\r\n   * }\r\n   *\r\n   * CertificateSerialNumber ::= INTEGER\r\n   * UniqueIdentifier  ::=  BIT STRING\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [issuer]\r\n     * @property {string} [serialNumber]\r\n     * @property {string} [issuerUID]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_GeneralNames.default.schema(names.issuer || {}), new asn1js.Integer({\n        name: names.serialNumber || \"\"\n      }), new asn1js.BitString({\n        optional: true,\n        name: names.issuerUID || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"issuer\", \"serialNumber\", \"issuerUID\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, IssuerSerial.schema({\n      names: {\n        issuer: {\n          names: {\n            blockName: \"issuer\"\n          }\n        },\n        serialNumber: \"serialNumber\",\n        issuerUID: \"issuerUID\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for IssuerSerial\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.issuer = new _GeneralNames.default({\n      schema: asn1.result.issuer\n    });\n    this.serialNumber = asn1.result.serialNumber;\n    if (\"issuerUID\" in asn1.result) this.issuerUID = asn1.result.issuerUID; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    const result = new asn1js.Sequence({\n      value: [this.issuer.toSchema(), this.serialNumber]\n    });\n    if (\"issuerUID\" in this) result.valueBlock.value.push(this.issuerUID); //region Construct and return new ASN.1 schema for this object\n\n    return result; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const result = {\n      issuer: this.issuer.toJSON(),\n      serialNumber: this.serialNumber.toJSON()\n    };\n    if (\"issuerUID\" in this) result.issuerUID = this.issuerUID.toJSON();\n    return result;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * Class from RFC5755\r\n */\n\n\nexports.IssuerSerial = IssuerSerial;\n\nclass AttributeCertificateInfoV1 {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AttributeCertificateInfoV1 class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", AttributeCertificateInfoV1.defaultValues(\"version\"));\n    if (\"baseCertificateID\" in parameters)\n      /**\r\n       * @type {IssuerSerial}\r\n       * @desc baseCertificateID\r\n       */\n      this.baseCertificateID = (0, _pvutils.getParametersValue)(parameters, \"baseCertificateID\", AttributeCertificateInfoV1.defaultValues(\"baseCertificateID\"));\n    if (\"subjectName\" in parameters)\n      /**\r\n       * @type {GeneralNames}\r\n       * @desc subjectName\r\n       */\n      this.subjectName = (0, _pvutils.getParametersValue)(parameters, \"subjectName\", AttributeCertificateInfoV1.defaultValues(\"subjectName\"));\n    /**\r\n     * @type {GeneralNames}\r\n     * @desc issuer\r\n     */\n\n    this.issuer = (0, _pvutils.getParametersValue)(parameters, \"issuer\", AttributeCertificateInfoV1.defaultValues(\"issuer\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc signature\r\n     */\n\n    this.signature = (0, _pvutils.getParametersValue)(parameters, \"signature\", AttributeCertificateInfoV1.defaultValues(\"signature\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc serialNumber\r\n     */\n\n    this.serialNumber = (0, _pvutils.getParametersValue)(parameters, \"serialNumber\", AttributeCertificateInfoV1.defaultValues(\"serialNumber\"));\n    /**\r\n     * @type {AttCertValidityPeriod}\r\n     * @desc attrCertValidityPeriod\r\n     */\n\n    this.attrCertValidityPeriod = (0, _pvutils.getParametersValue)(parameters, \"attrCertValidityPeriod\", AttributeCertificateInfoV1.defaultValues(\"attrCertValidityPeriod\"));\n    /**\r\n     * @type {Array.<Attribute>}\r\n     * @desc attributes\r\n     */\n\n    this.attributes = (0, _pvutils.getParametersValue)(parameters, \"attributes\", AttributeCertificateInfoV1.defaultValues(\"attributes\"));\n    if (\"issuerUniqueID\" in parameters)\n      /**\r\n       * @type {BitString}\r\n       * @desc issuerUniqueID\r\n       */\n      this.issuerUniqueID = (0, _pvutils.getParametersValue)(parameters, \"issuerUniqueID\", AttributeCertificateInfoV1.defaultValues(\"issuerUniqueID\"));\n    if (\"extensions\" in parameters)\n      /**\r\n       * @type {Extensions}\r\n       * @desc extensions\r\n       */\n      this.extensions = (0, _pvutils.getParametersValue)(parameters, \"extensions\", AttributeCertificateInfoV1.defaultValues(\"extensions\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"baseCertificateID\":\n        return new IssuerSerial();\n\n      case \"subjectName\":\n        return new _GeneralNames.default();\n\n      case \"issuer\":\n        return {};\n\n      case \"signature\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"serialNumber\":\n        return new asn1js.Integer();\n\n      case \"attrCertValidityPeriod\":\n        return new AttCertValidityPeriod();\n\n      case \"attributes\":\n        return [];\n\n      case \"issuerUniqueID\":\n        return new asn1js.BitString();\n\n      case \"extensions\":\n        return new _Extensions.default();\n\n      default:\n        throw new Error(`Invalid member name for AttributeCertificateInfoV1 class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AttributeCertificateInfo ::= SEQUENCE {\r\n   * \tversion Version DEFAULT v1,\r\n   * \tsubject CHOICE {\r\n   * \t\tbaseCertificateID [0] IssuerSerial, -- associated with a Public Key Certificate\r\n   * \t\tsubjectName [1] GeneralNames }, -- associated with a name\r\n   * \tissuer GeneralNames, -- CA issuing the attribute certificate\r\n   * \tsignature AlgorithmIdentifier,\r\n   * \tserialNumber CertificateSerialNumber,\r\n   * \tattrCertValidityPeriod AttCertValidityPeriod,\r\n   * \tattributes SEQUENCE OF Attribute,\r\n   * \tissuerUniqueID UniqueIdentifier OPTIONAL,\r\n   * \textensions Extensions OPTIONAL\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [issuer]\r\n     * @property {string} [serialNumber]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), new asn1js.Choice({\n        value: [new asn1js.Constructed({\n          name: names.baseCertificateID || \"\",\n          idBlock: {\n            tagClass: 3,\n            tagNumber: 0 // [0]\n\n          },\n          value: IssuerSerial.schema().valueBlock.value\n        }), new asn1js.Constructed({\n          name: names.subjectName || \"\",\n          idBlock: {\n            tagClass: 3,\n            tagNumber: 1 // [2]\n\n          },\n          value: _GeneralNames.default.schema().valueBlock.value\n        })]\n      }), _GeneralNames.default.schema({\n        names: {\n          blockName: names.issuer || \"\"\n        }\n      }), _AlgorithmIdentifier.default.schema(names.signature || {}), new asn1js.Integer({\n        name: names.serialNumber || \"\"\n      }), AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}), new asn1js.Sequence({\n        name: names.attributes || \"\",\n        value: [new asn1js.Repeated({\n          value: _Attribute.default.schema()\n        })]\n      }), new asn1js.BitString({\n        optional: true,\n        name: names.issuerUniqueID || \"\"\n      }), _Extensions.default.schema(names.extensions || {}, true)]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"baseCertificateID\", \"subjectName\", \"issuer\", \"signature\", \"serialNumber\", \"attrCertValidityPeriod\", \"attributes\", \"issuerUniqueID\", \"extensions\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AttributeCertificateInfoV1.schema({\n      names: {\n        version: \"version\",\n        baseCertificateID: \"baseCertificateID\",\n        subjectName: \"subjectName\",\n        issuer: \"issuer\",\n        signature: {\n          names: {\n            blockName: \"signature\"\n          }\n        },\n        serialNumber: \"serialNumber\",\n        attrCertValidityPeriod: {\n          names: {\n            blockName: \"attrCertValidityPeriod\"\n          }\n        },\n        attributes: \"attributes\",\n        issuerUniqueID: \"issuerUniqueID\",\n        extensions: {\n          names: {\n            blockName: \"extensions\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AttributeCertificateInfoV1\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n\n    if (\"baseCertificateID\" in asn1.result) {\n      this.baseCertificateID = new IssuerSerial({\n        schema: new asn1js.Sequence({\n          value: asn1.result.baseCertificateID.valueBlock.value\n        })\n      });\n    }\n\n    if (\"subjectName\" in asn1.result) {\n      this.subjectName = new _GeneralNames.default({\n        schema: new asn1js.Sequence({\n          value: asn1.result.subjectName.valueBlock.value\n        })\n      });\n    }\n\n    this.issuer = asn1.result.issuer;\n    this.signature = new _AlgorithmIdentifier.default({\n      schema: asn1.result.signature\n    });\n    this.serialNumber = asn1.result.serialNumber;\n    this.attrCertValidityPeriod = new AttCertValidityPeriod({\n      schema: asn1.result.attrCertValidityPeriod\n    });\n    this.attributes = Array.from(asn1.result.attributes.valueBlock.value, element => new _Attribute.default({\n      schema: element\n    }));\n    if (\"issuerUniqueID\" in asn1.result) this.issuerUniqueID = asn1.result.issuerUniqueID;\n    if (\"extensions\" in asn1.result) this.extensions = new _Extensions.default({\n      schema: asn1.result.extensions\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    const result = new asn1js.Sequence({\n      value: [new asn1js.Integer({\n        value: this.version\n      })]\n    });\n\n    if (\"baseCertificateID\" in this) {\n      result.valueBlock.value.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 0 // [0]\n\n        },\n        value: this.baseCertificateID.toSchema().valueBlock.value\n      }));\n    }\n\n    if (\"subjectName\" in this) {\n      result.valueBlock.value.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 1 // [1]\n\n        },\n        value: this.subjectName.toSchema().valueBlock.value\n      }));\n    }\n\n    result.valueBlock.value.push(this.issuer.toSchema());\n    result.valueBlock.value.push(this.signature.toSchema());\n    result.valueBlock.value.push(this.serialNumber);\n    result.valueBlock.value.push(this.attrCertValidityPeriod.toSchema());\n    result.valueBlock.value.push(new asn1js.Sequence({\n      value: Array.from(this.attributes, element => element.toSchema())\n    }));\n    if (\"issuerUniqueID\" in this) result.valueBlock.value.push(this.issuerUniqueID);\n    if (\"extensions\" in this) result.valueBlock.value.push(this.extensions.toSchema());\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const result = {\n      version: this.version\n    };\n    if (\"baseCertificateID\" in this) result.baseCertificateID = this.baseCertificateID.toJSON();\n    if (\"subjectName\" in this) result.subjectName = this.subjectName.toJSON();\n    result.issuer = this.issuer.toJSON();\n    result.signature = this.signature.toJSON();\n    result.serialNumber = this.serialNumber.toJSON();\n    result.attrCertValidityPeriod = this.attrCertValidityPeriod.toJSON();\n    result.attributes = Array.from(this.attributes, element => element.toJSON());\n    if (\"issuerUniqueID\" in this) result.issuerUniqueID = this.issuerUniqueID.toJSON();\n    if (\"extensions\" in this) result.extensions = this.extensions.toJSON();\n    return result;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * Class from X.509:1997\r\n */\n\n\nexports.AttributeCertificateInfoV1 = AttributeCertificateInfoV1;\n\nclass AttributeCertificateV1 {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AttributeCertificateV1 class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AttributeCertificateInfoV1}\r\n     * @desc acinfo\r\n     */\n    this.acinfo = (0, _pvutils.getParametersValue)(parameters, \"acinfo\", AttributeCertificateV1.defaultValues(\"acinfo\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc signatureAlgorithm\r\n     */\n\n    this.signatureAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"signatureAlgorithm\", AttributeCertificateV1.defaultValues(\"signatureAlgorithm\"));\n    /**\r\n     * @type {BitString}\r\n     * @desc signatureValue\r\n     */\n\n    this.signatureValue = (0, _pvutils.getParametersValue)(parameters, \"signatureValue\", AttributeCertificateV1.defaultValues(\"signatureValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"acinfo\":\n        return new AttributeCertificateInfoV1();\n\n      case \"signatureAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"signatureValue\":\n        return new asn1js.BitString();\n\n      default:\n        throw new Error(`Invalid member name for AttributeCertificateV1 class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AttributeCertificate ::= SEQUENCE {\r\n   *   acinfo               AttributeCertificateInfoV1,\r\n   *   signatureAlgorithm   AlgorithmIdentifier,\r\n   *   signatureValue       BIT STRING\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {Object} [acinfo]\r\n     * @property {Object} [signatureAlgorithm]\r\n     * @property {string} [signatureValue]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [AttributeCertificateInfoV1.schema(names.acinfo || {}), _AlgorithmIdentifier.default.schema(names.signatureAlgorithm || {}), new asn1js.BitString({\n        name: names.signatureValue || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"acinfo\", \"signatureValue\", \"signatureAlgorithm\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AttributeCertificateV1.schema({\n      names: {\n        acinfo: {\n          names: {\n            blockName: \"acinfo\"\n          }\n        },\n        signatureAlgorithm: {\n          names: {\n            blockName: \"signatureAlgorithm\"\n          }\n        },\n        signatureValue: \"signatureValue\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AttributeCertificateV1\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.acinfo = new AttributeCertificateInfoV1({\n      schema: asn1.result.acinfo\n    });\n    this.signatureAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.signatureAlgorithm\n    });\n    this.signatureValue = asn1.result.signatureValue; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    return new asn1js.Sequence({\n      value: [this.acinfo.toSchema(), this.signatureAlgorithm.toSchema(), this.signatureValue]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      acinfo: this.acinfo.toJSON(),\n      signatureAlgorithm: this.signatureAlgorithm.toJSON(),\n      signatureValue: this.signatureValue.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = AttributeCertificateV1;\n//# sourceMappingURL=AttributeCertificateV1.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/AttributeCertificateV1.js\n// module id = ./node_modules/pkijs/build/AttributeCertificateV1.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.AttributeCertificateInfoV2 = exports.Holder = exports.V2Form = exports.ObjectDigestInfo = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _GeneralNames = _interopRequireDefault(require(\"./GeneralNames.js\"));\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _Attribute = _interopRequireDefault(require(\"./Attribute.js\"));\n\nvar _Extensions = _interopRequireDefault(require(\"./Extensions.js\"));\n\nvar _AttributeCertificateV = require(\"./AttributeCertificateV1.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5755\r\n */\nclass ObjectDigestInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for ObjectDigestInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Enumerated}\r\n     * @desc digestedObjectType\r\n     */\n    this.digestedObjectType = (0, _pvutils.getParametersValue)(parameters, \"digestedObjectType\", ObjectDigestInfo.defaultValues(\"digestedObjectType\"));\n    if (\"otherObjectTypeID\" in parameters)\n      /**\r\n       * @type {ObjectIdentifier}\r\n       * @desc otherObjectTypeID\r\n       */\n      this.otherObjectTypeID = (0, _pvutils.getParametersValue)(parameters, \"otherObjectTypeID\", ObjectDigestInfo.defaultValues(\"otherObjectTypeID\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc digestAlgorithm\r\n     */\n\n    this.digestAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"digestAlgorithm\", ObjectDigestInfo.defaultValues(\"digestAlgorithm\"));\n    /**\r\n     * @type {BitString}\r\n     * @desc objectDigest\r\n     */\n\n    this.objectDigest = (0, _pvutils.getParametersValue)(parameters, \"objectDigest\", ObjectDigestInfo.defaultValues(\"objectDigest\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"digestedObjectType\":\n        return new asn1js.Enumerated();\n\n      case \"otherObjectTypeID\":\n        return new asn1js.ObjectIdentifier();\n\n      case \"digestAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"objectDigest\":\n        return new asn1js.BitString();\n\n      default:\n        throw new Error(`Invalid member name for ObjectDigestInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * ObjectDigestInfo ::= SEQUENCE {\r\n   *   digestedObjectType  ENUMERATED {\r\n   *     publicKey            (0),\r\n   *     publicKeyCert        (1),\r\n   *     otherObjectTypes     (2) },\r\n   *   -- otherObjectTypes MUST NOT\r\n   *   -- be used in this profile\r\n   *   otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,\r\n   *   digestAlgorithm     AlgorithmIdentifier,\r\n   *   objectDigest        BIT STRING\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [digestedObjectType]\r\n     * @property {string} [otherObjectTypeID]\r\n     * @property {string} [digestAlgorithm]\r\n     * @property {string} [objectDigest]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Enumerated({\n        name: names.digestedObjectType || \"\"\n      }), new asn1js.ObjectIdentifier({\n        optional: true,\n        name: names.otherObjectTypeID || \"\"\n      }), _AlgorithmIdentifier.default.schema(names.digestAlgorithm || {}), new asn1js.BitString({\n        name: names.objectDigest || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"digestedObjectType\", \"otherObjectTypeID\", \"digestAlgorithm\", \"objectDigest\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, ObjectDigestInfo.schema({\n      names: {\n        digestedObjectType: \"digestedObjectType\",\n        otherObjectTypeID: \"otherObjectTypeID\",\n        digestAlgorithm: {\n          names: {\n            blockName: \"digestAlgorithm\"\n          }\n        },\n        objectDigest: \"objectDigest\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for ObjectDigestInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.digestedObjectType = asn1.result.digestedObjectType;\n    if (\"otherObjectTypeID\" in asn1.result) this.otherObjectTypeID = asn1.result.otherObjectTypeID;\n    this.digestAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.digestAlgorithm\n    });\n    this.objectDigest = asn1.result.objectDigest; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    const result = new asn1js.Sequence({\n      value: [this.digestedObjectType]\n    });\n    if (\"otherObjectTypeID\" in this) result.value.push(this.otherObjectTypeID);\n    result.value.push(this.digestAlgorithm.toSchema());\n    result.value.push(this.objectDigest);\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const result = {\n      digestedObjectType: this.digestedObjectType.toJSON()\n    };\n    if (\"otherObjectTypeID\" in this) result.otherObjectTypeID = this.otherObjectTypeID.toJSON();\n    result.digestAlgorithm = this.digestAlgorithm.toJSON();\n    result.objectDigest = this.objectDigest.toJSON();\n    return result;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * Class from RFC5755\r\n */\n\n\nexports.ObjectDigestInfo = ObjectDigestInfo;\n\nclass V2Form {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for V2Form class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    if (\"issuerName\" in parameters)\n      /**\r\n       * @type {GeneralNames}\r\n       * @desc issuerName\r\n       */\n      this.issuerName = (0, _pvutils.getParametersValue)(parameters, \"issuerName\", V2Form.defaultValues(\"issuerName\"));\n    if (\"baseCertificateID\" in parameters)\n      /**\r\n       * @type {IssuerSerial}\r\n       * @desc baseCertificateID\r\n       */\n      this.baseCertificateID = (0, _pvutils.getParametersValue)(parameters, \"baseCertificateID\", V2Form.defaultValues(\"baseCertificateID\"));\n    if (\"objectDigestInfo\" in parameters)\n      /**\r\n       * @type {ObjectDigestInfo}\r\n       * @desc objectDigestInfo\r\n       */\n      this.objectDigestInfo = (0, _pvutils.getParametersValue)(parameters, \"objectDigestInfo\", V2Form.defaultValues(\"objectDigestInfo\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"issuerName\":\n        return new _GeneralNames.default();\n\n      case \"baseCertificateID\":\n        return new _AttributeCertificateV.IssuerSerial();\n\n      case \"objectDigestInfo\":\n        return new ObjectDigestInfo();\n\n      default:\n        throw new Error(`Invalid member name for V2Form class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * V2Form ::= SEQUENCE {\r\n   *   issuerName            GeneralNames  OPTIONAL,\r\n   *   baseCertificateID     [0] IssuerSerial  OPTIONAL,\r\n   *   objectDigestInfo      [1] ObjectDigestInfo  OPTIONAL\r\n   *     -- issuerName MUST be present in this profile\r\n   *     -- baseCertificateID and objectDigestInfo MUST NOT\r\n   *     -- be present in this profile\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [issuerName]\r\n     * @property {string} [baseCertificateID]\r\n     * @property {string} [objectDigestInfo]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_GeneralNames.default.schema({\n        names: {\n          blockName: names.issuerName\n        }\n      }, true), new asn1js.Constructed({\n        optional: true,\n        name: names.baseCertificateID || \"\",\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 0 // [0]\n\n        },\n        value: _AttributeCertificateV.IssuerSerial.schema().valueBlock.value\n      }), new asn1js.Constructed({\n        optional: true,\n        name: names.objectDigestInfo || \"\",\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 1 // [1]\n\n        },\n        value: ObjectDigestInfo.schema().valueBlock.value\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"issuerName\", \"baseCertificateID\", \"objectDigestInfo\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, V2Form.schema({\n      names: {\n        issuerName: \"issuerName\",\n        baseCertificateID: \"baseCertificateID\",\n        objectDigestInfo: \"objectDigestInfo\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for V2Form\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"issuerName\" in asn1.result) this.issuerName = new _GeneralNames.default({\n      schema: asn1.result.issuerName\n    });\n\n    if (\"baseCertificateID\" in asn1.result) {\n      this.baseCertificateID = new _AttributeCertificateV.IssuerSerial({\n        schema: new asn1js.Sequence({\n          value: asn1.result.baseCertificateID.valueBlock.value\n        })\n      });\n    }\n\n    if (\"objectDigestInfo\" in asn1.result) {\n      this.objectDigestInfo = new ObjectDigestInfo({\n        schema: new asn1js.Sequence({\n          value: asn1.result.objectDigestInfo.valueBlock.value\n        })\n      });\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    const result = new asn1js.Sequence();\n    if (\"issuerName\" in this) result.valueBlock.value.push(this.issuerName.toSchema());\n\n    if (\"baseCertificateID\" in this) {\n      result.valueBlock.value.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 0 // [0]\n\n        },\n        value: this.baseCertificateID.toSchema().valueBlock.value\n      }));\n    }\n\n    if (\"objectDigestInfo\" in this) {\n      result.valueBlock.value.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 1 // [1]\n\n        },\n        value: this.objectDigestInfo.toSchema().valueBlock.value\n      }));\n    } //region Construct and return new ASN.1 schema for this object\n\n\n    return result; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const result = {};\n    if (\"issuerName\" in this) result.issuerName = this.issuerName.toJSON();\n    if (\"baseCertificateID\" in this) result.baseCertificateID = this.baseCertificateID.toJSON();\n    if (\"objectDigestInfo\" in this) result.objectDigestInfo = this.objectDigestInfo.toJSON();\n    return result;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * Class from RFC5755\r\n */\n\n\nexports.V2Form = V2Form;\n\nclass Holder {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for Holder class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    if (\"baseCertificateID\" in parameters)\n      /**\r\n       * @type {IssuerSerial}\r\n       * @desc baseCertificateID\r\n       */\n      this.baseCertificateID = (0, _pvutils.getParametersValue)(parameters, \"baseCertificateID\", Holder.defaultValues(\"baseCertificateID\"));\n    if (\"entityName\" in parameters)\n      /**\r\n       * @type {GeneralNames}\r\n       * @desc entityName\r\n       */\n      this.entityName = (0, _pvutils.getParametersValue)(parameters, \"entityName\", Holder.defaultValues(\"entityName\"));\n    if (\"objectDigestInfo\" in parameters)\n      /**\r\n       * @type {ObjectDigestInfo}\r\n       * @desc objectDigestInfo\r\n       */\n      this.objectDigestInfo = (0, _pvutils.getParametersValue)(parameters, \"objectDigestInfo\", Holder.defaultValues(\"objectDigestInfo\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"baseCertificateID\":\n        return new _AttributeCertificateV.IssuerSerial();\n\n      case \"entityName\":\n        return new _GeneralNames.default();\n\n      case \"objectDigestInfo\":\n        return new ObjectDigestInfo();\n\n      default:\n        throw new Error(`Invalid member name for Holder class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * Holder ::= SEQUENCE {\r\n   *   baseCertificateID   [0] IssuerSerial OPTIONAL,\r\n   *       -- the issuer and serial number of\r\n   *       -- the holder's Public Key Certificate\r\n   *   entityName          [1] GeneralNames OPTIONAL,\r\n   *       -- the name of the claimant or role\r\n   *   objectDigestInfo    [2] ObjectDigestInfo OPTIONAL\r\n   *       -- used to directly authenticate the holder,\r\n   *       -- for example, an executable\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [baseCertificateID]\r\n     * @property {string} [entityName]\r\n     * @property {string} [objectDigestInfo]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Constructed({\n        optional: true,\n        name: names.baseCertificateID || \"\",\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 0 // [0]\n\n        },\n        value: _AttributeCertificateV.IssuerSerial.schema().valueBlock.value\n      }), new asn1js.Constructed({\n        optional: true,\n        name: names.entityName || \"\",\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 1 // [2]\n\n        },\n        value: _GeneralNames.default.schema().valueBlock.value\n      }), new asn1js.Constructed({\n        optional: true,\n        name: names.objectDigestInfo || \"\",\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 2 // [2]\n\n        },\n        value: ObjectDigestInfo.schema().valueBlock.value\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"baseCertificateID\", \"entityName\", \"objectDigestInfo\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, Holder.schema({\n      names: {\n        baseCertificateID: \"baseCertificateID\",\n        entityName: \"entityName\",\n        objectDigestInfo: \"objectDigestInfo\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for Holder\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"baseCertificateID\" in asn1.result) {\n      this.baseCertificateID = new _AttributeCertificateV.IssuerSerial({\n        schema: new asn1js.Sequence({\n          value: asn1.result.baseCertificateID.valueBlock.value\n        })\n      });\n    }\n\n    if (\"entityName\" in asn1.result) {\n      this.entityName = new _GeneralNames.default({\n        schema: new asn1js.Sequence({\n          value: asn1.result.entityName.valueBlock.value\n        })\n      });\n    }\n\n    if (\"objectDigestInfo\" in asn1.result) {\n      this.objectDigestInfo = new ObjectDigestInfo({\n        schema: new asn1js.Sequence({\n          value: asn1.result.objectDigestInfo.valueBlock.value\n        })\n      });\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    const result = new asn1js.Sequence();\n\n    if (\"baseCertificateID\" in this) {\n      result.valueBlock.value.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 0 // [0]\n\n        },\n        value: this.baseCertificateID.toSchema().valueBlock.value\n      }));\n    }\n\n    if (\"entityName\" in this) {\n      result.valueBlock.value.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 1 // [1]\n\n        },\n        value: this.entityName.toSchema().valueBlock.value\n      }));\n    }\n\n    if (\"objectDigestInfo\" in this) {\n      result.valueBlock.value.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 2 // [2]\n\n        },\n        value: this.objectDigestInfo.toSchema().valueBlock.value\n      }));\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const result = {};\n    if (\"baseCertificateID\" in this) result.baseCertificateID = this.baseCertificateID.toJSON();\n    if (\"entityName\" in this) result.entityName = this.entityName.toJSON();\n    if (\"objectDigestInfo\" in this) result.objectDigestInfo = this.objectDigestInfo.toJSON();\n    return result;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * Class from RFC5755\r\n */\n\n\nexports.Holder = Holder;\n\nclass AttributeCertificateInfoV2 {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AttributeCertificateInfoV2 class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", AttributeCertificateInfoV2.defaultValues(\"version\"));\n    /**\r\n     * @type {Holder}\r\n     * @desc holder\r\n     */\n\n    this.holder = (0, _pvutils.getParametersValue)(parameters, \"holder\", AttributeCertificateInfoV2.defaultValues(\"holder\"));\n    /**\r\n     * @type {GeneralNames|V2Form}\r\n     * @desc issuer\r\n     */\n\n    this.issuer = (0, _pvutils.getParametersValue)(parameters, \"issuer\", AttributeCertificateInfoV2.defaultValues(\"issuer\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc signature\r\n     */\n\n    this.signature = (0, _pvutils.getParametersValue)(parameters, \"signature\", AttributeCertificateInfoV2.defaultValues(\"signature\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc serialNumber\r\n     */\n\n    this.serialNumber = (0, _pvutils.getParametersValue)(parameters, \"serialNumber\", AttributeCertificateInfoV2.defaultValues(\"serialNumber\"));\n    /**\r\n     * @type {AttCertValidityPeriod}\r\n     * @desc attrCertValidityPeriod\r\n     */\n\n    this.attrCertValidityPeriod = (0, _pvutils.getParametersValue)(parameters, \"attrCertValidityPeriod\", AttributeCertificateInfoV2.defaultValues(\"attrCertValidityPeriod\"));\n    /**\r\n     * @type {Array.<Attribute>}\r\n     * @desc attributes\r\n     */\n\n    this.attributes = (0, _pvutils.getParametersValue)(parameters, \"attributes\", AttributeCertificateInfoV2.defaultValues(\"attributes\"));\n    if (\"issuerUniqueID\" in parameters)\n      /**\r\n       * @type {BitString}\r\n       * @desc issuerUniqueID\r\n       */\n      this.issuerUniqueID = (0, _pvutils.getParametersValue)(parameters, \"issuerUniqueID\", AttributeCertificateInfoV2.defaultValues(\"issuerUniqueID\"));\n    if (\"extensions\" in parameters)\n      /**\r\n       * @type {Extensions}\r\n       * @desc extensions\r\n       */\n      this.extensions = (0, _pvutils.getParametersValue)(parameters, \"extensions\", AttributeCertificateInfoV2.defaultValues(\"extensions\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 1;\n\n      case \"holder\":\n        return new Holder();\n\n      case \"issuer\":\n        return {};\n\n      case \"signature\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"serialNumber\":\n        return new asn1js.Integer();\n\n      case \"attrCertValidityPeriod\":\n        return new _AttributeCertificateV.AttCertValidityPeriod();\n\n      case \"attributes\":\n        return [];\n\n      case \"issuerUniqueID\":\n        return new asn1js.BitString();\n\n      case \"extensions\":\n        return new _Extensions.default();\n\n      default:\n        throw new Error(`Invalid member name for AttributeCertificateInfoV2 class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AttributeCertificateInfoV2 ::= SEQUENCE {\r\n   *   version                 AttCertVersion, -- version is v2\r\n   *   holder                  Holder,\r\n   *   issuer                  AttCertIssuer,\r\n   *   signature               AlgorithmIdentifier,\r\n   *   serialNumber            CertificateSerialNumber,\r\n   *   attrCertValidityPeriod  AttCertValidityPeriod,\r\n   *   attributes              SEQUENCE OF Attribute,\r\n   *   issuerUniqueID          UniqueIdentifier OPTIONAL,\r\n   *   extensions              Extensions OPTIONAL\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [issuer]\r\n     * @property {string} [serialNumber]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), Holder.schema(names.holder || {}), new asn1js.Choice({\n        value: [_GeneralNames.default.schema({\n          names: {\n            blockName: names.issuer || \"\"\n          }\n        }), new asn1js.Constructed({\n          name: names.issuer || \"\",\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: V2Form.schema().valueBlock.value\n        })]\n      }), _AlgorithmIdentifier.default.schema(names.signature || {}), new asn1js.Integer({\n        name: names.serialNumber || \"\"\n      }), _AttributeCertificateV.AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}), new asn1js.Sequence({\n        name: names.attributes || \"\",\n        value: [new asn1js.Repeated({\n          value: _Attribute.default.schema()\n        })]\n      }), new asn1js.BitString({\n        optional: true,\n        name: names.issuerUniqueID || \"\"\n      }), _Extensions.default.schema(names.extensions || {}, true)]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"holder\", \"issuer\", \"signature\", \"serialNumber\", \"attrCertValidityPeriod\", \"attributes\", \"issuerUniqueID\", \"extensions\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AttributeCertificateInfoV2.schema({\n      names: {\n        version: \"version\",\n        holder: {\n          names: {\n            blockName: \"holder\"\n          }\n        },\n        issuer: \"issuer\",\n        signature: {\n          names: {\n            blockName: \"signature\"\n          }\n        },\n        serialNumber: \"serialNumber\",\n        attrCertValidityPeriod: {\n          names: {\n            blockName: \"attrCertValidityPeriod\"\n          }\n        },\n        attributes: \"attributes\",\n        issuerUniqueID: \"issuerUniqueID\",\n        extensions: {\n          names: {\n            blockName: \"extensions\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AttributeCertificateInfoV2\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n    this.holder = new Holder({\n      schema: asn1.result.holder\n    });\n\n    switch (asn1.result.issuer.idBlock.tagClass) {\n      case 3:\n        // V2Form\n        this.issuer = new V2Form({\n          schema: new asn1js.Sequence({\n            value: asn1.result.issuer.valueBlock.value\n          })\n        });\n        break;\n\n      case 1: // GeneralNames (should not be used)\n\n      default:\n        throw new Error(\"Incorect value for 'issuer' in AttributeCertificateInfoV2\");\n    }\n\n    this.signature = new _AlgorithmIdentifier.default({\n      schema: asn1.result.signature\n    });\n    this.serialNumber = asn1.result.serialNumber;\n    this.attrCertValidityPeriod = new _AttributeCertificateV.AttCertValidityPeriod({\n      schema: asn1.result.attrCertValidityPeriod\n    });\n    this.attributes = Array.from(asn1.result.attributes.valueBlock.value, element => new _Attribute.default({\n      schema: element\n    }));\n    if (\"issuerUniqueID\" in asn1.result) this.issuerUniqueID = asn1.result.issuerUniqueID;\n    if (\"extensions\" in asn1.result) this.extensions = new _Extensions.default({\n      schema: asn1.result.extensions\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    const result = new asn1js.Sequence({\n      value: [new asn1js.Integer({\n        value: this.version\n      }), this.holder.toSchema(), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: this.issuer.toSchema().valueBlock.value\n      }), this.signature.toSchema(), this.serialNumber, this.attrCertValidityPeriod.toSchema(), new asn1js.Sequence({\n        value: Array.from(this.attributes, element => element.toSchema())\n      })]\n    });\n    if (\"issuerUniqueID\" in this) result.valueBlock.value.push(this.issuerUniqueID);\n    if (\"extensions\" in this) result.valueBlock.value.push(this.extensions.toSchema());\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const result = {\n      version: this.version,\n      holder: this.holder.toJSON(),\n      issuer: this.issuer.toJSON(),\n      signature: this.signature.toJSON(),\n      serialNumber: this.serialNumber.toJSON(),\n      attrCertValidityPeriod: this.attrCertValidityPeriod.toJSON(),\n      attributes: Array.from(this.attributes, element => element.toJSON())\n    };\n    if (\"issuerUniqueID\" in this) result.issuerUniqueID = this.issuerUniqueID.toJSON();\n    if (\"extensions\" in this) result.extensions = this.extensions.toJSON();\n    return result;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * Class from RFC5755\r\n */\n\n\nexports.AttributeCertificateInfoV2 = AttributeCertificateInfoV2;\n\nclass AttributeCertificateV2 {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AttributeCertificateV2 class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AttributeCertificateInfoV2}\r\n     * @desc acinfo\r\n     */\n    this.acinfo = (0, _pvutils.getParametersValue)(parameters, \"acinfo\", AttributeCertificateV2.defaultValues(\"acinfo\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc signatureAlgorithm\r\n     */\n\n    this.signatureAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"signatureAlgorithm\", AttributeCertificateV2.defaultValues(\"signatureAlgorithm\"));\n    /**\r\n     * @type {BitString}\r\n     * @desc signatureValue\r\n     */\n\n    this.signatureValue = (0, _pvutils.getParametersValue)(parameters, \"signatureValue\", AttributeCertificateV2.defaultValues(\"signatureValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"acinfo\":\n        return new AttributeCertificateInfoV2();\n\n      case \"signatureAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"signatureValue\":\n        return new asn1js.BitString();\n\n      default:\n        throw new Error(`Invalid member name for AttributeCertificateV2 class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AttributeCertificate ::= SEQUENCE {\r\n   *   acinfo               AttributeCertificateInfoV2,\r\n   *   signatureAlgorithm   AlgorithmIdentifier,\r\n   *   signatureValue       BIT STRING\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {Object} [acinfo]\r\n     * @property {Object} [signatureAlgorithm]\r\n     * @property {string} [signatureValue]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [AttributeCertificateInfoV2.schema(names.acinfo || {}), _AlgorithmIdentifier.default.schema(names.signatureAlgorithm || {}), new asn1js.BitString({\n        name: names.signatureValue || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"acinfo\", \"signatureAlgorithm\", \"signatureValue\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AttributeCertificateV2.schema({\n      names: {\n        acinfo: {\n          names: {\n            blockName: \"acinfo\"\n          }\n        },\n        signatureAlgorithm: {\n          names: {\n            blockName: \"signatureAlgorithm\"\n          }\n        },\n        signatureValue: \"signatureValue\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AttributeCertificateV2\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.acinfo = new AttributeCertificateInfoV2({\n      schema: asn1.result.acinfo\n    });\n    this.signatureAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.signatureAlgorithm\n    });\n    this.signatureValue = asn1.result.signatureValue; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    return new asn1js.Sequence({\n      value: [this.acinfo.toSchema(), this.signatureAlgorithm.toSchema(), this.signatureValue]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      acinfo: this.acinfo.toJSON(),\n      signatureAlgorithm: this.signatureAlgorithm.toJSON(),\n      signatureValue: this.signatureValue.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = AttributeCertificateV2;\n//# sourceMappingURL=AttributeCertificateV2.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/AttributeCertificateV2.js\n// module id = ./node_modules/pkijs/build/AttributeCertificateV2.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass AttributeTypeAndValue {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AttributeTypeAndValue class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc type\r\n     */\n    this.type = (0, _pvutils.getParametersValue)(parameters, \"type\", AttributeTypeAndValue.defaultValues(\"type\"));\n    /**\r\n     * @type {Object}\r\n     * @desc Value of the AttributeTypeAndValue class\r\n     */\n\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", AttributeTypeAndValue.defaultValues(\"value\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"type\":\n        return \"\";\n\n      case \"value\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for AttributeTypeAndValue class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AttributeTypeAndValue ::= Sequence {\r\n   *    type     AttributeType,\r\n   *    value    AttributeValue }\r\n   *\r\n   * AttributeType ::= OBJECT IDENTIFIER\r\n   *\r\n   * AttributeValue ::= ANY -- DEFINED BY AttributeType\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName] Name for entire block\r\n     * @property {string} [type] Name for \"type\" element\r\n     * @property {string} [value] Name for \"value\" element\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.type || \"\"\n      }), new asn1js.Any({\n        name: names.value || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n\n  static blockName() {\n    return \"AttributeTypeAndValue\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"type\", \"typeValue\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AttributeTypeAndValue.schema({\n      names: {\n        type: \"type\",\n        value: \"typeValue\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AttributeTypeAndValue\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.type = asn1.result.type.valueBlock.toString(); // noinspection JSUnresolvedVariable\n\n    this.value = asn1.result.typeValue; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.type\n      }), this.value]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      type: this.type\n    };\n    if (Object.keys(this.value).length !== 0) _object.value = this.value.toJSON();else _object.value = this.value;\n    return _object;\n  } //**********************************************************************************\n\n  /**\r\n   * Compare two AttributeTypeAndValue values, or AttributeTypeAndValue with ArrayBuffer value\r\n   * @param {(AttributeTypeAndValue|ArrayBuffer)} compareTo The value compare to current\r\n   * @returns {boolean}\r\n   */\n\n\n  isEqual(compareTo) {\n    const stringBlockNames = [asn1js.Utf8String.blockName(), asn1js.BmpString.blockName(), asn1js.UniversalString.blockName(), asn1js.NumericString.blockName(), asn1js.PrintableString.blockName(), asn1js.TeletexString.blockName(), asn1js.VideotexString.blockName(), asn1js.IA5String.blockName(), asn1js.GraphicString.blockName(), asn1js.VisibleString.blockName(), asn1js.GeneralString.blockName(), asn1js.CharacterString.blockName()];\n\n    if (compareTo.constructor.blockName() === AttributeTypeAndValue.blockName()) {\n      if (this.type !== compareTo.type) return false; //region Check we do have both strings\n\n      let isString = false;\n      const thisName = this.value.constructor.blockName();\n\n      if (thisName === compareTo.value.constructor.blockName()) {\n        var _iterator = _createForOfIteratorHelper(stringBlockNames),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            const name = _step.value;\n\n            if (thisName === name) {\n              isString = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } //endregion\n\n\n      if (isString) {\n        const value1 = (0, _common.stringPrep)(this.value.valueBlock.value);\n        const value2 = (0, _common.stringPrep)(compareTo.value.valueBlock.value);\n        if (value1.localeCompare(value2) !== 0) return false;\n      } else // Comparing as two ArrayBuffers\n        {\n          if ((0, _pvutils.isEqualBuffer)(this.value.valueBeforeDecode, compareTo.value.valueBeforeDecode) === false) return false;\n        }\n\n      return true;\n    }\n\n    if (compareTo instanceof ArrayBuffer) return (0, _pvutils.isEqualBuffer)(this.value.valueBeforeDecode, compareTo);\n    return false;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = AttributeTypeAndValue;\n//# sourceMappingURL=AttributeTypeAndValue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/AttributeTypeAndValue.js\n// module id = ./node_modules/pkijs/build/AttributeTypeAndValue.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _ContentInfo = _interopRequireDefault(require(\"./ContentInfo.js\"));\n\nvar _SafeContents = _interopRequireDefault(require(\"./SafeContents.js\"));\n\nvar _EnvelopedData = _interopRequireDefault(require(\"./EnvelopedData.js\"));\n\nvar _EncryptedData = _interopRequireDefault(require(\"./EncryptedData.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC7292\r\n */\nclass AuthenticatedSafe {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AuthenticatedSafe class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<ContentInfo>}\r\n     * @desc safeContents\r\n     */\n    this.safeContents = (0, _pvutils.getParametersValue)(parameters, \"safeContents\", AuthenticatedSafe.defaultValues(\"safeContents\"));\n    if (\"parsedValue\" in parameters)\n      /**\r\n       * @type {*}\r\n       * @desc parsedValue\r\n       */\n      this.parsedValue = (0, _pvutils.getParametersValue)(parameters, \"parsedValue\", AuthenticatedSafe.defaultValues(\"parsedValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"safeContents\":\n        return [];\n\n      case \"parsedValue\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for AuthenticatedSafe class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"safeContents\":\n        return memberValue.length === 0;\n\n      case \"parsedValue\":\n        return memberValue instanceof Object && Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for AuthenticatedSafe class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\r\n   * -- Data if unencrypted\r\n   * -- EncryptedData if password-encrypted\r\n   * -- EnvelopedData if public key-encrypted\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [contentInfos]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.contentInfos || \"\",\n        value: _ContentInfo.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"contentInfos\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AuthenticatedSafe.schema({\n      names: {\n        contentInfos: \"contentInfos\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AuthenticatedSafe\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.safeContents = Array.from(asn1.result.contentInfos, element => new _ContentInfo.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.safeContents, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      safeContents: Array.from(this.safeContents, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n  parseInternalValues(parameters) {\n    //region Check input data from \"parameters\" \n    if (parameters instanceof Object === false) return Promise.reject(\"The \\\"parameters\\\" must has \\\"Object\\\" type\");\n    if (\"safeContents\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"safeContents\\\"\");\n    if (parameters.safeContents instanceof Array === false) return Promise.reject(\"The \\\"parameters.safeContents\\\" must has \\\"Array\\\" type\");\n    if (parameters.safeContents.length !== this.safeContents.length) return Promise.reject(\"Length of \\\"parameters.safeContents\\\" must be equal to \\\"this.safeContents.length\\\"\"); //endregion \n    //region Initial variables \n\n    let sequence = Promise.resolve(); //endregion\n    //region Create value for \"this.parsedValue.authenticatedSafe\" \n\n    this.parsedValue = {\n      safeContents: []\n    };\n\n    var _iterator = _createForOfIteratorHelper(this.safeContents.entries()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const _step$value = _slicedToArray(_step.value, 2),\n              index = _step$value[0],\n              content = _step$value[1];\n\n        switch (content.contentType) {\n          //region data \n          case \"1.2.840.113549.1.7.1\":\n            {\n              //region Check that we do have OCTETSTRING as \"content\"\n              if (content.content instanceof asn1js.OctetString === false) return Promise.reject(\"Wrong type of \\\"this.safeContents[j].content\\\"\"); //endregion\n              //region Check we have \"constructive encoding\" for AuthSafe content\n\n              let authSafeContent = new ArrayBuffer(0);\n\n              if (content.content.valueBlock.isConstructed) {\n                var _iterator2 = _createForOfIteratorHelper(content.content.valueBlock.value),\n                    _step2;\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    const contentValue = _step2.value;\n                    authSafeContent = (0, _pvutils.utilConcatBuf)(authSafeContent, contentValue.valueBlock.valueHex);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n              } else authSafeContent = content.content.valueBlock.valueHex; //endregion\n              //region Parse internal ASN.1 data\n\n\n              const asn1 = asn1js.fromBER(authSafeContent);\n              if (asn1.offset === -1) return Promise.reject(\"Error during parsing of ASN.1 data inside \\\"content.content\\\"\"); //endregion\n              //region Finilly initialize initial values of \"SafeContents\" type\n\n              this.parsedValue.safeContents.push({\n                privacyMode: 0,\n                // No privacy, clear data\n                value: new _SafeContents.default({\n                  schema: asn1.result\n                })\n              }); //endregion\n            }\n            break;\n          //endregion \n          //region envelopedData \n\n          case \"1.2.840.113549.1.7.3\":\n            {\n              //region Initial variables\n              const cmsEnveloped = new _EnvelopedData.default({\n                schema: content.content\n              }); //endregion\n              //region Check mandatory parameters\n\n              if (\"recipientCertificate\" in parameters.safeContents[index] === false) return Promise.reject(\"Absent mandatory parameter \\\"recipientCertificate\\\" in \\\"parameters.safeContents[j]\\\"\");\n              const recipientCertificate = parameters.safeContents[index].recipientCertificate;\n              if (\"recipientKey\" in parameters.safeContents[index] === false) return Promise.reject(\"Absent mandatory parameter \\\"recipientKey\\\" in \\\"parameters.safeContents[j]\\\"\"); // noinspection JSUnresolvedVariable\n\n              const recipientKey = parameters.safeContents[index].recipientKey; //endregion\n              //region Decrypt CMS EnvelopedData using first recipient information\n\n              sequence = sequence.then(() => cmsEnveloped.decrypt(0, {\n                recipientCertificate,\n                recipientPrivateKey: recipientKey\n              }));\n              sequence = sequence.then(\n              /**\r\n               * @param {ArrayBuffer} result\r\n               */\n              result => {\n                const asn1 = asn1js.fromBER(result);\n                if (asn1.offset === -1) return Promise.reject(\"Error during parsing of decrypted data\");\n                this.parsedValue.safeContents.push({\n                  privacyMode: 2,\n                  // Public-key privacy mode\n                  value: new _SafeContents.default({\n                    schema: asn1.result\n                  })\n                });\n                return Promise.resolve();\n              }); //endregion\n            }\n            break;\n          //endregion   \n          //region encryptedData \n\n          case \"1.2.840.113549.1.7.6\":\n            {\n              //region Initial variables\n              const cmsEncrypted = new _EncryptedData.default({\n                schema: content.content\n              }); //endregion\n              //region Check mandatory parameters\n\n              if (\"password\" in parameters.safeContents[index] === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\" in \\\"parameters.safeContents[j]\\\"\");\n              const password = parameters.safeContents[index].password; //endregion\n              //region Decrypt CMS EncryptedData using password\n\n              sequence = sequence.then(() => cmsEncrypted.decrypt({\n                password\n              }), error => Promise.reject(error)); //endregion\n              //region Initialize internal data\n\n              sequence = sequence.then(\n              /**\r\n               * @param {ArrayBuffer} result\r\n               */\n              result => {\n                const asn1 = asn1js.fromBER(result);\n                if (asn1.offset === -1) return Promise.reject(\"Error during parsing of decrypted data\");\n                this.parsedValue.safeContents.push({\n                  privacyMode: 1,\n                  // Password-based privacy mode\n                  value: new _SafeContents.default({\n                    schema: asn1.result\n                  })\n                });\n                return Promise.resolve();\n              }, error => Promise.reject(error)); //endregion\n            }\n            break;\n          //endregion   \n          //region default \n\n          default:\n            throw new Error(`Unknown \"contentType\" for AuthenticatedSafe: \" ${content.contentType}`);\n          //endregion \n        }\n      } //endregion \n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return sequence;\n  } //**********************************************************************************\n\n\n  makeInternalValues(parameters) {\n    //region Check data in \"parsedValue\" \n    if (\"parsedValue\" in this === false) return Promise.reject(\"Please run \\\"parseValues\\\" first or add \\\"parsedValue\\\" manually\");\n    if (this.parsedValue instanceof Object === false) return Promise.reject(\"The \\\"this.parsedValue\\\" must has \\\"Object\\\" type\");\n    if (this.parsedValue.safeContents instanceof Array === false) return Promise.reject(\"The \\\"this.parsedValue.safeContents\\\" must has \\\"Array\\\" type\"); //endregion \n    //region Check input data from \"parameters\" \n\n    if (parameters instanceof Object === false) return Promise.reject(\"The \\\"parameters\\\" must has \\\"Object\\\" type\");\n    if (\"safeContents\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"safeContents\\\"\");\n    if (parameters.safeContents instanceof Array === false) return Promise.reject(\"The \\\"parameters.safeContents\\\" must has \\\"Array\\\" type\");\n    if (parameters.safeContents.length !== this.parsedValue.safeContents.length) return Promise.reject(\"Length of \\\"parameters.safeContents\\\" must be equal to \\\"this.parsedValue.safeContents\\\"\"); //endregion \n    //region Initial variables \n\n    let sequence = Promise.resolve(); //endregion\n    //region Create internal values from already parsed values \n\n    this.safeContents = [];\n\n    var _iterator3 = _createForOfIteratorHelper(this.parsedValue.safeContents.entries()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        const _step3$value = _slicedToArray(_step3.value, 2),\n              index = _step3$value[0],\n              content = _step3$value[1];\n\n        //region Check current \"content\" value\n        if (\"privacyMode\" in content === false) return Promise.reject(\"The \\\"privacyMode\\\" is a mandatory parameter for \\\"content\\\"\");\n        if (\"value\" in content === false) return Promise.reject(\"The \\\"value\\\" is a mandatory parameter for \\\"content\\\"\");\n        if (content.value instanceof _SafeContents.default === false) return Promise.reject(\"The \\\"content.value\\\" must has \\\"SafeContents\\\" type\"); //endregion \n\n        switch (content.privacyMode) {\n          //region No privacy \n          case 0:\n            {\n              const contentBuffer = content.value.toSchema().toBER(false);\n              sequence = sequence.then(() => {\n                this.safeContents.push(new _ContentInfo.default({\n                  contentType: \"1.2.840.113549.1.7.1\",\n                  content: new asn1js.OctetString({\n                    valueHex: contentBuffer\n                  })\n                }));\n              });\n            }\n            break;\n          //endregion \n          //region Privacy with password\n\n          case 1:\n            {\n              //region Initial variables\n              const cmsEncrypted = new _EncryptedData.default();\n              const currentParameters = parameters.safeContents[index];\n              currentParameters.contentToEncrypt = content.value.toSchema().toBER(false); //endregion\n              //region Encrypt CMS EncryptedData using password\n\n              sequence = sequence.then(() => cmsEncrypted.encrypt(currentParameters), error => Promise.reject(error)); //endregion\n              //region Store result content in CMS_CONTENT_INFO type\n\n              sequence = sequence.then(() => {\n                this.safeContents.push(new _ContentInfo.default({\n                  contentType: \"1.2.840.113549.1.7.6\",\n                  content: cmsEncrypted.toSchema()\n                }));\n              }, error => Promise.reject(error)); //endregion\n            }\n            break;\n          //endregion \n          //region Privacy with public key\n\n          case 2:\n            {\n              //region Initial variables\n              const cmsEnveloped = new _EnvelopedData.default();\n              const contentToEncrypt = content.value.toSchema().toBER(false); //endregion\n              //region Check mandatory parameters\n\n              if (\"encryptingCertificate\" in parameters.safeContents[index] === false) return Promise.reject(\"Absent mandatory parameter \\\"encryptingCertificate\\\" in \\\"parameters.safeContents[i]\\\"\");\n              if (\"encryptionAlgorithm\" in parameters.safeContents[index] === false) return Promise.reject(\"Absent mandatory parameter \\\"encryptionAlgorithm\\\" in \\\"parameters.safeContents[i]\\\"\");\n\n              switch (true) {\n                case parameters.safeContents[index].encryptionAlgorithm.name.toLowerCase() === \"aes-cbc\":\n                case parameters.safeContents[index].encryptionAlgorithm.name.toLowerCase() === \"aes-gcm\":\n                  break;\n\n                default:\n                  return Promise.reject(`Incorrect parameter \"encryptionAlgorithm\" in \"parameters.safeContents[i]\": ${parameters.safeContents[index].encryptionAlgorithm}`);\n              }\n\n              switch (true) {\n                case parameters.safeContents[index].encryptionAlgorithm.length === 128:\n                case parameters.safeContents[index].encryptionAlgorithm.length === 192:\n                case parameters.safeContents[index].encryptionAlgorithm.length === 256:\n                  break;\n\n                default:\n                  return Promise.reject(`Incorrect parameter \"encryptionAlgorithm.length\" in \"parameters.safeContents[i]\": ${parameters.safeContents[index].encryptionAlgorithm.length}`);\n              } //endregion\n              //region Making correct \"encryptionAlgorithm\" variable\n\n\n              const encryptionAlgorithm = parameters.safeContents[index].encryptionAlgorithm; //endregion\n              //region Append recipient for enveloped data\n\n              cmsEnveloped.addRecipientByCertificate(parameters.safeContents[index].encryptingCertificate); //endregion\n              //region Making encryption\n\n              sequence = sequence.then(() => cmsEnveloped.encrypt(encryptionAlgorithm, contentToEncrypt));\n              sequence = sequence.then(() => {\n                this.safeContents.push(new _ContentInfo.default({\n                  contentType: \"1.2.840.113549.1.7.3\",\n                  content: cmsEnveloped.toSchema()\n                }));\n              }); //endregion\n            }\n            break;\n          //endregion \n          //region default \n\n          default:\n            return Promise.reject(`Incorrect value for \"content.privacyMode\": ${content.privacyMode}`);\n          //endregion \n        }\n      } //endregion \n      //region Return result of the function \n\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return sequence.then(() => this, error => Promise.reject(`Error during parsing: ${error}`)); //endregion   \n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = AuthenticatedSafe;\n//# sourceMappingURL=AuthenticatedSafe.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/AuthenticatedSafe.js\n// module id = ./node_modules/pkijs/build/AuthenticatedSafe.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _GeneralName = _interopRequireDefault(require(\"./GeneralName.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass AuthorityKeyIdentifier {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for AuthorityKeyIdentifier class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    if (\"keyIdentifier\" in parameters)\n      /**\r\n       * @type {OctetString}\r\n       * @desc keyIdentifier\r\n       */\n      this.keyIdentifier = (0, _pvutils.getParametersValue)(parameters, \"keyIdentifier\", AuthorityKeyIdentifier.defaultValues(\"keyIdentifier\"));\n    if (\"authorityCertIssuer\" in parameters)\n      /**\r\n       * @type {Array.<GeneralName>}\r\n       * @desc authorityCertIssuer\r\n       */\n      this.authorityCertIssuer = (0, _pvutils.getParametersValue)(parameters, \"authorityCertIssuer\", AuthorityKeyIdentifier.defaultValues(\"authorityCertIssuer\"));\n    if (\"authorityCertSerialNumber\" in parameters)\n      /**\r\n       * @type {Integer}\r\n       * @desc authorityCertIssuer\r\n       */\n      this.authorityCertSerialNumber = (0, _pvutils.getParametersValue)(parameters, \"authorityCertSerialNumber\", AuthorityKeyIdentifier.defaultValues(\"authorityCertSerialNumber\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"keyIdentifier\":\n        return new asn1js.OctetString();\n\n      case \"authorityCertIssuer\":\n        return [];\n\n      case \"authorityCertSerialNumber\":\n        return new asn1js.Integer();\n\n      default:\n        throw new Error(`Invalid member name for AuthorityKeyIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AuthorityKeyIdentifier OID ::= 2.5.29.35\r\n   *\r\n   * AuthorityKeyIdentifier ::= SEQUENCE {\r\n   *    keyIdentifier             [0] KeyIdentifier           OPTIONAL,\r\n   *    authorityCertIssuer       [1] GeneralNames            OPTIONAL,\r\n   *    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }\r\n   *\r\n   * KeyIdentifier ::= OCTET STRING\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [keyIdentifier]\r\n     * @property {string} [authorityCertIssuer]\r\n     * @property {string} [authorityCertSerialNumber]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Primitive({\n        name: names.keyIdentifier || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        }\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [new asn1js.Repeated({\n          name: names.authorityCertIssuer || \"\",\n          value: _GeneralName.default.schema()\n        })]\n      }), new asn1js.Primitive({\n        name: names.authorityCertSerialNumber || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        }\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"keyIdentifier\", \"authorityCertIssuer\", \"authorityCertSerialNumber\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, AuthorityKeyIdentifier.schema({\n      names: {\n        keyIdentifier: \"keyIdentifier\",\n        authorityCertIssuer: \"authorityCertIssuer\",\n        authorityCertSerialNumber: \"authorityCertSerialNumber\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AuthorityKeyIdentifier\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"keyIdentifier\" in asn1.result) this.keyIdentifier = new asn1js.OctetString({\n      valueHex: asn1.result.keyIdentifier.valueBlock.valueHex\n    });\n    if (\"authorityCertIssuer\" in asn1.result) this.authorityCertIssuer = Array.from(asn1.result.authorityCertIssuer, element => new _GeneralName.default({\n      schema: element\n    }));\n    if (\"authorityCertSerialNumber\" in asn1.result) this.authorityCertSerialNumber = new asn1js.Integer({\n      valueHex: asn1.result.authorityCertSerialNumber.valueBlock.valueHex\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    if (\"keyIdentifier\" in this) {\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        valueHex: this.keyIdentifier.valueBlock.valueHex\n      }));\n    }\n\n    if (\"authorityCertIssuer\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: Array.from(this.authorityCertIssuer, element => element.toSchema())\n      }));\n    }\n\n    if (\"authorityCertSerialNumber\" in this) {\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        valueHex: this.authorityCertSerialNumber.valueBlock.valueHex\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {};\n    if (\"keyIdentifier\" in this) object.keyIdentifier = this.keyIdentifier.toJSON();\n    if (\"authorityCertIssuer\" in this) object.authorityCertIssuer = Array.from(this.authorityCertIssuer, element => element.toJSON());\n    if (\"authorityCertSerialNumber\" in this) object.authorityCertSerialNumber = this.authorityCertSerialNumber.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = AuthorityKeyIdentifier;\n//# sourceMappingURL=AuthorityKeyIdentifier.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/AuthorityKeyIdentifier.js\n// module id = ./node_modules/pkijs/build/AuthorityKeyIdentifier.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass BasicConstraints {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for BasicConstraints class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   * @property {Object} [cA]\r\n   * @property {Object} [pathLenConstraint]\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {boolean}\r\n     * @desc cA\r\n     */\n    this.cA = (0, _pvutils.getParametersValue)(parameters, \"cA\", false);\n    if (\"pathLenConstraint\" in parameters)\n      /**\r\n       * @type {number|Integer}\r\n       * @desc pathLenConstraint\r\n       */\n      this.pathLenConstraint = (0, _pvutils.getParametersValue)(parameters, \"pathLenConstraint\", 0); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"cA\":\n        return false;\n\n      default:\n        throw new Error(`Invalid member name for BasicConstraints class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * BasicConstraints ::= SEQUENCE {\r\n   *    cA                      BOOLEAN DEFAULT FALSE,\r\n   *    pathLenConstraint       INTEGER (0..MAX) OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [cA]\r\n     * @property {string} [pathLenConstraint]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Boolean({\n        optional: true,\n        name: names.cA || \"\"\n      }), new asn1js.Integer({\n        optional: true,\n        name: names.pathLenConstraint || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"cA\", \"pathLenConstraint\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, BasicConstraints.schema({\n      names: {\n        cA: \"cA\",\n        pathLenConstraint: \"pathLenConstraint\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for BasicConstraints\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"cA\" in asn1.result) this.cA = asn1.result.cA.valueBlock.value;\n\n    if (\"pathLenConstraint\" in asn1.result) {\n      if (asn1.result.pathLenConstraint.valueBlock.isHexOnly) this.pathLenConstraint = asn1.result.pathLenConstraint;else this.pathLenConstraint = asn1.result.pathLenConstraint.valueBlock.valueDec;\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    if (this.cA !== BasicConstraints.defaultValues(\"cA\")) outputArray.push(new asn1js.Boolean({\n      value: this.cA\n    }));\n\n    if (\"pathLenConstraint\" in this) {\n      if (this.pathLenConstraint instanceof asn1js.Integer) outputArray.push(this.pathLenConstraint);else outputArray.push(new asn1js.Integer({\n        value: this.pathLenConstraint\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {};\n    if (this.cA !== BasicConstraints.defaultValues(\"cA\")) object.cA = this.cA;\n\n    if (\"pathLenConstraint\" in this) {\n      if (this.pathLenConstraint instanceof asn1js.Integer) object.pathLenConstraint = this.pathLenConstraint.toJSON();else object.pathLenConstraint = this.pathLenConstraint;\n    }\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = BasicConstraints;\n//# sourceMappingURL=BasicConstraints.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/BasicConstraints.js\n// module id = ./node_modules/pkijs/build/BasicConstraints.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _ResponseData = _interopRequireDefault(require(\"./ResponseData.js\"));\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _Certificate = _interopRequireDefault(require(\"./Certificate.js\"));\n\nvar _CertID = _interopRequireDefault(require(\"./CertID.js\"));\n\nvar _RelativeDistinguishedNames = _interopRequireDefault(require(\"./RelativeDistinguishedNames.js\"));\n\nvar _CertificateChainValidationEngine = _interopRequireDefault(require(\"./CertificateChainValidationEngine.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC6960\r\n */\nclass BasicOCSPResponse {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for BasicOCSPResponse class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {ResponseData}\r\n     * @desc tbsResponseData\r\n     */\n    this.tbsResponseData = (0, _pvutils.getParametersValue)(parameters, \"tbsResponseData\", BasicOCSPResponse.defaultValues(\"tbsResponseData\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc signatureAlgorithm\r\n     */\n\n    this.signatureAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"signatureAlgorithm\", BasicOCSPResponse.defaultValues(\"signatureAlgorithm\"));\n    /**\r\n     * @type {BitString}\r\n     * @desc signature\r\n     */\n\n    this.signature = (0, _pvutils.getParametersValue)(parameters, \"signature\", BasicOCSPResponse.defaultValues(\"signature\"));\n    if (\"certs\" in parameters)\n      /**\r\n       * @type {Array.<Certificate>}\r\n       * @desc certs\r\n       */\n      this.certs = (0, _pvutils.getParametersValue)(parameters, \"certs\", BasicOCSPResponse.defaultValues(\"certs\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"tbsResponseData\":\n        return new _ResponseData.default();\n\n      case \"signatureAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"signature\":\n        return new asn1js.BitString();\n\n      case \"certs\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for BasicOCSPResponse class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"type\":\n        {\n          // noinspection OverlyComplexBooleanExpressionJS\n          let comparisonResult = _ResponseData.default.compareWithDefault(\"tbs\", memberValue.tbs) && _ResponseData.default.compareWithDefault(\"responderID\", memberValue.responderID) && _ResponseData.default.compareWithDefault(\"producedAt\", memberValue.producedAt) && _ResponseData.default.compareWithDefault(\"responses\", memberValue.responses);\n\n          if (\"responseExtensions\" in memberValue) comparisonResult = comparisonResult && _ResponseData.default.compareWithDefault(\"responseExtensions\", memberValue.responseExtensions);\n          return comparisonResult;\n        }\n\n      case \"signatureAlgorithm\":\n        return memberValue.algorithmId === \"\" && \"algorithmParams\" in memberValue === false;\n\n      case \"signature\":\n        return memberValue.isEqual(BasicOCSPResponse.defaultValues(memberName));\n\n      case \"certs\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for BasicOCSPResponse class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * BasicOCSPResponse       ::= SEQUENCE {\r\n   *    tbsResponseData      ResponseData,\r\n   *    signatureAlgorithm   AlgorithmIdentifier,\r\n   *    signature            BIT STRING,\r\n   *    certs            [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [tbsResponseData]\r\n     * @property {string} [signatureAlgorithm]\r\n     * @property {string} [signature]\r\n     * @property {string} [certs]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"BasicOCSPResponse\",\n      value: [_ResponseData.default.schema(names.tbsResponseData || {\n        names: {\n          blockName: \"BasicOCSPResponse.tbsResponseData\"\n        }\n      }), _AlgorithmIdentifier.default.schema(names.signatureAlgorithm || {\n        names: {\n          blockName: \"BasicOCSPResponse.signatureAlgorithm\"\n        }\n      }), new asn1js.BitString({\n        name: names.signature || \"BasicOCSPResponse.signature\"\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Sequence({\n          value: [new asn1js.Repeated({\n            name: \"BasicOCSPResponse.certs\",\n            value: _Certificate.default.schema(names.certs || {})\n          })]\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"BasicOCSPResponse.tbsResponseData\", \"BasicOCSPResponse.signatureAlgorithm\", \"BasicOCSPResponse.signature\", \"BasicOCSPResponse.certs\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, BasicOCSPResponse.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for BasicOCSPResponse\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.tbsResponseData = new _ResponseData.default({\n      schema: asn1.result[\"BasicOCSPResponse.tbsResponseData\"]\n    });\n    this.signatureAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result[\"BasicOCSPResponse.signatureAlgorithm\"]\n    });\n    this.signature = asn1.result[\"BasicOCSPResponse.signature\"];\n    if (\"BasicOCSPResponse.certs\" in asn1.result) this.certs = Array.from(asn1.result[\"BasicOCSPResponse.certs\"], element => new _Certificate.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(this.tbsResponseData.toSchema());\n    outputArray.push(this.signatureAlgorithm.toSchema());\n    outputArray.push(this.signature); //region Create array of certificates\n\n    if (\"certs\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Sequence({\n          value: Array.from(this.certs, element => element.toSchema())\n        })]\n      }));\n    } //endregion\n    //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      tbsResponseData: this.tbsResponseData.toJSON(),\n      signatureAlgorithm: this.signatureAlgorithm.toJSON(),\n      signature: this.signature.toJSON()\n    };\n    if (\"certs\" in this) _object.certs = Array.from(this.certs, element => element.toJSON());\n    return _object;\n  } //**********************************************************************************\n\n  /**\r\n   * Get OCSP response status for specific certificate\r\n   * @param {Certificate} certificate Certificate to be checked\r\n   * @param {Certificate} issuerCertificate Certificate of issuer for certificate to be checked\r\n   * @returns {Promise}\r\n   */\n\n\n  getCertificateStatus(certificate, issuerCertificate) {\n    //region Initial variables\n    let sequence = Promise.resolve();\n    const result = {\n      isForCertificate: false,\n      status: 2 // 0 = good, 1 = revoked, 2 = unknown\n\n    };\n    const hashesObject = {};\n    const certIDs = [];\n    const certIDPromises = []; //endregion\n    //region Create all \"certIDs\" for input certificates\n\n    var _iterator = _createForOfIteratorHelper(this.tbsResponseData.responses),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const response = _step.value;\n        const hashAlgorithm = (0, _common.getAlgorithmByOID)(response.certID.hashAlgorithm.algorithmId);\n        if (\"name\" in hashAlgorithm === false) return Promise.reject(`Wrong CertID hashing algorithm: ${response.certID.hashAlgorithm.algorithmId}`);\n\n        if (hashAlgorithm.name in hashesObject === false) {\n          hashesObject[hashAlgorithm.name] = 1;\n          const certID = new _CertID.default();\n          certIDs.push(certID);\n          certIDPromises.push(certID.createForCertificate(certificate, {\n            hashAlgorithm: hashAlgorithm.name,\n            issuerCertificate\n          }));\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    sequence = sequence.then(() => Promise.all(certIDPromises)); //endregion\n    //region Compare all response's \"certIDs\" with identifiers for input certificate\n\n    sequence = sequence.then(() => {\n      var _iterator2 = _createForOfIteratorHelper(this.tbsResponseData.responses),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          const response = _step2.value;\n\n          var _iterator3 = _createForOfIteratorHelper(certIDs),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              const id = _step3.value;\n\n              if (response.certID.isEqual(id)) {\n                result.isForCertificate = true;\n\n                try {\n                  switch (response.certStatus.idBlock.isConstructed) {\n                    case true:\n                      if (response.certStatus.idBlock.tagNumber === 1) result.status = 1; // revoked\n\n                      break;\n\n                    case false:\n                      switch (response.certStatus.idBlock.tagNumber) {\n                        case 0:\n                          // good\n                          result.status = 0;\n                          break;\n\n                        case 2:\n                          // unknown\n                          result.status = 2;\n                          break;\n\n                        default:\n                      }\n\n                      break;\n\n                    default:\n                  }\n                } catch (ex) {}\n\n                return result;\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return result;\n    }); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Make signature for current OCSP Basic Response\r\n   * @param {Object} privateKey Private key for \"subjectPublicKeyInfo\" structure\r\n   * @param {string} [hashAlgorithm=\"SHA-1\"] Hashing algorithm. Default SHA-1\r\n   * @returns {Promise}\r\n   */\n\n\n  sign(privateKey, hashAlgorithm = \"SHA-1\") {\n    //region Initial checking\n    //region Get a private key from function parameter\n    if (typeof privateKey === \"undefined\") return Promise.reject(\"Need to provide a private key for signing\"); //endregion\n    //endregion\n    //region Initial variables\n\n    let sequence = Promise.resolve();\n    let parameters;\n    const engine = (0, _common.getEngine)(); //endregion\n    //region Get a \"default parameters\" for current algorithm and set correct signature algorithm\n\n    sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));\n    sequence = sequence.then(result => {\n      parameters = result.parameters;\n      this.signatureAlgorithm = result.signatureAlgorithm;\n    }); //endregion\n    //region Create TBS data for signing\n\n    sequence = sequence.then(() => {\n      this.tbsResponseData.tbs = this.tbsResponseData.toSchema(true).toBER(false);\n    }); //endregion\n    //region Signing TBS data on provided private key\n\n    sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbsResponseData.tbs, privateKey, parameters));\n    sequence = sequence.then(result => {\n      this.signature = new asn1js.BitString({\n        valueHex: result\n      });\n    }); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Verify existing OCSP Basic Response\r\n   * @param {Object} parameters Additional parameters\r\n   * @returns {Promise}\r\n   */\n\n\n  verify(parameters = {}) {\n    //region Initial variables\n    let signerCert = null;\n    let certIndex = -1;\n    let sequence = Promise.resolve();\n    let trustedCerts = [];\n\n    const _this = this;\n\n    const engine = (0, _common.getEngine)(); //endregion\n    //region Check amount of certificates\n\n    if (\"certs\" in this === false) return Promise.reject(\"No certificates attached to the BasicOCSPResponce\"); //endregion\n    //region Get input values\n\n    if (\"trustedCerts\" in parameters) trustedCerts = parameters.trustedCerts; //endregion\n    //region Aux functions\n\n    /**\r\n     * Check CA flag for the certificate\r\n     * @param {Certificate} cert Certificate to find CA flag for\r\n     * @returns {*}\r\n     */\n\n    function checkCA(cert) {\n      //region Do not include signer's certificate\n      if (cert.issuer.isEqual(signerCert.issuer) === true && cert.serialNumber.isEqual(signerCert.serialNumber) === true) return null; //endregion\n\n      let isCA = false;\n\n      var _iterator4 = _createForOfIteratorHelper(cert.extensions),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          const extension = _step4.value;\n\n          if (extension.extnID === \"2.5.29.19\") // BasicConstraints\n            {\n              if (\"cA\" in extension.parsedValue) {\n                if (extension.parsedValue.cA === true) isCA = true;\n              }\n            }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (isCA) return cert;\n      return null;\n    } //endregion\n    //region Get a \"crypto\" extension\n\n\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Find correct value for \"responderID\"\n\n    switch (true) {\n      case this.tbsResponseData.responderID instanceof _RelativeDistinguishedNames.default:\n        // [1] Name\n        sequence = sequence.then(() => {\n          var _iterator5 = _createForOfIteratorHelper(_this.certs.entries()),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              const _step5$value = _slicedToArray(_step5.value, 2),\n                    index = _step5$value[0],\n                    certificate = _step5$value[1];\n\n              if (certificate.subject.isEqual(_this.tbsResponseData.responderID)) {\n                certIndex = index;\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        });\n        break;\n\n      case this.tbsResponseData.responderID instanceof asn1js.OctetString:\n        // [2] KeyHash\n        sequence = sequence.then(() => Promise.all(Array.from(_this.certs, element => crypto.digest({\n          name: \"sha-1\"\n        }, new Uint8Array(element.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(results => {\n          var _iterator6 = _createForOfIteratorHelper(_this.certs.entries()),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              const _step6$value = _slicedToArray(_step6.value, 1),\n                    index = _step6$value[0];\n\n              if ((0, _pvutils.isEqualBuffer)(results[index], _this.tbsResponseData.responderID.valueBlock.valueHex)) {\n                certIndex = index;\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }));\n        break;\n\n      default:\n        return Promise.reject(\"Wrong value for responderID\");\n    } //endregion\n    //region Make additional verification for signer's certificate\n\n\n    sequence = sequence.then(() => {\n      if (certIndex === -1) return Promise.reject(\"Correct certificate was not found in OCSP response\");\n      signerCert = this.certs[certIndex];\n      return Promise.all(Array.from(_this.certs, element => checkCA(element))).then(promiseResults => {\n        const additionalCerts = [];\n        additionalCerts.push(signerCert);\n\n        var _iterator7 = _createForOfIteratorHelper(promiseResults),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            const promiseResult = _step7.value;\n            if (promiseResult !== null) additionalCerts.push(promiseResult);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        const certChain = new _CertificateChainValidationEngine.default({\n          certs: additionalCerts,\n          trustedCerts\n        });\n        return certChain.verify().then(verificationResult => {\n          if (verificationResult.result === true) return Promise.resolve();\n          return Promise.reject(\"Validation of signer's certificate failed\");\n        }, error => Promise.reject(`Validation of signer's certificate failed with error: ${error instanceof Object ? error.resultMessage : error}`));\n      }, promiseError => Promise.reject(`Error during checking certificates for CA flag: ${promiseError}`));\n    }); //endregion\n\n    sequence = sequence.then(() => engine.subtle.verifyWithPublicKey(this.tbsResponseData.tbs, this.signature, this.certs[certIndex].subjectPublicKeyInfo, this.signatureAlgorithm));\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = BasicOCSPResponse;\n//# sourceMappingURL=BasicOCSPResponse.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/BasicOCSPResponse.js\n// module id = ./node_modules/pkijs/build/BasicOCSPResponse.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from https://docs.microsoft.com/en-us/windows/desktop/seccrypto/certification-authority-renewal\r\n */\nclass CAVersion {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for CAVersion class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc certificateIndex\r\n     */\n    this.certificateIndex = (0, _pvutils.getParametersValue)(parameters, \"certificateIndex\", CAVersion.defaultValues(\"certificateIndex\"));\n    /**\r\n     * @type {number}\r\n     * @desc keyIndex\r\n     */\n\n    this.keyIndex = (0, _pvutils.getParametersValue)(parameters, \"keyIndex\", CAVersion.defaultValues(\"keyIndex\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"certificateIndex\":\n      case \"keyIndex\":\n        return 0;\n\n      default:\n        throw new Error(`Invalid member name for CAVersion class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * CAVersion ::= INTEGER\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    return new asn1js.Integer();\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Check the schema is valid\n    if (schema.constructor.blockName() !== asn1js.Integer.blockName()) throw new Error(\"Object's schema was not verified against input data for CAVersion\"); //endregion\n    //region Check length of the input value and correct it if needed\n\n    let value = schema.valueBlock.valueHex.slice(0);\n    const valueView = new Uint8Array(value);\n\n    switch (true) {\n      case value.byteLength < 4:\n        {\n          const tempValue = new ArrayBuffer(4);\n          const tempValueView = new Uint8Array(tempValue);\n          tempValueView.set(valueView, 4 - value.byteLength);\n          value = tempValue.slice(0);\n        }\n        break;\n\n      case value.byteLength > 4:\n        {\n          const tempValue = new ArrayBuffer(4);\n          const tempValueView = new Uint8Array(tempValue);\n          tempValueView.set(valueView.slice(0, 4));\n          value = tempValue.slice(0);\n        }\n        break;\n\n      default:\n    } //endregion\n    //region Get internal properties from parsed schema\n\n\n    const keyIndexBuffer = value.slice(0, 2);\n    const keyIndexView8 = new Uint8Array(keyIndexBuffer);\n    let temp = keyIndexView8[0];\n    keyIndexView8[0] = keyIndexView8[1];\n    keyIndexView8[1] = temp;\n    const keyIndexView16 = new Uint16Array(keyIndexBuffer);\n    this.keyIndex = keyIndexView16[0];\n    const certificateIndexBuffer = value.slice(2);\n    const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);\n    temp = certificateIndexView8[0];\n    certificateIndexView8[0] = certificateIndexView8[1];\n    certificateIndexView8[1] = temp;\n    const certificateIndexView16 = new Uint16Array(certificateIndexBuffer);\n    this.certificateIndex = certificateIndexView16[0]; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create raw values\n    const certificateIndexBuffer = new ArrayBuffer(2);\n    const certificateIndexView = new Uint16Array(certificateIndexBuffer);\n    certificateIndexView[0] = this.certificateIndex;\n    const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);\n    let temp = certificateIndexView8[0];\n    certificateIndexView8[0] = certificateIndexView8[1];\n    certificateIndexView8[1] = temp;\n    const keyIndexBuffer = new ArrayBuffer(2);\n    const keyIndexView = new Uint16Array(keyIndexBuffer);\n    keyIndexView[0] = this.keyIndex;\n    const keyIndexView8 = new Uint8Array(keyIndexBuffer);\n    temp = keyIndexView8[0];\n    keyIndexView8[0] = keyIndexView8[1];\n    keyIndexView8[1] = temp; //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Integer({\n      valueHex: (0, _pvutils.utilConcatBuf)(keyIndexBuffer, certificateIndexBuffer)\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      certificateIndex: this.certificateIndex,\n      keyIndex: this.keyIndex\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CAVersion;\n//# sourceMappingURL=CAVersion.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CAVersion.js\n// module id = ./node_modules/pkijs/build/CAVersion.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _CertificateRevocationList = _interopRequireDefault(require(\"./CertificateRevocationList.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC7292\r\n */\nclass CRLBag {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for CRLBag class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc crlId\r\n     */\n    this.crlId = (0, _pvutils.getParametersValue)(parameters, \"crlId\", CRLBag.defaultValues(\"crlId\"));\n    /**\r\n     * @type {*}\r\n     * @desc crlValue\r\n     */\n\n    this.crlValue = (0, _pvutils.getParametersValue)(parameters, \"crlValue\", CRLBag.defaultValues(\"crlValue\"));\n    if (\"parsedValue\" in parameters)\n      /**\r\n       * @type {*}\r\n       * @desc parsedValue\r\n       */\n      this.parsedValue = (0, _pvutils.getParametersValue)(parameters, \"parsedValue\", CRLBag.defaultValues(\"parsedValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"crlId\":\n        return \"\";\n\n      case \"crlValue\":\n        return new asn1js.Any();\n\n      case \"parsedValue\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for CRLBag class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"crlId\":\n        return memberValue === \"\";\n\n      case \"crlValue\":\n        return memberValue instanceof asn1js.Any;\n\n      case \"parsedValue\":\n        return memberValue instanceof Object && Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for CRLBag class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * CRLBag ::= SEQUENCE {\r\n   *    crlId     \tBAG-TYPE.&id ({CRLTypes}),\r\n   *    crlValue \t[0] EXPLICIT BAG-TYPE.&Type ({CRLTypes}{@crlId})\r\n   *}\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [id]\r\n     * @property {string} [value]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.id || \"id\"\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Any({\n          name: names.value || \"value\"\n        })] // EXPLICIT ANY value\n\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"crlId\", \"crlValue\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, CRLBag.schema({\n      names: {\n        id: \"crlId\",\n        value: \"crlValue\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CRLBag\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.crlId = asn1.result.crlId.valueBlock.toString();\n    this.crlValue = asn1.result.crlValue;\n\n    switch (this.crlId) {\n      case \"1.2.840.113549.1.9.23.1\":\n        // x509CRL\n        {\n          const asn1Inner = asn1js.fromBER(this.certValue.valueBlock.valueHex);\n          this.parsedValue = new _CertificateRevocationList.default({\n            schema: asn1Inner.result\n          });\n        }\n        break;\n\n      default:\n        throw new Error(`Incorrect \"crlId\" value in CRLBag: ${this.crlId}`);\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    if (\"parsedValue\" in this) {\n      this.certId = \"1.2.840.113549.1.9.23.1\";\n      this.certValue = new asn1js.OctetString({\n        valueHex: this.parsedValue.toSchema().toBER(false)\n      });\n    }\n\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.crlId\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [this.crlValue.toSchema()]\n      })]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      crlId: this.crlId,\n      crlValue: this.crlValue.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CRLBag;\n//# sourceMappingURL=CRLBag.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CRLBag.js\n// module id = ./node_modules/pkijs/build/CRLBag.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _DistributionPoint = _interopRequireDefault(require(\"./DistributionPoint.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass CRLDistributionPoints {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for CRLDistributionPoints class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<DistributionPoint>}\r\n     * @desc distributionPoints\r\n     */\n    this.distributionPoints = (0, _pvutils.getParametersValue)(parameters, \"distributionPoints\", CRLDistributionPoints.defaultValues(\"distributionPoints\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"distributionPoints\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for CRLDistributionPoints class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * CRLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [distributionPoints]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.distributionPoints || \"\",\n        value: _DistributionPoint.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"distributionPoints\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, CRLDistributionPoints.schema({\n      names: {\n        distributionPoints: \"distributionPoints\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CRLDistributionPoints\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.distributionPoints = Array.from(asn1.result.distributionPoints, element => new _DistributionPoint.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.distributionPoints, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      distributionPoints: Array.from(this.distributionPoints, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CRLDistributionPoints;\n//# sourceMappingURL=CRLDistributionPoints.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CRLDistributionPoints.js\n// module id = ./node_modules/pkijs/build/CRLDistributionPoints.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _Certificate = _interopRequireDefault(require(\"./Certificate.js\"));\n\nvar _AttributeCertificateV = _interopRequireDefault(require(\"./AttributeCertificateV2.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC7292\r\n */\nclass CertBag {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for CertBag class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc certId\r\n     */\n    this.certId = (0, _pvutils.getParametersValue)(parameters, \"certId\", CertBag.defaultValues(\"certId\"));\n    /**\r\n     * @type {*}\r\n     * @desc certValue\r\n     */\n\n    this.certValue = (0, _pvutils.getParametersValue)(parameters, \"certValue\", CertBag.defaultValues(\"certValue\"));\n    if (\"parsedValue\" in parameters)\n      /**\r\n       * @type {*}\r\n       * @desc parsedValue\r\n       */\n      this.parsedValue = (0, _pvutils.getParametersValue)(parameters, \"parsedValue\", CertBag.defaultValues(\"parsedValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"certId\":\n        return \"\";\n\n      case \"certValue\":\n        return new asn1js.Any();\n\n      case \"parsedValue\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for CertBag class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"certId\":\n        return memberValue === \"\";\n\n      case \"certValue\":\n        return memberValue instanceof asn1js.Any;\n\n      case \"parsedValue\":\n        return memberValue instanceof Object && Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for CertBag class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * CertBag ::= SEQUENCE {\r\n   *    certId    BAG-TYPE.&id   ({CertTypes}),\r\n   *    certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [id]\r\n     * @property {string} [value]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.id || \"id\"\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Any({\n          name: names.value || \"value\"\n        })] // EXPLICIT ANY value\n\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"certId\", \"certValue\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, CertBag.schema({\n      names: {\n        id: \"certId\",\n        value: \"certValue\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CertBag\"); //endregion \n    //region Get internal properties from parsed schema \n\n    this.certId = asn1.result.certId.valueBlock.toString();\n    this.certValue = asn1.result.certValue;\n\n    switch (this.certId) {\n      case \"1.2.840.113549.1.9.22.1\":\n        // x509Certificate\n        {\n          const asn1Inner = asn1js.fromBER(this.certValue.valueBlock.valueHex);\n\n          try {\n            this.parsedValue = new _Certificate.default({\n              schema: asn1Inner.result\n            });\n          } catch (ex) // In some realizations the same OID used for attribute certificates\n          {\n            this.parsedValue = new _AttributeCertificateV.default({\n              schema: asn1Inner.result\n            });\n          }\n        }\n        break;\n\n      case \"1.2.840.113549.1.9.22.3\":\n        // attributeCertificate - (!!!) THIS OID IS SUBJECT FOR CHANGE IN FUTURE (!!!)\n        {\n          const asn1Inner = asn1js.fromBER(this.certValue.valueBlock.valueHex);\n          this.parsedValue = new _AttributeCertificateV.default({\n            schema: asn1Inner.result\n          });\n        }\n        break;\n\n      case \"1.2.840.113549.1.9.22.2\": // sdsiCertificate\n\n      default:\n        throw new Error(`Incorrect \"certId\" value in CertBag: ${this.certId}`);\n    } //endregion \n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    if (\"parsedValue\" in this) {\n      if (\"acinfo\" in this.parsedValue) // attributeCertificate\n        this.certId = \"1.2.840.113549.1.9.22.3\";else // x509Certificate\n        this.certId = \"1.2.840.113549.1.9.22.1\";\n      this.certValue = new asn1js.OctetString({\n        valueHex: this.parsedValue.toSchema().toBER(false)\n      });\n    }\n\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.certId\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [\"toSchema\" in this.certValue ? this.certValue.toSchema() : this.certValue]\n      })]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      certId: this.certId,\n      certValue: this.certValue.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CertBag;\n//# sourceMappingURL=CertBag.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CertBag.js\n// module id = ./node_modules/pkijs/build/CertBag.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC6960\r\n */\nclass CertID {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for CertID class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc hashAlgorithm\r\n     */\n    this.hashAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"hashAlgorithm\", CertID.defaultValues(\"hashAlgorithm\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc issuerNameHash\r\n     */\n\n    this.issuerNameHash = (0, _pvutils.getParametersValue)(parameters, \"issuerNameHash\", CertID.defaultValues(\"issuerNameHash\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc issuerKeyHash\r\n     */\n\n    this.issuerKeyHash = (0, _pvutils.getParametersValue)(parameters, \"issuerKeyHash\", CertID.defaultValues(\"issuerKeyHash\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc serialNumber\r\n     */\n\n    this.serialNumber = (0, _pvutils.getParametersValue)(parameters, \"serialNumber\", CertID.defaultValues(\"serialNumber\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"hashAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"issuerNameHash\":\n      case \"issuerKeyHash\":\n        return new asn1js.OctetString();\n\n      case \"serialNumber\":\n        return new asn1js.Integer();\n\n      default:\n        throw new Error(`Invalid member name for CertID class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"hashAlgorithm\":\n        return memberValue.algorithmId === \"\" && \"algorithmParams\" in memberValue === false;\n\n      case \"issuerNameHash\":\n      case \"issuerKeyHash\":\n      case \"serialNumber\":\n        return memberValue.isEqual(CertID.defaultValues(memberName));\n\n      default:\n        throw new Error(`Invalid member name for CertID class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * CertID          ::=     SEQUENCE {\r\n   *    hashAlgorithm       AlgorithmIdentifier,\r\n   *    issuerNameHash      OCTET STRING, -- Hash of issuer's DN\r\n   *    issuerKeyHash       OCTET STRING, -- Hash of issuer's public key\r\n   *    serialNumber        CertificateSerialNumber }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [hashAlgorithm]\r\n     * @property {string} [hashAlgorithmObject]\r\n     * @property {string} [issuerNameHash]\r\n     * @property {string} [issuerKeyHash]\r\n     * @property {string} [serialNumber]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_AlgorithmIdentifier.default.schema(names.hashAlgorithmObject || {\n        names: {\n          blockName: names.hashAlgorithm || \"\"\n        }\n      }), new asn1js.OctetString({\n        name: names.issuerNameHash || \"\"\n      }), new asn1js.OctetString({\n        name: names.issuerKeyHash || \"\"\n      }), new asn1js.Integer({\n        name: names.serialNumber || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"hashAlgorithm\", \"issuerNameHash\", \"issuerKeyHash\", \"serialNumber\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, CertID.schema({\n      names: {\n        hashAlgorithm: \"hashAlgorithm\",\n        issuerNameHash: \"issuerNameHash\",\n        issuerKeyHash: \"issuerKeyHash\",\n        serialNumber: \"serialNumber\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CertID\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.hashAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.hashAlgorithm\n    });\n    this.issuerNameHash = asn1.result.issuerNameHash;\n    this.issuerKeyHash = asn1.result.issuerKeyHash;\n    this.serialNumber = asn1.result.serialNumber; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.hashAlgorithm.toSchema(), this.issuerNameHash, this.issuerKeyHash, this.serialNumber]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      hashAlgorithm: this.hashAlgorithm.toJSON(),\n      issuerNameHash: this.issuerNameHash.toJSON(),\n      issuerKeyHash: this.issuerKeyHash.toJSON(),\n      serialNumber: this.serialNumber.toJSON()\n    };\n  } //**********************************************************************************\n\n  /**\r\n   * Check that two \"CertIDs\" are equal\r\n   * @param {CertID} certificateID Identifier of the certificate to be checked\r\n   * @returns {boolean}\r\n   */\n\n\n  isEqual(certificateID) {\n    //region Check \"hashAlgorithm\"\n    if (!this.hashAlgorithm.algorithmId === certificateID.hashAlgorithm.algorithmId) return false; //endregion\n    //region Check \"issuerNameHash\"\n\n    if ((0, _pvutils.isEqualBuffer)(this.issuerNameHash.valueBlock.valueHex, certificateID.issuerNameHash.valueBlock.valueHex) === false) return false; //endregion\n    //region Check \"issuerKeyHash\"\n\n    if ((0, _pvutils.isEqualBuffer)(this.issuerKeyHash.valueBlock.valueHex, certificateID.issuerKeyHash.valueBlock.valueHex) === false) return false; //endregion\n    //region Check \"serialNumber\"\n\n    if (!this.serialNumber.isEqual(certificateID.serialNumber)) return false; //endregion\n\n    return true;\n  } //**********************************************************************************\n\n  /**\r\n   * Making OCSP certificate identifier for specific certificate\r\n   * @param {Certificate} certificate Certificate making OCSP Request for\r\n   * @param {Object} parameters Additional parameters\r\n   * @returns {Promise}\r\n   */\n\n\n  createForCertificate(certificate, parameters) {\n    //region Initial variables\n    let sequence = Promise.resolve();\n    let issuerCertificate; //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Check input parameters\n\n    if (\"hashAlgorithm\" in parameters === false) return Promise.reject(\"Parameter \\\"hashAlgorithm\\\" is mandatory for \\\"OCSP_REQUEST.createForCertificate\\\"\");\n    const hashOID = (0, _common.getOIDByAlgorithm)({\n      name: parameters.hashAlgorithm\n    });\n    if (hashOID === \"\") return Promise.reject(`Incorrect \"hashAlgorithm\": ${this.hashAlgorithm}`);\n    this.hashAlgorithm = new _AlgorithmIdentifier.default({\n      algorithmId: hashOID,\n      algorithmParams: new asn1js.Null()\n    });\n    if (\"issuerCertificate\" in parameters) issuerCertificate = parameters.issuerCertificate;else return Promise.reject(\"Parameter \\\"issuerCertificate\\\" is mandatory for \\\"OCSP_REQUEST.createForCertificate\\\"\"); //endregion\n    //region Initialize \"serialNumber\" field\n\n    this.serialNumber = certificate.serialNumber; //endregion\n    //region Create \"issuerNameHash\"\n\n    sequence = sequence.then(() => crypto.digest({\n      name: parameters.hashAlgorithm\n    }, issuerCertificate.subject.toSchema().toBER(false)), error => Promise.reject(error)); //endregion\n    //region Create \"issuerKeyHash\"\n\n    sequence = sequence.then(result => {\n      this.issuerNameHash = new asn1js.OctetString({\n        valueHex: result\n      });\n      const issuerKeyBuffer = issuerCertificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex;\n      return crypto.digest({\n        name: parameters.hashAlgorithm\n      }, issuerKeyBuffer);\n    }, error => Promise.reject(error)).then(result => {\n      this.issuerKeyHash = new asn1js.OctetString({\n        valueHex: result\n      });\n    }, error => Promise.reject(error)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CertID;\n//# sourceMappingURL=CertID.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CertID.js\n// module id = ./node_modules/pkijs/build/CertID.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _RelativeDistinguishedNames = _interopRequireDefault(require(\"./RelativeDistinguishedNames.js\"));\n\nvar _Time = _interopRequireDefault(require(\"./Time.js\"));\n\nvar _PublicKeyInfo = _interopRequireDefault(require(\"./PublicKeyInfo.js\"));\n\nvar _Extension = _interopRequireDefault(require(\"./Extension.js\"));\n\nvar _Extensions = _interopRequireDefault(require(\"./Extensions.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\nfunction tbsCertificate(parameters = {}) {\n  //TBSCertificate  ::=  SEQUENCE  {\n  //    version         [0]  EXPLICIT Version DEFAULT v1,\n  //    serialNumber         CertificateSerialNumber,\n  //    signature            AlgorithmIdentifier,\n  //    issuer               Name,\n  //    validity             Validity,\n  //    subject              Name,\n  //    subjectPublicKeyInfo SubjectPublicKeyInfo,\n  //    issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n  //                         -- If present, version MUST be v2 or v3\n  //    subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n  //                         -- If present, version MUST be v2 or v3\n  //    extensions      [3]  EXPLICIT Extensions OPTIONAL\n  //    -- If present, version MUST be v3\n  //}\n\n  /**\r\n   * @type {Object}\r\n   * @property {string} [blockName]\r\n   * @property {string} [tbsCertificateVersion]\r\n   * @property {string} [tbsCertificateSerialNumber]\r\n   * @property {string} [signature]\r\n   * @property {string} [issuer]\r\n   * @property {string} [tbsCertificateValidity]\r\n   * @property {string} [notBefore]\r\n   * @property {string} [notAfter]\r\n   * @property {string} [subject]\r\n   * @property {string} [subjectPublicKeyInfo]\r\n   * @property {string} [tbsCertificateIssuerUniqueID]\r\n   * @property {string} [tbsCertificateSubjectUniqueID]\r\n   * @property {string} [extensions]\r\n   */\n  const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n  return new asn1js.Sequence({\n    name: names.blockName || \"tbsCertificate\",\n    value: [new asn1js.Constructed({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 0 // [0]\n\n      },\n      value: [new asn1js.Integer({\n        name: names.tbsCertificateVersion || \"tbsCertificate.version\"\n      }) // EXPLICIT integer value\n      ]\n    }), new asn1js.Integer({\n      name: names.tbsCertificateSerialNumber || \"tbsCertificate.serialNumber\"\n    }), _AlgorithmIdentifier.default.schema(names.signature || {\n      names: {\n        blockName: \"tbsCertificate.signature\"\n      }\n    }), _RelativeDistinguishedNames.default.schema(names.issuer || {\n      names: {\n        blockName: \"tbsCertificate.issuer\"\n      }\n    }), new asn1js.Sequence({\n      name: names.tbsCertificateValidity || \"tbsCertificate.validity\",\n      value: [_Time.default.schema(names.notBefore || {\n        names: {\n          utcTimeName: \"tbsCertificate.notBefore\",\n          generalTimeName: \"tbsCertificate.notBefore\"\n        }\n      }), _Time.default.schema(names.notAfter || {\n        names: {\n          utcTimeName: \"tbsCertificate.notAfter\",\n          generalTimeName: \"tbsCertificate.notAfter\"\n        }\n      })]\n    }), _RelativeDistinguishedNames.default.schema(names.subject || {\n      names: {\n        blockName: \"tbsCertificate.subject\"\n      }\n    }), _PublicKeyInfo.default.schema(names.subjectPublicKeyInfo || {\n      names: {\n        blockName: \"tbsCertificate.subjectPublicKeyInfo\"\n      }\n    }), new asn1js.Primitive({\n      name: names.tbsCertificateIssuerUniqueID || \"tbsCertificate.issuerUniqueID\",\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 1 // [1]\n\n      }\n    }), // IMPLICIT bistring value\n    new asn1js.Primitive({\n      name: names.tbsCertificateSubjectUniqueID || \"tbsCertificate.subjectUniqueID\",\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 2 // [2]\n\n      }\n    }), // IMPLICIT bistring value\n    new asn1js.Constructed({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 3 // [3]\n\n      },\n      value: [_Extensions.default.schema(names.extensions || {\n        names: {\n          blockName: \"tbsCertificate.extensions\"\n        }\n      })]\n    }) // EXPLICIT SEQUENCE value\n    ]\n  });\n} //**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\n\n\nclass Certificate {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for Certificate class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc ToBeSigned (TBS) part of the certificate\r\n     */\n    this.tbs = (0, _pvutils.getParametersValue)(parameters, \"tbs\", Certificate.defaultValues(\"tbs\"));\n    /**\r\n     * @type {number}\r\n     * @desc Version number\r\n     */\n\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", Certificate.defaultValues(\"version\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc Serial number of the certificate\r\n     */\n\n    this.serialNumber = (0, _pvutils.getParametersValue)(parameters, \"serialNumber\", Certificate.defaultValues(\"serialNumber\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc This field contains the algorithm identifier for the algorithm used by the CA to sign the certificate\r\n     */\n\n    this.signature = (0, _pvutils.getParametersValue)(parameters, \"signature\", Certificate.defaultValues(\"signature\"));\n    /**\r\n     * @type {RelativeDistinguishedNames}\r\n     * @desc The issuer field identifies the entity that has signed and issued the certificate\r\n     */\n\n    this.issuer = (0, _pvutils.getParametersValue)(parameters, \"issuer\", Certificate.defaultValues(\"issuer\"));\n    /**\r\n     * @type {Time}\r\n     * @desc The date on which the certificate validity period begins\r\n     */\n\n    this.notBefore = (0, _pvutils.getParametersValue)(parameters, \"notBefore\", Certificate.defaultValues(\"notBefore\"));\n    /**\r\n     * @type {Time}\r\n     * @desc The date on which the certificate validity period ends\r\n     */\n\n    this.notAfter = (0, _pvutils.getParametersValue)(parameters, \"notAfter\", Certificate.defaultValues(\"notAfter\"));\n    /**\r\n     * @type {RelativeDistinguishedNames}\r\n     * @desc The subject field identifies the entity associated with the public key stored in the subject public key field\r\n     */\n\n    this.subject = (0, _pvutils.getParametersValue)(parameters, \"subject\", Certificate.defaultValues(\"subject\"));\n    /**\r\n     * @type {PublicKeyInfo}\r\n     * @desc This field is used to carry the public key and identify the algorithm with which the key is used\r\n     */\n\n    this.subjectPublicKeyInfo = (0, _pvutils.getParametersValue)(parameters, \"subjectPublicKeyInfo\", Certificate.defaultValues(\"subjectPublicKeyInfo\"));\n    if (\"issuerUniqueID\" in parameters)\n      /**\r\n       * @type {ArrayBuffer}\r\n       * @desc The subject and issuer unique identifiers are present in the certificate to handle the possibility of reuse of subject and/or issuer names over time\r\n       */\n      this.issuerUniqueID = (0, _pvutils.getParametersValue)(parameters, \"issuerUniqueID\", Certificate.defaultValues(\"issuerUniqueID\"));\n    if (\"subjectUniqueID\" in parameters)\n      /**\r\n       * @type {ArrayBuffer}\r\n       * @desc The subject and issuer unique identifiers are present in the certificate to handle the possibility of reuse of subject and/or issuer names over time\r\n       */\n      this.subjectUniqueID = (0, _pvutils.getParametersValue)(parameters, \"subjectUniqueID\", Certificate.defaultValues(\"subjectUniqueID\"));\n    if (\"extensions\" in parameters)\n      /**\r\n       * @type {Array}\r\n       * @desc If present, this field is a SEQUENCE of one or more certificate extensions\r\n       */\n      this.extensions = (0, _pvutils.getParametersValue)(parameters, \"extensions\", Certificate.defaultValues(\"extensions\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc The signatureAlgorithm field contains the identifier for the cryptographic algorithm used by the CA to sign this certificate\r\n     */\n\n    this.signatureAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"signatureAlgorithm\", Certificate.defaultValues(\"signatureAlgorithm\"));\n    /**\r\n     * @type {BitString}\r\n     * @desc The signatureValue field contains a digital signature computed upon the ASN.1 DER encoded tbsCertificate\r\n     */\n\n    this.signatureValue = (0, _pvutils.getParametersValue)(parameters, \"signatureValue\", Certificate.defaultValues(\"signatureValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"tbs\":\n        return new ArrayBuffer(0);\n\n      case \"version\":\n        return 0;\n\n      case \"serialNumber\":\n        return new asn1js.Integer();\n\n      case \"signature\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"issuer\":\n        return new _RelativeDistinguishedNames.default();\n\n      case \"notBefore\":\n        return new _Time.default();\n\n      case \"notAfter\":\n        return new _Time.default();\n\n      case \"subject\":\n        return new _RelativeDistinguishedNames.default();\n\n      case \"subjectPublicKeyInfo\":\n        return new _PublicKeyInfo.default();\n\n      case \"issuerUniqueID\":\n        return new ArrayBuffer(0);\n\n      case \"subjectUniqueID\":\n        return new ArrayBuffer(0);\n\n      case \"extensions\":\n        return [];\n\n      case \"signatureAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"signatureValue\":\n        return new asn1js.BitString();\n\n      default:\n        throw new Error(`Invalid member name for Certificate class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * Certificate  ::=  SEQUENCE  {\r\n   *    tbsCertificate       TBSCertificate,\r\n   *    signatureAlgorithm   AlgorithmIdentifier,\r\n   *    signatureValue       BIT STRING  }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [tbsCertificate]\r\n     * @property {string} [signatureAlgorithm]\r\n     * @property {string} [signatureValue]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [tbsCertificate(names.tbsCertificate), _AlgorithmIdentifier.default.schema(names.signatureAlgorithm || {\n        names: {\n          blockName: \"signatureAlgorithm\"\n        }\n      }), new asn1js.BitString({\n        name: names.signatureValue || \"signatureValue\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"tbsCertificate\", \"tbsCertificate.extensions\", \"tbsCertificate.version\", \"tbsCertificate.serialNumber\", \"tbsCertificate.signature\", \"tbsCertificate.issuer\", \"tbsCertificate.notBefore\", \"tbsCertificate.notAfter\", \"tbsCertificate.subject\", \"tbsCertificate.subjectPublicKeyInfo\", \"tbsCertificate.issuerUniqueID\", \"tbsCertificate.subjectUniqueID\", \"signatureAlgorithm\", \"signatureValue\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, Certificate.schema({\n      names: {\n        tbsCertificate: {\n          names: {\n            extensions: {\n              names: {\n                extensions: \"tbsCertificate.extensions\"\n              }\n            }\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for Certificate\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.tbs = asn1.result.tbsCertificate.valueBeforeDecode;\n    if (\"tbsCertificate.version\" in asn1.result) this.version = asn1.result[\"tbsCertificate.version\"].valueBlock.valueDec;\n    this.serialNumber = asn1.result[\"tbsCertificate.serialNumber\"];\n    this.signature = new _AlgorithmIdentifier.default({\n      schema: asn1.result[\"tbsCertificate.signature\"]\n    });\n    this.issuer = new _RelativeDistinguishedNames.default({\n      schema: asn1.result[\"tbsCertificate.issuer\"]\n    });\n    this.notBefore = new _Time.default({\n      schema: asn1.result[\"tbsCertificate.notBefore\"]\n    });\n    this.notAfter = new _Time.default({\n      schema: asn1.result[\"tbsCertificate.notAfter\"]\n    });\n    this.subject = new _RelativeDistinguishedNames.default({\n      schema: asn1.result[\"tbsCertificate.subject\"]\n    });\n    this.subjectPublicKeyInfo = new _PublicKeyInfo.default({\n      schema: asn1.result[\"tbsCertificate.subjectPublicKeyInfo\"]\n    });\n    if (\"tbsCertificate.issuerUniqueID\" in asn1.result) this.issuerUniqueID = asn1.result[\"tbsCertificate.issuerUniqueID\"].valueBlock.valueHex;\n    if (\"tbsCertificate.subjectUniqueID\" in asn1.result) this.subjectUniqueID = asn1.result[\"tbsCertificate.subjectUniqueID\"].valueBlock.valueHex;\n    if (\"tbsCertificate.extensions\" in asn1.result) this.extensions = Array.from(asn1.result[\"tbsCertificate.extensions\"], element => new _Extension.default({\n      schema: element\n    }));\n    this.signatureAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.signatureAlgorithm\n    });\n    this.signatureValue = asn1.result.signatureValue; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Create ASN.1 schema for existing values of TBS part for the certificate\r\n   */\n\n\n  encodeTBS() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    if (\"version\" in this && this.version !== Certificate.defaultValues(\"version\")) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Integer({\n          value: this.version\n        }) // EXPLICIT integer value\n        ]\n      }));\n    }\n\n    outputArray.push(this.serialNumber);\n    outputArray.push(this.signature.toSchema());\n    outputArray.push(this.issuer.toSchema());\n    outputArray.push(new asn1js.Sequence({\n      value: [this.notBefore.toSchema(), this.notAfter.toSchema()]\n    }));\n    outputArray.push(this.subject.toSchema());\n    outputArray.push(this.subjectPublicKeyInfo.toSchema());\n\n    if (\"issuerUniqueID\" in this) {\n      outputArray.push(new asn1js.Primitive({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        valueHex: this.issuerUniqueID\n      }));\n    }\n\n    if (\"subjectUniqueID\" in this) {\n      outputArray.push(new asn1js.Primitive({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        valueHex: this.subjectUniqueID\n      }));\n    }\n\n    if (\"extensions\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 3 // [3]\n\n        },\n        value: [new asn1js.Sequence({\n          value: Array.from(this.extensions, element => element.toSchema())\n        })]\n      }));\n    } //endregion\n    //region Create and return output sequence\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema(encodeFlag = false) {\n    let tbsSchema = {}; //region Decode stored TBS value\n\n    if (encodeFlag === false) {\n      if (this.tbs.length === 0) // No stored certificate TBS part\n        return Certificate.schema().value[0];\n      tbsSchema = asn1js.fromBER(this.tbs).result;\n    } //endregion\n    //region Create TBS schema via assembling from TBS parts\n    else tbsSchema = this.encodeTBS(); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: [tbsSchema, this.signatureAlgorithm.toSchema(), this.signatureValue]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      tbs: (0, _pvutils.bufferToHexCodes)(this.tbs, 0, this.tbs.byteLength),\n      serialNumber: this.serialNumber.toJSON(),\n      signature: this.signature.toJSON(),\n      issuer: this.issuer.toJSON(),\n      notBefore: this.notBefore.toJSON(),\n      notAfter: this.notAfter.toJSON(),\n      subject: this.subject.toJSON(),\n      subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),\n      signatureAlgorithm: this.signatureAlgorithm.toJSON(),\n      signatureValue: this.signatureValue.toJSON()\n    };\n    if (\"version\" in this && this.version !== Certificate.defaultValues(\"version\")) object.version = this.version;\n    if (\"issuerUniqueID\" in this) object.issuerUniqueID = (0, _pvutils.bufferToHexCodes)(this.issuerUniqueID, 0, this.issuerUniqueID.byteLength);\n    if (\"subjectUniqueID\" in this) object.subjectUniqueID = (0, _pvutils.bufferToHexCodes)(this.subjectUniqueID, 0, this.subjectUniqueID.byteLength);\n    if (\"extensions\" in this) object.extensions = Array.from(this.extensions, element => element.toJSON());\n    return object;\n  } //**********************************************************************************\n\n  /**\r\n   * Importing public key for current certificate\r\n   */\n\n\n  getPublicKey(parameters = null) {\n    return (0, _common.getEngine)().subtle.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);\n  } //**********************************************************************************\n\n  /**\r\n   * Get hash value for subject public key (default SHA-1)\r\n   * @param {String} [hashAlgorithm=SHA-1] Hashing algorithm name\r\n   */\n\n\n  getKeyHash(hashAlgorithm = \"SHA-1\") {\n    //region Get a \"crypto\" extension\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n\n    return crypto.digest({\n      name: hashAlgorithm\n    }, new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex));\n  } //**********************************************************************************\n\n  /**\r\n   * Make a signature for current value from TBS section\r\n   * @param {Object} privateKey Private key for \"subjectPublicKeyInfo\" structure\r\n   * @param {string} [hashAlgorithm=\"SHA-1\"] Hashing algorithm\r\n   */\n\n\n  sign(privateKey, hashAlgorithm = \"SHA-1\") {\n    //region Initial checking\n    //region Check private key\n    if (typeof privateKey === \"undefined\") return Promise.reject(\"Need to provide a private key for signing\"); //endregion\n    //endregion\n    //region Initial variables\n\n    let sequence = Promise.resolve();\n    let parameters;\n    const engine = (0, _common.getEngine)(); //endregion\n    //region Get a \"default parameters\" for current algorithm and set correct signature algorithm\n\n    sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));\n    sequence = sequence.then(result => {\n      parameters = result.parameters;\n      this.signature = result.signatureAlgorithm;\n      this.signatureAlgorithm = result.signatureAlgorithm;\n    }); //endregion\n    //region Create TBS data for signing\n\n    sequence = sequence.then(() => {\n      this.tbs = this.encodeTBS().toBER(false);\n    }); //endregion\n    //region Signing TBS data on provided private key\n\n    sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));\n    sequence = sequence.then(result => {\n      this.signatureValue = new asn1js.BitString({\n        valueHex: result\n      });\n    }); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n\n  verify(issuerCertificate = null) {\n    //region Global variables\n    let subjectPublicKeyInfo = {}; //endregion\n    //region Set correct \"subjectPublicKeyInfo\" value\n\n    if (issuerCertificate !== null) subjectPublicKeyInfo = issuerCertificate.subjectPublicKeyInfo;else {\n      if (this.issuer.isEqual(this.subject)) // Self-signed certificate\n        subjectPublicKeyInfo = this.subjectPublicKeyInfo;\n    }\n    if (subjectPublicKeyInfo instanceof _PublicKeyInfo.default === false) return Promise.reject(\"Please provide issuer certificate as a parameter\"); //endregion\n\n    return (0, _common.getEngine)().subtle.verifyWithPublicKey(this.tbs, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = Certificate;\n//# sourceMappingURL=Certificate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/Certificate.js\n// module id = ./node_modules/pkijs/build/Certificate.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\nclass CertificateChainValidationEngine {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for CertificateChainValidationEngine class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<Certificate>}\r\n     * @desc Array of pre-defined trusted (by user) certificates\r\n     */\n    this.trustedCerts = (0, _pvutils.getParametersValue)(parameters, \"trustedCerts\", this.defaultValues(\"trustedCerts\"));\n    /**\r\n     * @type {Array.<Certificate>}\r\n     * @desc Array with certificate chain. Could be only one end-user certificate in there!\r\n     */\n\n    this.certs = (0, _pvutils.getParametersValue)(parameters, \"certs\", this.defaultValues(\"certs\"));\n    /**\r\n     * @type {Array.<CertificateRevocationList>}\r\n     * @desc Array of all CRLs for all certificates from certificate chain\r\n     */\n\n    this.crls = (0, _pvutils.getParametersValue)(parameters, \"crls\", this.defaultValues(\"crls\"));\n    /**\r\n     * @type {Array}\r\n     * @desc Array of all OCSP responses\r\n     */\n\n    this.ocsps = (0, _pvutils.getParametersValue)(parameters, \"ocsps\", this.defaultValues(\"ocsps\"));\n    /**\r\n     * @type {Date}\r\n     * @desc The date at which the check would be\r\n     */\n\n    this.checkDate = (0, _pvutils.getParametersValue)(parameters, \"checkDate\", this.defaultValues(\"checkDate\"));\n    /**\r\n     * @type {Function}\r\n     * @desc The date at which the check would be\r\n     */\n\n    this.findOrigin = (0, _pvutils.getParametersValue)(parameters, \"findOrigin\", this.defaultValues(\"findOrigin\"));\n    /**\r\n     * @type {Function}\r\n     * @desc The date at which the check would be\r\n     */\n\n    this.findIssuer = (0, _pvutils.getParametersValue)(parameters, \"findIssuer\", this.defaultValues(\"findIssuer\")); //endregion\n  } //**********************************************************************************\n\n\n  static defaultFindOrigin(certificate, validationEngine) {\n    //region Firstly encode TBS for certificate\n    if (certificate.tbs.byteLength === 0) certificate.tbs = certificate.encodeTBS(); //endregion\n    //region Search in Intermediate Certificates\n\n    var _iterator = _createForOfIteratorHelper(validationEngine.certs),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const localCert = _step.value;\n        //region Firstly encode TBS for certificate\n        if (localCert.tbs.byteLength === 0) localCert.tbs = localCert.encodeTBS(); //endregion\n\n        if ((0, _pvutils.isEqualBuffer)(certificate.tbs, localCert.tbs)) return \"Intermediate Certificates\";\n      } //endregion\n      //region Search in Trusted Certificates\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper(validationEngine.trustedCerts),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        const trustedCert = _step2.value;\n        //region Firstly encode TBS for certificate\n        if (trustedCert.tbs.byteLength === 0) trustedCert.tbs = trustedCert.encodeTBS(); //endregion\n\n        if ((0, _pvutils.isEqualBuffer)(certificate.tbs, trustedCert.tbs)) return \"Trusted Certificates\";\n      } //endregion\n\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return \"Unknown\";\n  } //**********************************************************************************\n\n\n  defaultFindIssuer(certificate, validationEngine) {\n    return _asyncToGenerator(function* () {\n      //region Initial variables\n      let result = [];\n      let keyIdentifier = null;\n      let authorityCertIssuer = null;\n      let authorityCertSerialNumber = null; //endregion\n      //region Speed-up searching in case of self-signed certificates\n\n      if (certificate.subject.isEqual(certificate.issuer)) {\n        try {\n          const verificationResult = yield certificate.verify();\n          if (verificationResult === true) return [certificate];\n        } catch (ex) {}\n      } //endregion\n      //region Find values to speed-up search\n\n\n      if (\"extensions\" in certificate) {\n        var _iterator3 = _createForOfIteratorHelper(certificate.extensions),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            const extension = _step3.value;\n\n            if (extension.extnID === \"2.5.29.35\") // AuthorityKeyIdentifier\n              {\n                if (\"keyIdentifier\" in extension.parsedValue) keyIdentifier = extension.parsedValue.keyIdentifier;else {\n                  if (\"authorityCertIssuer\" in extension.parsedValue) authorityCertIssuer = extension.parsedValue.authorityCertIssuer;\n                  if (\"authorityCertSerialNumber\" in extension.parsedValue) authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;\n                }\n                break;\n              }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } //endregion\n      //region Aux function\n\n\n      function checkCertificate(possibleIssuer) {\n        //region Firstly search for appropriate extensions\n        if (keyIdentifier !== null) {\n          if (\"extensions\" in possibleIssuer) {\n            let extensionFound = false;\n\n            var _iterator4 = _createForOfIteratorHelper(possibleIssuer.extensions),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                const extension = _step4.value;\n\n                if (extension.extnID === \"2.5.29.14\") // SubjectKeyIdentifier\n                  {\n                    extensionFound = true;\n                    if ((0, _pvutils.isEqualBuffer)(extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHex)) result.push(possibleIssuer);\n                    break;\n                  }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            if (extensionFound) return;\n          }\n        } //endregion\n        //region Now search for authorityCertSerialNumber\n\n\n        let authorityCertSerialNumberEqual = false;\n        if (authorityCertSerialNumber !== null) authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber); //endregion\n        //region And at least search for Issuer data\n\n        if (authorityCertIssuer !== null) {\n          if (possibleIssuer.subject.isEqual(authorityCertIssuer)) {\n            if (authorityCertSerialNumberEqual) result.push(possibleIssuer);\n          }\n        } else {\n          if (certificate.issuer.isEqual(possibleIssuer.subject)) result.push(possibleIssuer);\n        } //endregion\n\n      } //endregion\n      //region Search in Trusted Certificates\n\n\n      var _iterator5 = _createForOfIteratorHelper(validationEngine.trustedCerts),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          const trustedCert = _step5.value;\n          checkCertificate(trustedCert);\n        } //endregion\n        //region Search in Intermediate Certificates\n\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(validationEngine.certs),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          const intermediateCert = _step6.value;\n          checkCertificate(intermediateCert);\n        } //endregion\n        //region Now perform certificate verification checking\n\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      for (let i = 0; i < result.length; i++) {\n        try {\n          const verificationResult = yield certificate.verify(result[i]);\n          if (verificationResult === false) result.splice(i, 1);\n        } catch (ex) {\n          result.splice(i, 1); // Something wrong, remove the certificate\n        }\n      } //endregion\n\n\n      return result;\n    })();\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  defaultValues(memberName) {\n    switch (memberName) {\n      case \"trustedCerts\":\n        return [];\n\n      case \"certs\":\n        return [];\n\n      case \"crls\":\n        return [];\n\n      case \"ocsps\":\n        return [];\n\n      case \"checkDate\":\n        return new Date();\n\n      case \"findOrigin\":\n        return CertificateChainValidationEngine.defaultFindOrigin;\n\n      case \"findIssuer\":\n        return this.defaultFindIssuer;\n\n      default:\n        throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n\n  sort(passedWhenNotRevValues = false) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      //region Initial variables\n      const localCerts = [];\n      const _this = _this2; //endregion\n      //region Building certificate path\n\n      function buildPath(_x) {\n        return _buildPath.apply(this, arguments);\n      } //endregion\n      //region Find CRL for specific certificate\n\n\n      function _buildPath() {\n        _buildPath = _asyncToGenerator(function* (certificate) {\n          const result = []; //region Aux function checking array for unique elements\n\n          function checkUnique(array) {\n            let unique = true;\n\n            for (let i = 0; i < array.length; i++) {\n              for (let j = 0; j < array.length; j++) {\n                if (j === i) continue;\n\n                if (array[i] === array[j]) {\n                  unique = false;\n                  break;\n                }\n              }\n\n              if (!unique) break;\n            }\n\n            return unique;\n          } //endregion\n\n\n          const findIssuerResult = yield _this.findIssuer(certificate, _this);\n          if (findIssuerResult.length === 0) throw new Error(\"No valid certificate paths found\");\n\n          for (let i = 0; i < findIssuerResult.length; i++) {\n            if ((0, _pvutils.isEqualBuffer)(findIssuerResult[i].tbs, certificate.tbs)) {\n              result.push([findIssuerResult[i]]);\n              continue;\n            }\n\n            const buildPathResult = yield buildPath(findIssuerResult[i]);\n\n            for (let j = 0; j < buildPathResult.length; j++) {\n              const copy = buildPathResult[j].slice();\n              copy.splice(0, 0, findIssuerResult[i]);\n              if (checkUnique(copy)) result.push(copy);else result.push(buildPathResult[j]);\n            }\n          }\n\n          return result;\n        });\n        return _buildPath.apply(this, arguments);\n      }\n\n      function findCRL(_x2) {\n        return _findCRL.apply(this, arguments);\n      } //endregion\n      //region Find OCSP for specific certificate\n\n\n      function _findCRL() {\n        _findCRL = _asyncToGenerator(function* (certificate) {\n          //region Initial variables\n          const issuerCertificates = [];\n          const crls = [];\n          const crlsAndCertificates = []; //endregion\n          //region Find all possible CRL issuers\n\n          issuerCertificates.push(...localCerts.filter(element => certificate.issuer.isEqual(element.subject)));\n\n          if (issuerCertificates.length === 0) {\n            return {\n              status: 1,\n              statusMessage: \"No certificate's issuers\"\n            };\n          } //endregion\n          //region Find all CRLs for certificate's issuer\n\n\n          crls.push(..._this.crls.filter(element => element.issuer.isEqual(certificate.issuer)));\n\n          if (crls.length === 0) {\n            return {\n              status: 2,\n              statusMessage: \"No CRLs for specific certificate issuer\"\n            };\n          } //endregion\n          //region Find specific certificate of issuer for each CRL\n\n\n          for (let i = 0; i < crls.length; i++) {\n            //region Check \"nextUpdate\" for the CRL\n            // The \"nextUpdate\" is older than \"checkDate\".\n            // Thus we should do have another, updated CRL.\n            // Thus the CRL assumed to be invalid.\n            if (crls[i].nextUpdate.value < _this.checkDate) continue; //endregion\n\n            for (let j = 0; j < issuerCertificates.length; j++) {\n              try {\n                const result = yield crls[i].verify({\n                  issuerCertificate: issuerCertificates[j]\n                });\n\n                if (result) {\n                  crlsAndCertificates.push({\n                    crl: crls[i],\n                    certificate: issuerCertificates[j]\n                  });\n                  break;\n                }\n              } catch (ex) {}\n            }\n          } //endregion\n\n\n          if (crlsAndCertificates.length) {\n            return {\n              status: 0,\n              statusMessage: \"\",\n              result: crlsAndCertificates\n            };\n          }\n\n          return {\n            status: 3,\n            statusMessage: \"No valid CRLs found\"\n          };\n        });\n        return _findCRL.apply(this, arguments);\n      }\n\n      function findOCSP(_x3, _x4) {\n        return _findOCSP.apply(this, arguments);\n      } //endregion\n      //region Check for certificate to be CA\n\n\n      function _findOCSP() {\n        _findOCSP = _asyncToGenerator(function* (certificate, issuerCertificate) {\n          //region Get hash algorithm from certificate\n          const hashAlgorithm = (0, _common.getAlgorithmByOID)(certificate.signatureAlgorithm.algorithmId);\n          if (\"name\" in hashAlgorithm === false) return 1;\n          if (\"hash\" in hashAlgorithm === false) return 1; //endregion\n          //region Search for OCSP response for the certificate\n\n          for (let i = 0; i < _this.ocsps.length; i++) {\n            const result = yield _this.ocsps[i].getCertificateStatus(certificate, issuerCertificate);\n\n            if (result.isForCertificate) {\n              if (result.status === 0) return 0;\n              return 1;\n            }\n          } //endregion\n\n\n          return 2;\n        });\n        return _findOCSP.apply(this, arguments);\n      }\n\n      function checkForCA(_x5) {\n        return _checkForCA.apply(this, arguments);\n      } //endregion\n      //region Basic check for certificate path\n\n\n      function _checkForCA() {\n        _checkForCA = _asyncToGenerator(function* (certificate, needToCheckCRL = false) {\n          //region Initial variables\n          let isCA = false;\n          let mustBeCA = false;\n          let keyUsagePresent = false;\n          let cRLSign = false; //endregion\n\n          if (\"extensions\" in certificate) {\n            for (let j = 0; j < certificate.extensions.length; j++) {\n              if (certificate.extensions[j].critical === true && \"parsedValue\" in certificate.extensions[j] === false) {\n                return {\n                  result: false,\n                  resultCode: 6,\n                  resultMessage: `Unable to parse critical certificate extension: ${certificate.extensions[j].extnID}`\n                };\n              }\n\n              if (certificate.extensions[j].extnID === \"2.5.29.15\") // KeyUsage\n                {\n                  keyUsagePresent = true;\n                  const view = new Uint8Array(certificate.extensions[j].parsedValue.valueBlock.valueHex);\n                  if ((view[0] & 0x04) === 0x04) // Set flag \"keyCertSign\"\n                    mustBeCA = true;\n                  if ((view[0] & 0x02) === 0x02) // Set flag \"cRLSign\"\n                    cRLSign = true;\n                }\n\n              if (certificate.extensions[j].extnID === \"2.5.29.19\") // BasicConstraints\n                {\n                  if (\"cA\" in certificate.extensions[j].parsedValue) {\n                    if (certificate.extensions[j].parsedValue.cA === true) isCA = true;\n                  }\n                }\n            }\n\n            if (mustBeCA === true && isCA === false) {\n              return {\n                result: false,\n                resultCode: 3,\n                resultMessage: \"Unable to build certificate chain - using \\\"keyCertSign\\\" flag set without BasicConstaints\"\n              };\n            }\n\n            if (keyUsagePresent === true && isCA === true && mustBeCA === false) {\n              return {\n                result: false,\n                resultCode: 4,\n                resultMessage: \"Unable to build certificate chain - \\\"keyCertSign\\\" flag was not set\"\n              };\n            } // noinspection OverlyComplexBooleanExpressionJS\n\n\n            if (isCA === true && keyUsagePresent === true && needToCheckCRL && cRLSign === false) {\n              return {\n                result: false,\n                resultCode: 5,\n                resultMessage: \"Unable to build certificate chain - intermediate certificate must have \\\"cRLSign\\\" key usage flag\"\n              };\n            }\n          }\n\n          if (isCA === false) {\n            return {\n              result: false,\n              resultCode: 7,\n              resultMessage: \"Unable to build certificate chain - more than one possible end-user certificate\"\n            };\n          }\n\n          return {\n            result: true,\n            resultCode: 0,\n            resultMessage: \"\"\n          };\n        });\n        return _checkForCA.apply(this, arguments);\n      }\n\n      function basicCheck(_x6, _x7) {\n        return _basicCheck.apply(this, arguments);\n      } //endregion\n      //region Do main work\n      //region Initialize \"localCerts\" by value of \"_this.certs\" + \"_this.trustedCerts\" arrays\n\n\n      function _basicCheck() {\n        _basicCheck = _asyncToGenerator(function* (path, checkDate) {\n          //region Check that all dates are valid\n          for (let i = 0; i < path.length; i++) {\n            if (path[i].notBefore.value > checkDate || path[i].notAfter.value < checkDate) {\n              return {\n                result: false,\n                resultCode: 8,\n                resultMessage: \"The certificate is either not yet valid or expired\"\n              };\n            }\n          } //endregion\n          //region Check certificate name chain\n          // We should have at least two certificates: end entity and trusted root\n\n\n          if (path.length < 2) {\n            return {\n              result: false,\n              resultCode: 9,\n              resultMessage: \"Too short certificate path\"\n            };\n          }\n\n          for (let i = path.length - 2; i >= 0; i--) {\n            //region Check that we do not have a \"self-signed\" certificate\n            if (path[i].issuer.isEqual(path[i].subject) === false) {\n              if (path[i].issuer.isEqual(path[i + 1].subject) === false) {\n                return {\n                  result: false,\n                  resultCode: 10,\n                  resultMessage: \"Incorrect name chaining\"\n                };\n              }\n            } //endregion\n\n          } //endregion\n          //region Check each certificate (except \"trusted root\") to be non-revoked\n\n\n          if (_this.crls.length !== 0 || _this.ocsps.length !== 0) // If CRLs and OCSPs are empty then we consider all certificates to be valid\n            {\n              for (let i = 0; i < path.length - 1; i++) {\n                //region Initial variables\n                let ocspResult = 2;\n                let crlResult = {\n                  status: 0,\n                  statusMessage: \"\"\n                }; //endregion\n                //region Check OCSPs first\n\n                if (_this.ocsps.length !== 0) {\n                  ocspResult = yield findOCSP(path[i], path[i + 1]);\n\n                  switch (ocspResult) {\n                    case 0:\n                      continue;\n\n                    case 1:\n                      return {\n                        result: false,\n                        resultCode: 12,\n                        resultMessage: \"One of certificates was revoked via OCSP response\"\n                      };\n\n                    case 2:\n                      // continue to check the certificate with CRL\n                      break;\n\n                    default:\n                  }\n                } //endregion\n                //region Check CRLs\n\n\n                if (_this.crls.length !== 0) {\n                  crlResult = yield findCRL(path[i]);\n\n                  if (crlResult.status === 0) {\n                    for (let j = 0; j < crlResult.result.length; j++) {\n                      //region Check that the CRL issuer certificate have not been revoked\n                      const isCertificateRevoked = crlResult.result[j].crl.isCertificateRevoked(path[i]);\n\n                      if (isCertificateRevoked) {\n                        return {\n                          result: false,\n                          resultCode: 12,\n                          resultMessage: \"One of certificates had been revoked\"\n                        };\n                      } //endregion\n                      //region Check that the CRL issuer certificate is a CA certificate\n\n\n                      const isCertificateCA = yield checkForCA(crlResult.result[j].certificate, true);\n\n                      if (isCertificateCA.result === false) {\n                        return {\n                          result: false,\n                          resultCode: 13,\n                          resultMessage: \"CRL issuer certificate is not a CA certificate or does not have crlSign flag\"\n                        };\n                      } //endregion\n\n                    }\n                  } else {\n                    if (passedWhenNotRevValues === false) {\n                      throw {\n                        result: false,\n                        resultCode: 11,\n                        resultMessage: `No revocation values found for one of certificates: ${crlResult.statusMessage}`\n                      };\n                    }\n                  }\n                } else {\n                  if (ocspResult === 2) {\n                    return {\n                      result: false,\n                      resultCode: 11,\n                      resultMessage: \"No revocation values found for one of certificates\"\n                    };\n                  }\n                } //endregion\n                //region Check we do have links to revocation values inside issuer's certificate\n\n\n                if (ocspResult === 2 && crlResult.status === 2 && passedWhenNotRevValues) {\n                  const issuerCertificate = path[i + 1];\n                  let extensionFound = false;\n\n                  if (\"extensions\" in issuerCertificate) {\n                    var _iterator7 = _createForOfIteratorHelper(issuerCertificate.extensions),\n                        _step7;\n\n                    try {\n                      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                        const extension = _step7.value;\n\n                        switch (extension.extnID) {\n                          case \"2.5.29.31\": // CRLDistributionPoints\n\n                          case \"2.5.29.46\": // FreshestCRL\n\n                          case \"1.3.6.1.5.5.7.1.1\":\n                            // AuthorityInfoAccess\n                            extensionFound = true;\n                            break;\n\n                          default:\n                        }\n                      }\n                    } catch (err) {\n                      _iterator7.e(err);\n                    } finally {\n                      _iterator7.f();\n                    }\n                  }\n\n                  if (extensionFound) {\n                    throw {\n                      result: false,\n                      resultCode: 11,\n                      resultMessage: `No revocation values found for one of certificates: ${crlResult.statusMessage}`\n                    };\n                  }\n                } //endregion\n\n              }\n            } //endregion\n          //region Check each certificate (except \"end entity\") in the path to be a CA certificate\n\n\n          for (let i = 1; i < path.length; i++) {\n            const result = yield checkForCA(path[i]);\n\n            if (result.result === false) {\n              return {\n                result: false,\n                resultCode: 14,\n                resultMessage: \"One of intermediate certificates is not a CA certificate\"\n              };\n            }\n          } //endregion\n\n\n          return {\n            result: true\n          };\n        });\n        return _basicCheck.apply(this, arguments);\n      }\n\n      localCerts.push(..._this.trustedCerts);\n      localCerts.push(..._this.certs); //endregion\n      //region Check all certificates for been unique\n\n      for (let i = 0; i < localCerts.length; i++) {\n        for (let j = 0; j < localCerts.length; j++) {\n          if (i === j) continue;\n\n          if ((0, _pvutils.isEqualBuffer)(localCerts[i].tbs, localCerts[j].tbs)) {\n            localCerts.splice(j, 1);\n            i = 0;\n            break;\n          }\n        }\n      } //endregion\n      //region Initial variables\n\n\n      let result;\n      const certificatePath = [localCerts[localCerts.length - 1]]; // The \"end entity\" certificate must be the least in \"certs\" array\n      //endregion\n      //region Build path for \"end entity\" certificate\n\n      result = yield buildPath(localCerts[localCerts.length - 1]);\n\n      if (result.length === 0) {\n        return {\n          result: false,\n          resultCode: 60,\n          resultMessage: \"Unable to find certificate path\"\n        };\n      } //endregion\n      //region Exclude certificate paths not ended with \"trusted roots\"\n\n\n      for (let i = 0; i < result.length; i++) {\n        let found = false;\n\n        for (let j = 0; j < result[i].length; j++) {\n          const certificate = result[i][j];\n\n          for (let k = 0; k < _this.trustedCerts.length; k++) {\n            if ((0, _pvutils.isEqualBuffer)(certificate.tbs, _this.trustedCerts[k].tbs)) {\n              found = true;\n              break;\n            }\n          }\n\n          if (found) break;\n        }\n\n        if (!found) {\n          result.splice(i, 1);\n          i = 0;\n        }\n      }\n\n      if (result.length === 0) {\n        throw {\n          result: false,\n          resultCode: 97,\n          resultMessage: \"No valid certificate paths found\"\n        };\n      } //endregion\n      //region Find shortest certificate path (for the moment it is the only criteria)\n\n\n      let shortestLength = result[0].length;\n      let shortestIndex = 0;\n\n      for (let i = 0; i < result.length; i++) {\n        if (result[i].length < shortestLength) {\n          shortestLength = result[i].length;\n          shortestIndex = i;\n        }\n      } //endregion\n      //region Create certificate path for basic check\n\n\n      for (let i = 0; i < result[shortestIndex].length; i++) certificatePath.push(result[shortestIndex][i]); //endregion\n      //region Perform basic checking for all certificates in the path\n\n\n      result = yield basicCheck(certificatePath, _this.checkDate);\n      if (result.result === false) throw result; //endregion\n\n      return certificatePath; //endregion\n    })();\n  } //**********************************************************************************\n\n  /**\r\n   * Major verification function for certificate chain.\r\n   * @param {{initialPolicySet, initialExplicitPolicy, initialPolicyMappingInhibit, initialInhibitPolicy, initialPermittedSubtreesSet, initialExcludedSubtreesSet, initialRequiredNameForms}} [parameters]\r\n   * @returns {Promise}\r\n   */\n\n\n  verify(parameters = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      //region Auxiliary functions for name constraints checking\n      function compareDNSName(name, constraint) {\n        /// <summary>Compare two dNSName values</summary>\n        /// <param name=\"name\" type=\"String\">DNS from name</param>\n        /// <param name=\"constraint\" type=\"String\">Constraint for DNS from name</param>\n        /// <returns type=\"Boolean\">Boolean result - valid or invalid the \"name\" against the \"constraint\"</returns>\n        //region Make a \"string preparation\" for both name and constrain\n        const namePrepared = (0, _common.stringPrep)(name);\n        const constraintPrepared = (0, _common.stringPrep)(constraint); //endregion\n        //region Make a \"splitted\" versions of \"constraint\" and \"name\"\n\n        const nameSplitted = namePrepared.split(\".\");\n        const constraintSplitted = constraintPrepared.split(\".\"); //endregion\n        //region Length calculation and additional check\n\n        const nameLen = nameSplitted.length;\n        const constrLen = constraintSplitted.length;\n        if (nameLen === 0 || constrLen === 0 || nameLen < constrLen) return false; //endregion\n        //region Check that no part of \"name\" has zero length\n\n        for (let i = 0; i < nameLen; i++) {\n          if (nameSplitted[i].length === 0) return false;\n        } //endregion\n        //region Check that no part of \"constraint\" has zero length\n\n\n        for (let i = 0; i < constrLen; i++) {\n          if (constraintSplitted[i].length === 0) {\n            if (i === 0) {\n              if (constrLen === 1) return false;\n              continue;\n            }\n\n            return false;\n          }\n        } //endregion\n        //region Check that \"name\" has a tail as \"constraint\"\n\n\n        for (let i = 0; i < constrLen; i++) {\n          if (constraintSplitted[constrLen - 1 - i].length === 0) continue;\n          if (nameSplitted[nameLen - 1 - i].localeCompare(constraintSplitted[constrLen - 1 - i]) !== 0) return false;\n        } //endregion\n\n\n        return true;\n      }\n\n      function compareRFC822Name(name, constraint) {\n        /// <summary>Compare two rfc822Name values</summary>\n        /// <param name=\"name\" type=\"String\">E-mail address from name</param>\n        /// <param name=\"constraint\" type=\"String\">Constraint for e-mail address from name</param>\n        /// <returns type=\"Boolean\">Boolean result - valid or invalid the \"name\" against the \"constraint\"</returns>\n        //region Make a \"string preparation\" for both name and constrain\n        const namePrepared = (0, _common.stringPrep)(name);\n        const constraintPrepared = (0, _common.stringPrep)(constraint); //endregion\n        //region Make a \"splitted\" versions of \"constraint\" and \"name\"\n\n        const nameSplitted = namePrepared.split(\"@\");\n        const constraintSplitted = constraintPrepared.split(\"@\"); //endregion\n        //region Splitted array length checking\n\n        if (nameSplitted.length === 0 || constraintSplitted.length === 0 || nameSplitted.length < constraintSplitted.length) return false; //endregion\n\n        if (constraintSplitted.length === 1) {\n          const result = compareDNSName(nameSplitted[1], constraintSplitted[0]);\n\n          if (result) {\n            //region Make a \"splitted\" versions of domain name from \"constraint\" and \"name\"\n            const ns = nameSplitted[1].split(\".\");\n            const cs = constraintSplitted[0].split(\".\"); //endregion\n\n            if (cs[0].length === 0) return true;\n            return ns.length === cs.length;\n          }\n\n          return false;\n        }\n\n        return namePrepared.localeCompare(constraintPrepared) === 0;\n      }\n\n      function compareUniformResourceIdentifier(name, constraint) {\n        /// <summary>Compare two uniformResourceIdentifier values</summary>\n        /// <param name=\"name\" type=\"String\">uniformResourceIdentifier from name</param>\n        /// <param name=\"constraint\" type=\"String\">Constraint for uniformResourceIdentifier from name</param>\n        /// <returns type=\"Boolean\">Boolean result - valid or invalid the \"name\" against the \"constraint\"</returns>\n        //region Make a \"string preparation\" for both name and constrain\n        let namePrepared = (0, _common.stringPrep)(name);\n        const constraintPrepared = (0, _common.stringPrep)(constraint); //endregion\n        //region Find out a major URI part to compare with\n\n        const ns = namePrepared.split(\"/\");\n        const cs = constraintPrepared.split(\"/\");\n        if (cs.length > 1) // Malformed constraint\n          return false;\n\n        if (ns.length > 1) // Full URI string\n          {\n            for (let i = 0; i < ns.length; i++) {\n              if (ns[i].length > 0 && ns[i].charAt(ns[i].length - 1) !== \":\") {\n                const nsPort = ns[i].split(\":\");\n                namePrepared = nsPort[0];\n                break;\n              }\n            }\n          } //endregion\n\n\n        const result = compareDNSName(namePrepared, constraintPrepared);\n\n        if (result) {\n          //region Make a \"splitted\" versions of \"constraint\" and \"name\"\n          const nameSplitted = namePrepared.split(\".\");\n          const constraintSplitted = constraintPrepared.split(\".\"); //endregion\n\n          if (constraintSplitted[0].length === 0) return true;\n          return nameSplitted.length === constraintSplitted.length;\n        }\n\n        return false;\n      }\n\n      function compareIPAddress(name, constraint) {\n        /// <summary>Compare two iPAddress values</summary>\n        /// <param name=\"name\" type=\"in_window.org.pkijs.asn1.OCTETSTRING\">iPAddress from name</param>\n        /// <param name=\"constraint\" type=\"in_window.org.pkijs.asn1.OCTETSTRING\">Constraint for iPAddress from name</param>\n        /// <returns type=\"Boolean\">Boolean result - valid or invalid the \"name\" against the \"constraint\"</returns>\n        //region Common variables\n        const nameView = new Uint8Array(name.valueBlock.valueHex);\n        const constraintView = new Uint8Array(constraint.valueBlock.valueHex); //endregion\n        //region Work with IPv4 addresses\n\n        if (nameView.length === 4 && constraintView.length === 8) {\n          for (let i = 0; i < 4; i++) {\n            if ((nameView[i] ^ constraintView[i]) & constraintView[i + 4]) return false;\n          }\n\n          return true;\n        } //endregion\n        //region Work with IPv6 addresses\n\n\n        if (nameView.length === 16 && constraintView.length === 32) {\n          for (let i = 0; i < 16; i++) {\n            if ((nameView[i] ^ constraintView[i]) & constraintView[i + 16]) return false;\n          }\n\n          return true;\n        } //endregion\n\n\n        return false;\n      }\n\n      function compareDirectoryName(name, constraint) {\n        /// <summary>Compare two directoryName values</summary>\n        /// <param name=\"name\" type=\"in_window.org.pkijs.simpl.RDN\">directoryName from name</param>\n        /// <param name=\"constraint\" type=\"in_window.org.pkijs.simpl.RDN\">Constraint for directoryName from name</param>\n        /// <param name=\"any\" type=\"Boolean\">Boolean flag - should be comparision interrupted after first match or we need to match all \"constraints\" parts</param>\n        /// <returns type=\"Boolean\">Boolean result - valid or invalid the \"name\" against the \"constraint\"</returns>\n        //region Initial check\n        if (name.typesAndValues.length === 0 || constraint.typesAndValues.length === 0) return true;\n        if (name.typesAndValues.length < constraint.typesAndValues.length) return false; //endregion\n        //region Initial variables\n\n        let result = true;\n        let nameStart = 0; //endregion\n\n        for (let i = 0; i < constraint.typesAndValues.length; i++) {\n          let localResult = false;\n\n          for (let j = nameStart; j < name.typesAndValues.length; j++) {\n            localResult = name.typesAndValues[j].isEqual(constraint.typesAndValues[i]);\n            if (name.typesAndValues[j].type === constraint.typesAndValues[i].type) result = result && localResult;\n\n            if (localResult === true) {\n              if (nameStart === 0 || nameStart === j) {\n                nameStart = j + 1;\n                break;\n              } else // Structure of \"name\" must be the same with \"constraint\"\n                return false;\n            }\n          }\n\n          if (localResult === false) return false;\n        }\n\n        return nameStart === 0 ? false : result;\n      } //endregion\n\n\n      try {\n        //region Initial checks\n        if (_this3.certs.length === 0) throw \"Empty certificate array\"; //endregion\n        //region Get input variables\n\n        let passedWhenNotRevValues = false;\n        if (\"passedWhenNotRevValues\" in parameters) passedWhenNotRevValues = parameters.passedWhenNotRevValues;\n        let initialPolicySet = [];\n        initialPolicySet.push(\"2.5.29.32.0\"); // \"anyPolicy\"\n\n        let initialExplicitPolicy = false;\n        let initialPolicyMappingInhibit = false;\n        let initialInhibitPolicy = false;\n        let initialPermittedSubtreesSet = []; // Array of \"simpl.x509.GeneralSubtree\"\n\n        let initialExcludedSubtreesSet = []; // Array of \"simpl.x509.GeneralSubtree\"\n\n        let initialRequiredNameForms = []; // Array of \"simpl.x509.GeneralSubtree\"\n\n        if (\"initialPolicySet\" in parameters) initialPolicySet = parameters.initialPolicySet;\n        if (\"initialExplicitPolicy\" in parameters) initialExplicitPolicy = parameters.initialExplicitPolicy;\n        if (\"initialPolicyMappingInhibit\" in parameters) initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit;\n        if (\"initialInhibitPolicy\" in parameters) initialInhibitPolicy = parameters.initialInhibitPolicy;\n        if (\"initialPermittedSubtreesSet\" in parameters) initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet;\n        if (\"initialExcludedSubtreesSet\" in parameters) initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet;\n        if (\"initialRequiredNameForms\" in parameters) initialRequiredNameForms = parameters.initialRequiredNameForms;\n        let explicitPolicyIndicator = initialExplicitPolicy;\n        let policyMappingInhibitIndicator = initialPolicyMappingInhibit;\n        let inhibitAnyPolicyIndicator = initialInhibitPolicy;\n        const pendingConstraints = new Array(3);\n        pendingConstraints[0] = false; // For \"explicitPolicyPending\"\n\n        pendingConstraints[1] = false; // For \"policyMappingInhibitPending\"\n\n        pendingConstraints[2] = false; // For \"inhibitAnyPolicyPending\"\n\n        let explicitPolicyPending = 0;\n        let policyMappingInhibitPending = 0;\n        let inhibitAnyPolicyPending = 0;\n        let permittedSubtrees = initialPermittedSubtreesSet;\n        let excludedSubtrees = initialExcludedSubtreesSet;\n        const requiredNameForms = initialRequiredNameForms;\n        let pathDepth = 1; //endregion\n        //region Sorting certificates in the chain array\n\n        _this3.certs = yield _this3.sort(passedWhenNotRevValues); //endregion\n        //region Work with policies\n        //region Support variables\n\n        const allPolicies = []; // Array of all policies (string values)\n\n        allPolicies.push(\"2.5.29.32.0\"); // Put \"anyPolicy\" at first place\n\n        const policiesAndCerts = []; // In fact \"array of array\" where rows are for each specific policy, column for each certificate and value is \"true/false\"\n\n        const anyPolicyArray = new Array(_this3.certs.length - 1); // Minus \"trusted anchor\"\n\n        for (let ii = 0; ii < _this3.certs.length - 1; ii++) anyPolicyArray[ii] = true;\n\n        policiesAndCerts.push(anyPolicyArray);\n        const policyMappings = new Array(_this3.certs.length - 1); // Array of \"PolicyMappings\" for each certificate\n\n        const certPolicies = new Array(_this3.certs.length - 1); // Array of \"CertificatePolicies\" for each certificate\n\n        let explicitPolicyStart = explicitPolicyIndicator ? _this3.certs.length - 1 : -1; //endregion\n        //region Gather all neccessary information from certificate chain\n\n        for (let i = _this3.certs.length - 2; i >= 0; i--, pathDepth++) {\n          if (\"extensions\" in _this3.certs[i]) {\n            //region Get information about certificate extensions\n            for (let j = 0; j < _this3.certs[i].extensions.length; j++) {\n              //region CertificatePolicies\n              if (_this3.certs[i].extensions[j].extnID === \"2.5.29.32\") {\n                certPolicies[i] = _this3.certs[i].extensions[j].parsedValue; //region Remove entry from \"anyPolicies\" for the certificate\n\n                for (let s = 0; s < allPolicies.length; s++) {\n                  if (allPolicies[s] === \"2.5.29.32.0\") {\n                    delete policiesAndCerts[s][i];\n                    break;\n                  }\n                } //endregion\n\n\n                for (let k = 0; k < _this3.certs[i].extensions[j].parsedValue.certificatePolicies.length; k++) {\n                  let policyIndex = -1; //region Try to find extension in \"allPolicies\" array\n\n                  for (let s = 0; s < allPolicies.length; s++) {\n                    if (_this3.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier === allPolicies[s]) {\n                      policyIndex = s;\n                      break;\n                    }\n                  } //endregion\n\n\n                  if (policyIndex === -1) {\n                    allPolicies.push(_this3.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier);\n                    const certArray = new Array(_this3.certs.length - 1);\n                    certArray[i] = true;\n                    policiesAndCerts.push(certArray);\n                  } else policiesAndCerts[policyIndex][i] = true;\n                }\n              } //endregion\n              //region PolicyMappings\n\n\n              if (_this3.certs[i].extensions[j].extnID === \"2.5.29.33\") {\n                if (policyMappingInhibitIndicator) {\n                  return {\n                    result: false,\n                    resultCode: 98,\n                    resultMessage: \"Policy mapping prohibited\"\n                  };\n                }\n\n                policyMappings[i] = _this3.certs[i].extensions[j].parsedValue;\n              } //endregion\n              //region PolicyConstraints\n\n\n              if (_this3.certs[i].extensions[j].extnID === \"2.5.29.36\") {\n                if (explicitPolicyIndicator === false) {\n                  //region requireExplicitPolicy\n                  if (_this3.certs[i].extensions[j].parsedValue.requireExplicitPolicy === 0) {\n                    explicitPolicyIndicator = true;\n                    explicitPolicyStart = i;\n                  } else {\n                    if (pendingConstraints[0] === false) {\n                      pendingConstraints[0] = true;\n                      explicitPolicyPending = _this3.certs[i].extensions[j].parsedValue.requireExplicitPolicy;\n                    } else explicitPolicyPending = explicitPolicyPending > _this3.certs[i].extensions[j].parsedValue.requireExplicitPolicy ? _this3.certs[i].extensions[j].parsedValue.requireExplicitPolicy : explicitPolicyPending;\n                  } //endregion\n                  //region inhibitPolicyMapping\n\n\n                  if (_this3.certs[i].extensions[j].parsedValue.inhibitPolicyMapping === 0) policyMappingInhibitIndicator = true;else {\n                    if (pendingConstraints[1] === false) {\n                      pendingConstraints[1] = true;\n                      policyMappingInhibitPending = _this3.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1;\n                    } else policyMappingInhibitPending = policyMappingInhibitPending > _this3.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1 ? _this3.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1 : policyMappingInhibitPending;\n                  } //endregion\n                }\n              } //endregion\n              //region InhibitAnyPolicy\n\n\n              if (_this3.certs[i].extensions[j].extnID === \"2.5.29.54\") {\n                if (inhibitAnyPolicyIndicator === false) {\n                  if (_this3.certs[i].extensions[j].parsedValue.valueBlock.valueDec === 0) inhibitAnyPolicyIndicator = true;else {\n                    if (pendingConstraints[2] === false) {\n                      pendingConstraints[2] = true;\n                      inhibitAnyPolicyPending = _this3.certs[i].extensions[j].parsedValue.valueBlock.valueDec;\n                    } else inhibitAnyPolicyPending = inhibitAnyPolicyPending > _this3.certs[i].extensions[j].parsedValue.valueBlock.valueDec ? _this3.certs[i].extensions[j].parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;\n                  }\n                }\n              } //endregion\n\n            } //endregion\n            //region Check \"inhibitAnyPolicyIndicator\"\n\n\n            if (inhibitAnyPolicyIndicator === true) {\n              let policyIndex = -1; //region Find \"anyPolicy\" index\n\n              for (let searchAnyPolicy = 0; searchAnyPolicy < allPolicies.length; searchAnyPolicy++) {\n                if (allPolicies[searchAnyPolicy] === \"2.5.29.32.0\") {\n                  policyIndex = searchAnyPolicy;\n                  break;\n                }\n              } //endregion\n\n\n              if (policyIndex !== -1) delete policiesAndCerts[0][i]; // Unset value to \"undefined\" for \"anyPolicies\" value for current certificate\n            } //endregion\n            //region Process with \"pending constraints\"\n\n\n            if (explicitPolicyIndicator === false) {\n              if (pendingConstraints[0] === true) {\n                explicitPolicyPending--;\n\n                if (explicitPolicyPending === 0) {\n                  explicitPolicyIndicator = true;\n                  explicitPolicyStart = i;\n                  pendingConstraints[0] = false;\n                }\n              }\n            }\n\n            if (policyMappingInhibitIndicator === false) {\n              if (pendingConstraints[1] === true) {\n                policyMappingInhibitPending--;\n\n                if (policyMappingInhibitPending === 0) {\n                  policyMappingInhibitIndicator = true;\n                  pendingConstraints[1] = false;\n                }\n              }\n            }\n\n            if (inhibitAnyPolicyIndicator === false) {\n              if (pendingConstraints[2] === true) {\n                inhibitAnyPolicyPending--;\n\n                if (inhibitAnyPolicyPending === 0) {\n                  inhibitAnyPolicyIndicator = true;\n                  pendingConstraints[2] = false;\n                }\n              }\n            } //endregion\n\n          }\n        } //endregion\n        //region Working with policy mappings\n\n\n        for (let i = 0; i < _this3.certs.length - 1; i++) {\n          //region Check that there is \"policy mapping\" for level \"i + 1\"\n          if (i < _this3.certs.length - 2 && typeof policyMappings[i + 1] !== \"undefined\") {\n            for (let k = 0; k < policyMappings[i + 1].mappings.length; k++) {\n              //region Check that we do not have \"anyPolicy\" in current mapping\n              if (policyMappings[i + 1].mappings[k].issuerDomainPolicy === \"2.5.29.32.0\" || policyMappings[i + 1].mappings[k].subjectDomainPolicy === \"2.5.29.32.0\") {\n                return {\n                  result: false,\n                  resultCode: 99,\n                  resultMessage: \"The \\\"anyPolicy\\\" should not be a part of policy mapping scheme\"\n                };\n              } //endregion\n              //region Initial variables\n\n\n              let issuerDomainPolicyIndex = -1;\n              let subjectDomainPolicyIndex = -1; //endregion\n              //region Search for index of policies indedes\n\n              for (let n = 0; n < allPolicies.length; n++) {\n                if (allPolicies[n] === policyMappings[i + 1].mappings[k].issuerDomainPolicy) issuerDomainPolicyIndex = n;\n                if (allPolicies[n] === policyMappings[i + 1].mappings[k].subjectDomainPolicy) subjectDomainPolicyIndex = n;\n              } //endregion\n              //region Delete existing \"issuerDomainPolicy\" because on the level we mapped the policy to another one\n\n\n              if (typeof policiesAndCerts[issuerDomainPolicyIndex][i] !== \"undefined\") delete policiesAndCerts[issuerDomainPolicyIndex][i]; //endregion\n              //region Check all policies for the certificate\n\n              for (let j = 0; j < certPolicies[i].certificatePolicies.length; j++) {\n                if (policyMappings[i + 1].mappings[k].subjectDomainPolicy === certPolicies[i].certificatePolicies[j].policyIdentifier) {\n                  //region Set mapped policy for current certificate\n                  if (issuerDomainPolicyIndex !== -1 && subjectDomainPolicyIndex !== -1) {\n                    for (let m = 0; m <= i; m++) {\n                      if (typeof policiesAndCerts[subjectDomainPolicyIndex][m] !== \"undefined\") {\n                        policiesAndCerts[issuerDomainPolicyIndex][m] = true;\n                        delete policiesAndCerts[subjectDomainPolicyIndex][m];\n                      }\n                    }\n                  } //endregion\n\n                }\n              } //endregion\n\n            }\n          } //endregion\n\n        } //endregion\n        //region Working with \"explicitPolicyIndicator\" and \"anyPolicy\"\n\n\n        for (let i = 0; i < allPolicies.length; i++) {\n          if (allPolicies[i] === \"2.5.29.32.0\") {\n            for (let j = 0; j < explicitPolicyStart; j++) delete policiesAndCerts[i][j];\n          }\n        } //endregion\n        //region Create \"set of authorities-constrained policies\"\n\n\n        const authConstrPolicies = [];\n\n        for (let i = 0; i < policiesAndCerts.length; i++) {\n          let found = true;\n\n          for (let j = 0; j < _this3.certs.length - 1; j++) {\n            let anyPolicyFound = false;\n\n            if (j < explicitPolicyStart && allPolicies[i] === \"2.5.29.32.0\" && allPolicies.length > 1) {\n              found = false;\n              break;\n            }\n\n            if (typeof policiesAndCerts[i][j] === \"undefined\") {\n              if (j >= explicitPolicyStart) {\n                //region Search for \"anyPolicy\" in the policy set\n                for (let k = 0; k < allPolicies.length; k++) {\n                  if (allPolicies[k] === \"2.5.29.32.0\") {\n                    if (policiesAndCerts[k][j] === true) anyPolicyFound = true;\n                    break;\n                  }\n                } //endregion\n\n              }\n\n              if (!anyPolicyFound) {\n                found = false;\n                break;\n              }\n            }\n          }\n\n          if (found === true) authConstrPolicies.push(allPolicies[i]);\n        } //endregion\n        //region Create \"set of user-constrained policies\"\n\n\n        let userConstrPolicies = [];\n        if (initialPolicySet.length === 1 && initialPolicySet[0] === \"2.5.29.32.0\" && explicitPolicyIndicator === false) userConstrPolicies = initialPolicySet;else {\n          if (authConstrPolicies.length === 1 && authConstrPolicies[0] === \"2.5.29.32.0\") userConstrPolicies = initialPolicySet;else {\n            for (let i = 0; i < authConstrPolicies.length; i++) {\n              for (let j = 0; j < initialPolicySet.length; j++) {\n                if (initialPolicySet[j] === authConstrPolicies[i] || initialPolicySet[j] === \"2.5.29.32.0\") {\n                  userConstrPolicies.push(authConstrPolicies[i]);\n                  break;\n                }\n              }\n            }\n          }\n        } //endregion\n        //region Combine output object\n\n        const policyResult = {\n          result: userConstrPolicies.length > 0,\n          resultCode: 0,\n          resultMessage: userConstrPolicies.length > 0 ? \"\" : \"Zero \\\"userConstrPolicies\\\" array, no intersections with \\\"authConstrPolicies\\\"\",\n          authConstrPolicies,\n          userConstrPolicies,\n          explicitPolicyIndicator,\n          policyMappings,\n          certificatePath: _this3.certs\n        };\n        if (userConstrPolicies.length === 0) return policyResult; //endregion\n        //endregion\n        //region Work with name constraints\n        //region Check a result from \"policy checking\" part\n\n        if (policyResult.result === false) return policyResult; //endregion\n        //region Check all certificates, excluding \"trust anchor\"\n\n        pathDepth = 1;\n\n        for (let i = _this3.certs.length - 2; i >= 0; i--, pathDepth++) {\n          //region Support variables\n          let subjectAltNames = [];\n          let certPermittedSubtrees = [];\n          let certExcludedSubtrees = []; //endregion\n\n          if (\"extensions\" in _this3.certs[i]) {\n            for (let j = 0; j < _this3.certs[i].extensions.length; j++) {\n              //region NameConstraints\n              if (_this3.certs[i].extensions[j].extnID === \"2.5.29.30\") {\n                if (\"permittedSubtrees\" in _this3.certs[i].extensions[j].parsedValue) certPermittedSubtrees = certPermittedSubtrees.concat(_this3.certs[i].extensions[j].parsedValue.permittedSubtrees);\n                if (\"excludedSubtrees\" in _this3.certs[i].extensions[j].parsedValue) certExcludedSubtrees = certExcludedSubtrees.concat(_this3.certs[i].extensions[j].parsedValue.excludedSubtrees);\n              } //endregion\n              //region SubjectAltName\n\n\n              if (_this3.certs[i].extensions[j].extnID === \"2.5.29.17\") subjectAltNames = subjectAltNames.concat(_this3.certs[i].extensions[j].parsedValue.altNames); //endregion\n            }\n          } //region Checking for \"required name forms\"\n\n\n          let formFound = requiredNameForms.length <= 0;\n\n          for (let j = 0; j < requiredNameForms.length; j++) {\n            switch (requiredNameForms[j].base.type) {\n              case 4:\n                // directoryName\n                {\n                  if (requiredNameForms[j].base.value.typesAndValues.length !== _this3.certs[i].subject.typesAndValues.length) continue;\n                  formFound = true;\n\n                  for (let k = 0; k < _this3.certs[i].subject.typesAndValues.length; k++) {\n                    if (_this3.certs[i].subject.typesAndValues[k].type !== requiredNameForms[j].base.value.typesAndValues[k].type) {\n                      formFound = false;\n                      break;\n                    }\n                  }\n\n                  if (formFound === true) break;\n                }\n                break;\n\n              default: // ??? Probably here we should reject the certificate ???\n\n            }\n          }\n\n          if (formFound === false) {\n            policyResult.result = false;\n            policyResult.resultCode = 21;\n            policyResult.resultMessage = \"No neccessary name form found\";\n            throw policyResult;\n          } //endregion\n          //region Checking for \"permited sub-trees\"\n          //region Make groups for all types of constraints\n\n\n          const constrGroups = []; // Array of array for groupped constraints\n\n          constrGroups[0] = []; // rfc822Name\n\n          constrGroups[1] = []; // dNSName\n\n          constrGroups[2] = []; // directoryName\n\n          constrGroups[3] = []; // uniformResourceIdentifier\n\n          constrGroups[4] = []; // iPAddress\n\n          for (let j = 0; j < permittedSubtrees.length; j++) {\n            switch (permittedSubtrees[j].base.type) {\n              //region rfc822Name\n              case 1:\n                constrGroups[0].push(permittedSubtrees[j]);\n                break;\n              //endregion\n              //region dNSName\n\n              case 2:\n                constrGroups[1].push(permittedSubtrees[j]);\n                break;\n              //endregion\n              //region directoryName\n\n              case 4:\n                constrGroups[2].push(permittedSubtrees[j]);\n                break;\n              //endregion\n              //region uniformResourceIdentifier\n\n              case 6:\n                constrGroups[3].push(permittedSubtrees[j]);\n                break;\n              //endregion\n              //region iPAddress\n\n              case 7:\n                constrGroups[4].push(permittedSubtrees[j]);\n                break;\n              //endregion\n              //region default\n\n              default: //endregion\n\n            }\n          } //endregion\n          //region Check name constraints groupped by type, one-by-one\n\n\n          for (let p = 0; p < 5; p++) {\n            let groupPermitted = false;\n            let valueExists = false;\n            const group = constrGroups[p];\n\n            for (let j = 0; j < group.length; j++) {\n              switch (p) {\n                //region rfc822Name\n                case 0:\n                  if (subjectAltNames.length > 0) {\n                    for (let k = 0; k < subjectAltNames.length; k++) {\n                      if (subjectAltNames[k].type === 1) // rfc822Name\n                        {\n                          valueExists = true;\n                          groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[k].value, group[j].base.value);\n                        }\n                    }\n                  } else // Try to find out \"emailAddress\" inside \"subject\"\n                    {\n                      for (let k = 0; k < _this3.certs[i].subject.typesAndValues.length; k++) {\n                        if (_this3.certs[i].subject.typesAndValues[k].type === \"1.2.840.113549.1.9.1\" || // PKCS#9 e-mail address\n                        _this3.certs[i].subject.typesAndValues[k].type === \"0.9.2342.19200300.100.1.3\") // RFC1274 \"rfc822Mailbox\" e-mail address\n                          {\n                            valueExists = true;\n                            groupPermitted = groupPermitted || compareRFC822Name(_this3.certs[i].subject.typesAndValues[k].value.valueBlock.value, group[j].base.value);\n                          }\n                      }\n                    }\n\n                  break;\n                //endregion\n                //region dNSName\n\n                case 1:\n                  if (subjectAltNames.length > 0) {\n                    for (let k = 0; k < subjectAltNames.length; k++) {\n                      if (subjectAltNames[k].type === 2) // dNSName\n                        {\n                          valueExists = true;\n                          groupPermitted = groupPermitted || compareDNSName(subjectAltNames[k].value, group[j].base.value);\n                        }\n                    }\n                  }\n\n                  break;\n                //endregion\n                //region directoryName\n\n                case 2:\n                  valueExists = true;\n                  groupPermitted = compareDirectoryName(_this3.certs[i].subject, group[j].base.value);\n                  break;\n                //endregion\n                //region uniformResourceIdentifier\n\n                case 3:\n                  if (subjectAltNames.length > 0) {\n                    for (let k = 0; k < subjectAltNames.length; k++) {\n                      if (subjectAltNames[k].type === 6) // uniformResourceIdentifier\n                        {\n                          valueExists = true;\n                          groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[k].value, group[j].base.value);\n                        }\n                    }\n                  }\n\n                  break;\n                //endregion\n                //region iPAddress\n\n                case 4:\n                  if (subjectAltNames.length > 0) {\n                    for (let k = 0; k < subjectAltNames.length; k++) {\n                      if (subjectAltNames[k].type === 7) // iPAddress\n                        {\n                          valueExists = true;\n                          groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[k].value, group[j].base.value);\n                        }\n                    }\n                  }\n\n                  break;\n                //endregion\n                //region default\n\n                default: //endregion\n\n              }\n\n              if (groupPermitted) break;\n            }\n\n            if (groupPermitted === false && group.length > 0 && valueExists) {\n              policyResult.result = false;\n              policyResult.resultCode = 41;\n              policyResult.resultMessage = \"Failed to meet \\\"permitted sub-trees\\\" name constraint\";\n              throw policyResult;\n            }\n          } //endregion\n          //endregion\n          //region Checking for \"excluded sub-trees\"\n\n\n          let excluded = false;\n\n          for (let j = 0; j < excludedSubtrees.length; j++) {\n            switch (excludedSubtrees[j].base.type) {\n              //region rfc822Name\n              case 1:\n                if (subjectAltNames.length >= 0) {\n                  for (let k = 0; k < subjectAltNames.length; k++) {\n                    if (subjectAltNames[k].type === 1) // rfc822Name\n                      excluded = excluded || compareRFC822Name(subjectAltNames[k].value, excludedSubtrees[j].base.value);\n                  }\n                } else // Try to find out \"emailAddress\" inside \"subject\"\n                  {\n                    for (let k = 0; k < _this3.certs[i].subject.typesAndValues.length; k++) {\n                      if (_this3.certs[i].subject.typesAndValues[k].type === \"1.2.840.113549.1.9.1\" || // PKCS#9 e-mail address\n                      _this3.certs[i].subject.typesAndValues[k].type === \"0.9.2342.19200300.100.1.3\") // RFC1274 \"rfc822Mailbox\" e-mail address\n                        excluded = excluded || compareRFC822Name(_this3.certs[i].subject.typesAndValues[k].value.valueBlock.value, excludedSubtrees[j].base.value);\n                    }\n                  }\n\n                break;\n              //endregion\n              //region dNSName\n\n              case 2:\n                if (subjectAltNames.length > 0) {\n                  for (let k = 0; k < subjectAltNames.length; k++) {\n                    if (subjectAltNames[k].type === 2) // dNSName\n                      excluded = excluded || compareDNSName(subjectAltNames[k].value, excludedSubtrees[j].base.value);\n                  }\n                }\n\n                break;\n              //endregion\n              //region directoryName\n\n              case 4:\n                excluded = excluded || compareDirectoryName(_this3.certs[i].subject, excludedSubtrees[j].base.value);\n                break;\n              //endregion\n              //region uniformResourceIdentifier\n\n              case 6:\n                if (subjectAltNames.length > 0) {\n                  for (let k = 0; k < subjectAltNames.length; k++) {\n                    if (subjectAltNames[k].type === 6) // uniformResourceIdentifier\n                      excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[k].value, excludedSubtrees[j].base.value);\n                  }\n                }\n\n                break;\n              //endregion\n              //region iPAddress\n\n              case 7:\n                if (subjectAltNames.length > 0) {\n                  for (let k = 0; k < subjectAltNames.length; k++) {\n                    if (subjectAltNames[k].type === 7) // iPAddress\n                      excluded = excluded || compareIPAddress(subjectAltNames[k].value, excludedSubtrees[j].base.value);\n                  }\n                }\n\n                break;\n              //endregion\n              //region default\n\n              default: // No action, but probably here we need to create a warning for \"malformed constraint\"\n              //endregion\n\n            }\n\n            if (excluded) break;\n          }\n\n          if (excluded === true) {\n            policyResult.result = false;\n            policyResult.resultCode = 42;\n            policyResult.resultMessage = \"Failed to meet \\\"excluded sub-trees\\\" name constraint\";\n            throw policyResult;\n          } //endregion\n          //region Append \"cert_..._subtrees\" to \"..._subtrees\"\n\n\n          permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);\n          excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees); //endregion\n        } //endregion\n\n\n        return policyResult; //endregion\n      } catch (error) {\n        if (error instanceof Object) {\n          if (\"resultMessage\" in error) return error;\n\n          if (\"message\" in error) {\n            return {\n              result: false,\n              resultCode: -1,\n              resultMessage: error.message\n            };\n          }\n        }\n\n        return {\n          result: false,\n          resultCode: -1,\n          resultMessage: error\n        };\n      }\n    })();\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CertificateChainValidationEngine;\n//# sourceMappingURL=CertificateChainValidationEngine.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CertificateChainValidationEngine.js\n// module id = ./node_modules/pkijs/build/CertificateChainValidationEngine.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _PolicyInformation = _interopRequireDefault(require(\"./PolicyInformation.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass CertificatePolicies {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for CertificatePolicies class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<PolicyInformation>}\r\n     * @desc certificatePolicies\r\n     */\n    this.certificatePolicies = (0, _pvutils.getParametersValue)(parameters, \"certificatePolicies\", CertificatePolicies.defaultValues(\"certificatePolicies\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"certificatePolicies\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for CertificatePolicies class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * certificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [certificatePolicies]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.certificatePolicies || \"\",\n        value: _PolicyInformation.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"certificatePolicies\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, CertificatePolicies.schema({\n      names: {\n        certificatePolicies: \"certificatePolicies\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CertificatePolicies\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.certificatePolicies = Array.from(asn1.result.certificatePolicies, element => new _PolicyInformation.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.certificatePolicies, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      certificatePolicies: Array.from(this.certificatePolicies, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CertificatePolicies;\n//# sourceMappingURL=CertificatePolicies.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CertificatePolicies.js\n// module id = ./node_modules/pkijs/build/CertificatePolicies.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _RelativeDistinguishedNames = _interopRequireDefault(require(\"./RelativeDistinguishedNames.js\"));\n\nvar _Time = _interopRequireDefault(require(\"./Time.js\"));\n\nvar _RevokedCertificate = _interopRequireDefault(require(\"./RevokedCertificate.js\"));\n\nvar _Extensions = _interopRequireDefault(require(\"./Extensions.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\nfunction tbsCertList(parameters = {}) {\n  //TBSCertList  ::=  SEQUENCE  {\n  //    version                 Version OPTIONAL,\n  //                                 -- if present, MUST be v2\n  //    signature               AlgorithmIdentifier,\n  //    issuer                  Name,\n  //    thisUpdate              Time,\n  //    nextUpdate              Time OPTIONAL,\n  //    revokedCertificates     SEQUENCE OF SEQUENCE  {\n  //        userCertificate         CertificateSerialNumber,\n  //        revocationDate          Time,\n  //        crlEntryExtensions      Extensions OPTIONAL\n  //        -- if present, version MUST be v2\n  //    }  OPTIONAL,\n  //    crlExtensions           [0]  EXPLICIT Extensions OPTIONAL\n  //    -- if present, version MUST be v2\n  //}\n\n  /**\r\n   * @type {Object}\r\n   * @property {string} [blockName]\r\n   * @property {string} [tbsCertListVersion]\r\n   * @property {string} [signature]\r\n   * @property {string} [issuer]\r\n   * @property {string} [tbsCertListThisUpdate]\r\n   * @property {string} [tbsCertListNextUpdate]\r\n   * @property {string} [tbsCertListRevokedCertificates]\r\n   * @property {string} [crlExtensions]\r\n   */\n  const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n  return new asn1js.Sequence({\n    name: names.blockName || \"tbsCertList\",\n    value: [new asn1js.Integer({\n      optional: true,\n      name: names.tbsCertListVersion || \"tbsCertList.version\",\n      value: 2\n    }), // EXPLICIT integer value (v2)\n    _AlgorithmIdentifier.default.schema(names.signature || {\n      names: {\n        blockName: \"tbsCertList.signature\"\n      }\n    }), _RelativeDistinguishedNames.default.schema(names.issuer || {\n      names: {\n        blockName: \"tbsCertList.issuer\"\n      }\n    }), _Time.default.schema(names.tbsCertListThisUpdate || {\n      names: {\n        utcTimeName: \"tbsCertList.thisUpdate\",\n        generalTimeName: \"tbsCertList.thisUpdate\"\n      }\n    }), _Time.default.schema(names.tbsCertListNextUpdate || {\n      names: {\n        utcTimeName: \"tbsCertList.nextUpdate\",\n        generalTimeName: \"tbsCertList.nextUpdate\"\n      }\n    }, true), new asn1js.Sequence({\n      optional: true,\n      value: [new asn1js.Repeated({\n        name: names.tbsCertListRevokedCertificates || \"tbsCertList.revokedCertificates\",\n        value: new asn1js.Sequence({\n          value: [new asn1js.Integer(), _Time.default.schema(), _Extensions.default.schema({}, true)]\n        })\n      })]\n    }), new asn1js.Constructed({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 0 // [0]\n\n      },\n      value: [_Extensions.default.schema(names.crlExtensions || {\n        names: {\n          blockName: \"tbsCertList.extensions\"\n        }\n      })]\n    }) // EXPLICIT SEQUENCE value\n    ]\n  });\n} //**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\n\n\nclass CertificateRevocationList {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for Attribute class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc tbs\r\n     */\n    this.tbs = (0, _pvutils.getParametersValue)(parameters, \"tbs\", CertificateRevocationList.defaultValues(\"tbs\"));\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", CertificateRevocationList.defaultValues(\"version\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc signature\r\n     */\n\n    this.signature = (0, _pvutils.getParametersValue)(parameters, \"signature\", CertificateRevocationList.defaultValues(\"signature\"));\n    /**\r\n     * @type {RelativeDistinguishedNames}\r\n     * @desc issuer\r\n     */\n\n    this.issuer = (0, _pvutils.getParametersValue)(parameters, \"issuer\", CertificateRevocationList.defaultValues(\"issuer\"));\n    /**\r\n     * @type {Time}\r\n     * @desc thisUpdate\r\n     */\n\n    this.thisUpdate = (0, _pvutils.getParametersValue)(parameters, \"thisUpdate\", CertificateRevocationList.defaultValues(\"thisUpdate\"));\n    if (\"nextUpdate\" in parameters)\n      /**\r\n       * @type {Time}\r\n       * @desc nextUpdate\r\n       */\n      this.nextUpdate = (0, _pvutils.getParametersValue)(parameters, \"nextUpdate\", CertificateRevocationList.defaultValues(\"nextUpdate\"));\n    if (\"revokedCertificates\" in parameters)\n      /**\r\n       * @type {Array.<RevokedCertificate>}\r\n       * @desc revokedCertificates\r\n       */\n      this.revokedCertificates = (0, _pvutils.getParametersValue)(parameters, \"revokedCertificates\", CertificateRevocationList.defaultValues(\"revokedCertificates\"));\n    if (\"crlExtensions\" in parameters)\n      /**\r\n       * @type {Extensions}\r\n       * @desc crlExtensions\r\n       */\n      this.crlExtensions = (0, _pvutils.getParametersValue)(parameters, \"crlExtensions\", CertificateRevocationList.defaultValues(\"crlExtensions\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc signatureAlgorithm\r\n     */\n\n    this.signatureAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"signatureAlgorithm\", CertificateRevocationList.defaultValues(\"signatureAlgorithm\"));\n    /**\r\n     * @type {BitString}\r\n     * @desc signatureValue\r\n     */\n\n    this.signatureValue = (0, _pvutils.getParametersValue)(parameters, \"signatureValue\", CertificateRevocationList.defaultValues(\"signatureValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"tbs\":\n        return new ArrayBuffer(0);\n\n      case \"version\":\n        return 1;\n\n      case \"signature\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"issuer\":\n        return new _RelativeDistinguishedNames.default();\n\n      case \"thisUpdate\":\n        return new _Time.default();\n\n      case \"nextUpdate\":\n        return new _Time.default();\n\n      case \"revokedCertificates\":\n        return [];\n\n      case \"crlExtensions\":\n        return new _Extensions.default();\n\n      case \"signatureAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"signatureValue\":\n        return new asn1js.BitString();\n\n      default:\n        throw new Error(`Invalid member name for CertificateRevocationList class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * CertificateList  ::=  SEQUENCE  {\r\n   *    tbsCertList          TBSCertList,\r\n   *    signatureAlgorithm   AlgorithmIdentifier,\r\n   *    signatureValue       BIT STRING  }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [signatureAlgorithm]\r\n     * @property {string} [signatureValue]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"CertificateList\",\n      value: [tbsCertList(parameters), _AlgorithmIdentifier.default.schema(names.signatureAlgorithm || {\n        names: {\n          blockName: \"signatureAlgorithm\"\n        }\n      }), new asn1js.BitString({\n        name: names.signatureValue || \"signatureValue\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"tbsCertList\", \"tbsCertList.version\", \"tbsCertList.signature\", \"tbsCertList.issuer\", \"tbsCertList.thisUpdate\", \"tbsCertList.nextUpdate\", \"tbsCertList.revokedCertificates\", \"tbsCertList.extensions\", \"signatureAlgorithm\", \"signatureValue\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, CertificateRevocationList.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CertificateRevocationList\"); //endregion\n    //region Get internal properties from parsed schema\n    // noinspection JSUnresolvedVariable\n\n    this.tbs = asn1.result.tbsCertList.valueBeforeDecode;\n    if (\"tbsCertList.version\" in asn1.result) this.version = asn1.result[\"tbsCertList.version\"].valueBlock.valueDec;\n    this.signature = new _AlgorithmIdentifier.default({\n      schema: asn1.result[\"tbsCertList.signature\"]\n    });\n    this.issuer = new _RelativeDistinguishedNames.default({\n      schema: asn1.result[\"tbsCertList.issuer\"]\n    });\n    this.thisUpdate = new _Time.default({\n      schema: asn1.result[\"tbsCertList.thisUpdate\"]\n    });\n    if (\"tbsCertList.nextUpdate\" in asn1.result) this.nextUpdate = new _Time.default({\n      schema: asn1.result[\"tbsCertList.nextUpdate\"]\n    });\n    if (\"tbsCertList.revokedCertificates\" in asn1.result) this.revokedCertificates = Array.from(asn1.result[\"tbsCertList.revokedCertificates\"], element => new _RevokedCertificate.default({\n      schema: element\n    }));\n    if (\"tbsCertList.extensions\" in asn1.result) this.crlExtensions = new _Extensions.default({\n      schema: asn1.result[\"tbsCertList.extensions\"]\n    });\n    this.signatureAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.signatureAlgorithm\n    });\n    this.signatureValue = asn1.result.signatureValue; //endregion\n  } //**********************************************************************************\n\n\n  encodeTBS() {\n    //region Create array for output sequence\n    const outputArray = [];\n    if (this.version !== CertificateRevocationList.defaultValues(\"version\")) outputArray.push(new asn1js.Integer({\n      value: this.version\n    }));\n    outputArray.push(this.signature.toSchema());\n    outputArray.push(this.issuer.toSchema());\n    outputArray.push(this.thisUpdate.toSchema());\n    if (\"nextUpdate\" in this) outputArray.push(this.nextUpdate.toSchema());\n\n    if (\"revokedCertificates\" in this) {\n      outputArray.push(new asn1js.Sequence({\n        value: Array.from(this.revokedCertificates, element => element.toSchema())\n      }));\n    }\n\n    if (\"crlExtensions\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [this.crlExtensions.toSchema()]\n      }));\n    } //endregion\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema(encodeFlag = false) {\n    //region Decode stored TBS value\n    let tbsSchema;\n\n    if (encodeFlag === false) {\n      if (this.tbs.length === 0) // No stored TBS part\n        return CertificateRevocationList.schema();\n      tbsSchema = asn1js.fromBER(this.tbs).result;\n    } //endregion\n    //region Create TBS schema via assembling from TBS parts\n    else tbsSchema = this.encodeTBS(); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: [tbsSchema, this.signatureAlgorithm.toSchema(), this.signatureValue]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      tbs: (0, _pvutils.bufferToHexCodes)(this.tbs, 0, this.tbs.byteLength),\n      signature: this.signature.toJSON(),\n      issuer: this.issuer.toJSON(),\n      thisUpdate: this.thisUpdate.toJSON(),\n      signatureAlgorithm: this.signatureAlgorithm.toJSON(),\n      signatureValue: this.signatureValue.toJSON()\n    };\n    if (this.version !== CertificateRevocationList.defaultValues(\"version\")) object.version = this.version;\n    if (\"nextUpdate\" in this) object.nextUpdate = this.nextUpdate.toJSON();\n    if (\"revokedCertificates\" in this) object.revokedCertificates = Array.from(this.revokedCertificates, element => element.toJSON());\n    if (\"crlExtensions\" in this) object.crlExtensions = this.crlExtensions.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n  isCertificateRevoked(certificate) {\n    //region Check that issuer of the input certificate is the same with issuer of this CRL\n    if (this.issuer.isEqual(certificate.issuer) === false) return false; //endregion\n    //region Check that there are revoked certificates in this CRL\n\n    if (\"revokedCertificates\" in this === false) return false; //endregion\n    //region Search for input certificate in revoked certificates array\n\n    var _iterator = _createForOfIteratorHelper(this.revokedCertificates),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const revokedCertificate = _step.value;\n        if (revokedCertificate.userCertificate.isEqual(certificate.serialNumber)) return true;\n      } //endregion\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return false;\n  } //**********************************************************************************\n\n  /**\r\n   * Make a signature for existing CRL data\r\n   * @param {Object} privateKey Private key for \"subjectPublicKeyInfo\" structure\r\n   * @param {string} [hashAlgorithm] Hashing algorithm. Default SHA-1\r\n   */\n\n\n  sign(privateKey, hashAlgorithm = \"SHA-1\") {\n    //region Initial checking\n    //region Get a private key from function parameter\n    if (typeof privateKey === \"undefined\") return Promise.reject(\"Need to provide a private key for signing\"); //endregion\n    //endregion\n    //region Initial variables\n\n    let sequence = Promise.resolve();\n    let parameters;\n    const engine = (0, _common.getEngine)(); //endregion\n    //region Get a \"default parameters\" for current algorithm and set correct signature algorithm\n\n    sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));\n    sequence = sequence.then(result => {\n      parameters = result.parameters;\n      this.signature = result.signatureAlgorithm;\n      this.signatureAlgorithm = result.signatureAlgorithm;\n    }); //endregion\n    //region Create TBS data for signing\n\n    sequence = sequence.then(() => {\n      this.tbs = this.encodeTBS().toBER(false);\n    }); //endregion\n    //region Signing TBS data on provided private key\n\n    sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));\n    sequence = sequence.then(result => {\n      this.signatureValue = new asn1js.BitString({\n        valueHex: result\n      });\n    }); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Verify existing signature\r\n   * @param {{[issuerCertificate]: Object, [publicKeyInfo]: Object}} parameters\r\n   * @returns {*}\r\n   */\n\n\n  verify(parameters = {}) {\n    //region Global variables\n    let sequence = Promise.resolve();\n    let subjectPublicKeyInfo = -1;\n    const engine = (0, _common.getEngine)(); //endregion\n    //region Get information about CRL issuer certificate\n\n    if (\"issuerCertificate\" in parameters) // \"issuerCertificate\" must be of type \"Certificate\"\n      {\n        subjectPublicKeyInfo = parameters.issuerCertificate.subjectPublicKeyInfo; // The CRL issuer name and \"issuerCertificate\" subject name are not equal\n\n        if (this.issuer.isEqual(parameters.issuerCertificate.subject) === false) return Promise.resolve(false);\n      } //region In case if there is only public key during verification\n\n\n    if (\"publicKeyInfo\" in parameters) subjectPublicKeyInfo = parameters.publicKeyInfo; // Must be of type \"PublicKeyInfo\"\n    //endregion\n\n    if (\"subjectPublicKey\" in subjectPublicKeyInfo === false) return Promise.reject(\"Issuer's certificate must be provided as an input parameter\"); //endregion\n    //region Check the CRL for unknown critical extensions\n\n    if (\"crlExtensions\" in this) {\n      var _iterator2 = _createForOfIteratorHelper(this.crlExtensions.extensions),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          const extension = _step2.value;\n\n          if (extension.critical) {\n            // We can not be sure that unknown extension has no value for CRL signature\n            if (\"parsedValue\" in extension === false) return Promise.resolve(false);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } //endregion\n\n\n    sequence = sequence.then(() => engine.subtle.verifyWithPublicKey(this.tbs, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm));\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CertificateRevocationList;\n//# sourceMappingURL=CertificateRevocationList.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CertificateRevocationList.js\n// module id = ./node_modules/pkijs/build/CertificateRevocationList.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _Certificate = _interopRequireDefault(require(\"./Certificate.js\"));\n\nvar _AttributeCertificateV = _interopRequireDefault(require(\"./AttributeCertificateV1.js\"));\n\nvar _AttributeCertificateV2 = _interopRequireDefault(require(\"./AttributeCertificateV2.js\"));\n\nvar _OtherCertificateFormat = _interopRequireDefault(require(\"./OtherCertificateFormat.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass CertificateSet {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for CertificateSet class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array}\r\n     * @desc certificates\r\n     */\n    this.certificates = (0, _pvutils.getParametersValue)(parameters, \"certificates\", CertificateSet.defaultValues(\"certificates\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"certificates\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for Attribute class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * CertificateSet ::= SET OF CertificateChoices\r\n   *\r\n   * CertificateChoices ::= CHOICE {\r\n   *    certificate Certificate,\r\n   *    extendedCertificate [0] IMPLICIT ExtendedCertificate,  -- Obsolete\r\n   *    v1AttrCert [1] IMPLICIT AttributeCertificateV1,        -- Obsolete\r\n   *    v2AttrCert [2] IMPLICIT AttributeCertificateV2,\r\n   *    other [3] IMPLICIT OtherCertificateFormat }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Set({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.certificates || \"certificates\",\n        value: new asn1js.Choice({\n          value: [_Certificate.default.schema(), new asn1js.Constructed({\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 0 // [0]\n\n            },\n            value: [new asn1js.Any()]\n          }), // JUST A STUB\n          new asn1js.Constructed({\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 1 // [1]\n\n            },\n            value: _AttributeCertificateV.default.schema().valueBlock.value\n          }), new asn1js.Constructed({\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 2 // [2]\n\n            },\n            value: _AttributeCertificateV2.default.schema().valueBlock.value\n          }), new asn1js.Constructed({\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 3 // [3]\n\n            },\n            value: _OtherCertificateFormat.default.schema().valueBlock.value\n          })]\n        })\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"certificates\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, CertificateSet.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CertificateSet\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.certificates = Array.from(asn1.result.certificates || [], element => {\n      const initialTagNumber = element.idBlock.tagNumber;\n      if (element.idBlock.tagClass === 1) return new _Certificate.default({\n        schema: element\n      }); //region Making \"Sequence\" from \"Constructed\" value\n\n      const elementSequence = new asn1js.Sequence({\n        value: element.valueBlock.value\n      }); //endregion\n\n      switch (initialTagNumber) {\n        case 1:\n          return new _AttributeCertificateV.default({\n            schema: elementSequence\n          });\n\n        case 2:\n          return new _AttributeCertificateV2.default({\n            schema: elementSequence\n          });\n\n        case 3:\n          return new _OtherCertificateFormat.default({\n            schema: elementSequence\n          });\n\n        case 0:\n        default:\n      }\n\n      return element;\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Set({\n      value: Array.from(this.certificates, element => {\n        switch (true) {\n          case element instanceof _Certificate.default:\n            return element.toSchema();\n\n          case element instanceof _AttributeCertificateV.default:\n            return new asn1js.Constructed({\n              idBlock: {\n                tagClass: 3,\n                tagNumber: 1 // [1]\n\n              },\n              value: element.toSchema().valueBlock.value\n            });\n\n          case element instanceof _AttributeCertificateV2.default:\n            return new asn1js.Constructed({\n              idBlock: {\n                tagClass: 3,\n                tagNumber: 2 // [2]\n\n              },\n              value: element.toSchema().valueBlock.value\n            });\n\n          case element instanceof _OtherCertificateFormat.default:\n            return new asn1js.Constructed({\n              idBlock: {\n                tagClass: 3,\n                tagNumber: 3 // [3]\n\n              },\n              value: element.toSchema().valueBlock.value\n            });\n\n          default:\n        }\n\n        return element;\n      })\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      certificates: Array.from(this.certificates, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CertificateSet;\n//# sourceMappingURL=CertificateSet.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CertificateSet.js\n// module id = ./node_modules/pkijs/build/CertificateSet.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from \"[MS-WCCE]: Windows Client Certificate Enrollment Protocol\"\r\n */\nclass CertificateTemplate {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for CertificateTemplate class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc templateID\r\n     */\n    this.templateID = (0, _pvutils.getParametersValue)(parameters, \"templateID\", CertificateTemplate.defaultValues(\"templateID\"));\n    if (\"templateMajorVersion\" in parameters)\n      /**\r\n       * @type {number}\r\n       * @desc templateMajorVersion\r\n       */\n      this.templateMajorVersion = (0, _pvutils.getParametersValue)(parameters, \"templateMajorVersion\", CertificateTemplate.defaultValues(\"templateMajorVersion\"));\n    if (\"templateMinorVersion\" in parameters)\n      /**\r\n       * @type {number}\r\n       * @desc templateMinorVersion\r\n       */\n      this.templateMinorVersion = (0, _pvutils.getParametersValue)(parameters, \"templateMinorVersion\", CertificateTemplate.defaultValues(\"templateMinorVersion\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"templateID\":\n        return \"\";\n\n      case \"templateMajorVersion\":\n      case \"templateMinorVersion\":\n        return 0;\n\n      default:\n        throw new Error(`Invalid member name for CertificateTemplate class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * CertificateTemplateOID ::= SEQUENCE {\r\n      *    templateID              OBJECT IDENTIFIER,\r\n      *    templateMajorVersion    INTEGER (0..4294967295) OPTIONAL,\r\n      *    templateMinorVersion    INTEGER (0..4294967295) OPTIONAL\r\n      * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [templateID]\r\n     * @property {string} [templateMajorVersion]\r\n     * @property {string} [templateMinorVersion]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.templateID || \"\"\n      }), new asn1js.Integer({\n        name: names.templateMajorVersion || \"\",\n        optional: true\n      }), new asn1js.Integer({\n        name: names.templateMinorVersion || \"\",\n        optional: true\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"templateID\", \"templateMajorVersion\", \"templateMinorVersion\"]); //endregion\n    //region Check the schema is valid\n\n    let asn1 = asn1js.compareSchema(schema, schema, CertificateTemplate.schema({\n      names: {\n        templateID: \"templateID\",\n        templateMajorVersion: \"templateMajorVersion\",\n        templateMinorVersion: \"templateMinorVersion\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CertificateTemplate\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.templateID = asn1.result.templateID.valueBlock.toString();\n    if (\"templateMajorVersion\" in asn1.result) this.templateMajorVersion = asn1.result.templateMajorVersion.valueBlock.valueDec;\n    if (\"templateMinorVersion\" in asn1.result) this.templateMinorVersion = asn1.result.templateMinorVersion.valueBlock.valueDec; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.ObjectIdentifier({\n      value: this.templateID\n    }));\n    if (\"templateMajorVersion\" in this) outputArray.push(new asn1js.Integer({\n      value: this.templateMajorVersion\n    }));\n    if (\"templateMinorVersion\" in this) outputArray.push(new asn1js.Integer({\n      value: this.templateMinorVersion\n    })); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      extnID: this.templateID\n    };\n    if (\"templateMajorVersion\" in this) object.templateMajorVersion = this.templateMajorVersion;\n    if (\"templateMinorVersion\" in this) object.templateMinorVersion = this.templateMinorVersion;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CertificateTemplate;\n//# sourceMappingURL=CertificateTemplate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CertificateTemplate.js\n// module id = ./node_modules/pkijs/build/CertificateTemplate.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _PublicKeyInfo = _interopRequireDefault(require(\"./PublicKeyInfo.js\"));\n\nvar _RelativeDistinguishedNames = _interopRequireDefault(require(\"./RelativeDistinguishedNames.js\"));\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _Attribute = _interopRequireDefault(require(\"./Attribute.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\nfunction CertificationRequestInfo(parameters = {}) {\n  //CertificationRequestInfo ::= SEQUENCE {\n  //    version       INTEGER { v1(0) } (v1,...),\n  //    subject       Name,\n  //    subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},\n  //    attributes    [0] Attributes{{ CRIAttributes }}\n  //}\n\n  /**\r\n   * @type {Object}\r\n   * @property {string} [blockName]\r\n   * @property {string} [CertificationRequestInfo]\r\n   * @property {string} [CertificationRequestInfoVersion]\r\n   * @property {string} [subject]\r\n   * @property {string} [CertificationRequestInfoAttributes]\r\n   * @property {string} [attributes]\r\n   */\n  const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n  return new asn1js.Sequence({\n    name: names.CertificationRequestInfo || \"CertificationRequestInfo\",\n    value: [new asn1js.Integer({\n      name: names.CertificationRequestInfoVersion || \"CertificationRequestInfo.version\"\n    }), _RelativeDistinguishedNames.default.schema(names.subject || {\n      names: {\n        blockName: \"CertificationRequestInfo.subject\"\n      }\n    }), _PublicKeyInfo.default.schema({\n      names: {\n        blockName: \"CertificationRequestInfo.subjectPublicKeyInfo\"\n      }\n    }), new asn1js.Constructed({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 0 // [0]\n\n      },\n      value: [new asn1js.Repeated({\n        optional: true,\n        // Because OpenSSL makes wrong \"attributes\" field\n        name: names.CertificationRequestInfoAttributes || \"CertificationRequestInfo.attributes\",\n        value: _Attribute.default.schema(names.attributes || {})\n      })]\n    })]\n  });\n} //**************************************************************************************\n\n/**\r\n * Class from RFC2986\r\n */\n\n\nclass CertificationRequest {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for Attribute class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc tbs\r\n     */\n    this.tbs = (0, _pvutils.getParametersValue)(parameters, \"tbs\", CertificationRequest.defaultValues(\"tbs\"));\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", CertificationRequest.defaultValues(\"version\"));\n    /**\r\n     * @type {RelativeDistinguishedNames}\r\n     * @desc subject\r\n     */\n\n    this.subject = (0, _pvutils.getParametersValue)(parameters, \"subject\", CertificationRequest.defaultValues(\"subject\"));\n    /**\r\n     * @type {PublicKeyInfo}\r\n     * @desc subjectPublicKeyInfo\r\n     */\n\n    this.subjectPublicKeyInfo = (0, _pvutils.getParametersValue)(parameters, \"subjectPublicKeyInfo\", CertificationRequest.defaultValues(\"subjectPublicKeyInfo\"));\n    if (\"attributes\" in parameters)\n      /**\r\n       * @type {Array.<Attribute>}\r\n       * @desc attributes\r\n       */\n      this.attributes = (0, _pvutils.getParametersValue)(parameters, \"attributes\", CertificationRequest.defaultValues(\"attributes\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc signatureAlgorithm\r\n     */\n\n    this.signatureAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"signatureAlgorithm\", CertificationRequest.defaultValues(\"signatureAlgorithm\"));\n    /**\r\n     * @type {BitString}\r\n     * @desc signatureAlgorithm\r\n     */\n\n    this.signatureValue = (0, _pvutils.getParametersValue)(parameters, \"signatureValue\", CertificationRequest.defaultValues(\"signatureValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"tbs\":\n        return new ArrayBuffer(0);\n\n      case \"version\":\n        return 0;\n\n      case \"subject\":\n        return new _RelativeDistinguishedNames.default();\n\n      case \"subjectPublicKeyInfo\":\n        return new _PublicKeyInfo.default();\n\n      case \"attributes\":\n        return [];\n\n      case \"signatureAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"signatureValue\":\n        return new asn1js.BitString();\n\n      default:\n        throw new Error(`Invalid member name for CertificationRequest class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * CertificationRequest ::= SEQUENCE {\r\n   *    certificationRequestInfo CertificationRequestInfo,\r\n   *    signatureAlgorithm       AlgorithmIdentifier{{ SignatureAlgorithms }},\r\n   *    signature                BIT STRING\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [certificationRequestInfo]\r\n     * @property {string} [signatureAlgorithm]\r\n     * @property {string} [signatureValue]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      value: [CertificationRequestInfo(names.certificationRequestInfo || {}), new asn1js.Sequence({\n        name: names.signatureAlgorithm || \"signatureAlgorithm\",\n        value: [new asn1js.ObjectIdentifier(), new asn1js.Any({\n          optional: true\n        })]\n      }), new asn1js.BitString({\n        name: names.signatureValue || \"signatureValue\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"CertificationRequestInfo\", \"CertificationRequestInfo.version\", \"CertificationRequestInfo.subject\", \"CertificationRequestInfo.subjectPublicKeyInfo\", \"CertificationRequestInfo.attributes\", \"signatureAlgorithm\", \"signatureValue\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, CertificationRequest.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CertificationRequest\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.tbs = asn1.result.CertificationRequestInfo.valueBeforeDecode;\n    this.version = asn1.result[\"CertificationRequestInfo.version\"].valueBlock.valueDec;\n    this.subject = new _RelativeDistinguishedNames.default({\n      schema: asn1.result[\"CertificationRequestInfo.subject\"]\n    });\n    this.subjectPublicKeyInfo = new _PublicKeyInfo.default({\n      schema: asn1.result[\"CertificationRequestInfo.subjectPublicKeyInfo\"]\n    });\n    if (\"CertificationRequestInfo.attributes\" in asn1.result) this.attributes = Array.from(asn1.result[\"CertificationRequestInfo.attributes\"], element => new _Attribute.default({\n      schema: element\n    }));\n    this.signatureAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.signatureAlgorithm\n    });\n    this.signatureValue = asn1.result.signatureValue; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function making ASN1js Sequence from current TBS\r\n   * @returns {Sequence}\r\n   */\n\n\n  encodeTBS() {\n    //region Create array for output sequence\n    const outputArray = [new asn1js.Integer({\n      value: this.version\n    }), this.subject.toSchema(), this.subjectPublicKeyInfo.toSchema()];\n\n    if (\"attributes\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: Array.from(this.attributes, element => element.toSchema())\n      }));\n    } //endregion\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema(encodeFlag = false) {\n    //region Decode stored TBS value\n    let tbsSchema;\n\n    if (encodeFlag === false) {\n      if (this.tbs.byteLength === 0) // No stored TBS part\n        return CertificationRequest.schema();\n      tbsSchema = asn1js.fromBER(this.tbs).result;\n    } //endregion\n    //region Create TBS schema via assembling from TBS parts\n    else tbsSchema = this.encodeTBS(); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: [tbsSchema, this.signatureAlgorithm.toSchema(), this.signatureValue]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      tbs: (0, _pvutils.bufferToHexCodes)(this.tbs, 0, this.tbs.byteLength),\n      version: this.version,\n      subject: this.subject.toJSON(),\n      subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),\n      signatureAlgorithm: this.signatureAlgorithm.toJSON(),\n      signatureValue: this.signatureValue.toJSON()\n    };\n    if (\"attributes\" in this) object.attributes = Array.from(this.attributes, element => element.toJSON());\n    return object;\n  } //**********************************************************************************\n\n  /**\r\n   * Makes signature for currect certification request\r\n   * @param {Object} privateKey WebCrypto private key\r\n   * @param {string} [hashAlgorithm=SHA-1] String representing current hashing algorithm\r\n   */\n\n\n  sign(privateKey, hashAlgorithm = \"SHA-1\") {\n    //region Initial checking\n    //region Get a private key from function parameter\n    if (typeof privateKey === \"undefined\") return Promise.reject(\"Need to provide a private key for signing\"); //endregion\n    //endregion\n    //region Initial variables\n\n    let sequence = Promise.resolve();\n    let parameters;\n    const engine = (0, _common.getEngine)(); //endregion\n    //region Get a \"default parameters\" for current algorithm and set correct signature algorithm\n\n    sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));\n    sequence = sequence.then(result => {\n      parameters = result.parameters;\n      this.signatureAlgorithm = result.signatureAlgorithm;\n    }); //endregion\n    //region Create TBS data for signing\n\n    sequence = sequence.then(() => {\n      this.tbs = this.encodeTBS().toBER(false);\n    }); //endregion\n    //region Signing TBS data on provided private key\n\n    sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));\n    sequence = sequence.then(result => {\n      this.signatureValue = new asn1js.BitString({\n        valueHex: result\n      });\n    }); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Verify existing certification request signature\r\n   * @returns {*}\r\n   */\n\n\n  verify() {\n    return (0, _common.getEngine)().subtle.verifyWithPublicKey(this.tbs, this.signatureValue, this.subjectPublicKeyInfo, this.signatureAlgorithm);\n  } //**********************************************************************************\n\n  /**\r\n   * Importing public key for current certificate request\r\n   */\n\n\n  getPublicKey(parameters = null) {\n    return (0, _common.getEngine)().getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CertificationRequest;\n//# sourceMappingURL=CertificationRequest.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CertificationRequest.js\n// module id = ./node_modules/pkijs/build/CertificationRequest.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass ContentInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for ContentInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc contentType\r\n     */\n    this.contentType = (0, _pvutils.getParametersValue)(parameters, \"contentType\", ContentInfo.defaultValues(\"contentType\"));\n    /**\r\n     * @type {Any}\r\n     * @desc content\r\n     */\n\n    this.content = (0, _pvutils.getParametersValue)(parameters, \"content\", ContentInfo.defaultValues(\"content\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"contentType\":\n        return \"\";\n\n      case \"content\":\n        return new asn1js.Any();\n\n      default:\n        throw new Error(`Invalid member name for ContentInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"contentType\":\n        return memberValue === \"\";\n\n      case \"content\":\n        return memberValue instanceof asn1js.Any;\n\n      default:\n        throw new Error(`Invalid member name for ContentInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * ContentInfo ::= SEQUENCE {\r\n   *    contentType ContentType,\r\n   *    content [0] EXPLICIT ANY DEFINED BY contentType }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [contentType]\r\n     * @property {string} [content]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    if (\"optional\" in names === false) names.optional = false;\n    return new asn1js.Sequence({\n      name: names.blockName || \"ContentInfo\",\n      optional: names.optional,\n      value: [new asn1js.ObjectIdentifier({\n        name: names.contentType || \"contentType\"\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Any({\n          name: names.content || \"content\"\n        })] // EXPLICIT ANY value\n\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"contentType\", \"content\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, ContentInfo.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for ContentInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.contentType = asn1.result.contentType.valueBlock.toString();\n    this.content = asn1.result.content; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.contentType\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [this.content] // EXPLICIT ANY value\n\n      })]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      contentType: this.contentType\n    };\n    if (!(this.content instanceof asn1js.Any)) object.content = this.content.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = ContentInfo;\n//# sourceMappingURL=ContentInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/ContentInfo.js\n// module id = ./node_modules/pkijs/build/ContentInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _PublicKeyInfo = _interopRequireDefault(require(\"./PublicKeyInfo.js\"));\n\nvar _PrivateKeyInfo = _interopRequireDefault(require(\"./PrivateKeyInfo.js\"));\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _EncryptedContentInfo = _interopRequireDefault(require(\"./EncryptedContentInfo.js\"));\n\nvar _RSASSAPSSParams = _interopRequireDefault(require(\"./RSASSAPSSParams.js\"));\n\nvar _PBKDF2Params = _interopRequireDefault(require(\"./PBKDF2Params.js\"));\n\nvar _PBES2Params = _interopRequireDefault(require(\"./PBES2Params.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\n\n/**\r\n * Making MAC key using algorithm described in B.2 of PKCS#12 standard.\r\n */\nfunction makePKCS12B2Key(cryptoEngine, hashAlgorithm, keyLength, password, salt, iterationCount) {\n  //region Initial variables\n  let u;\n  let v;\n  const result = []; //endregion\n  //region Get \"u\" and \"v\" values\n\n  switch (hashAlgorithm.toUpperCase()) {\n    case \"SHA-1\":\n      u = 20; // 160\n\n      v = 64; // 512\n\n      break;\n\n    case \"SHA-256\":\n      u = 32; // 256\n\n      v = 64; // 512\n\n      break;\n\n    case \"SHA-384\":\n      u = 48; // 384\n\n      v = 128; // 1024\n\n      break;\n\n    case \"SHA-512\":\n      u = 64; // 512\n\n      v = 128; // 1024\n\n      break;\n\n    default:\n      throw new Error(\"Unsupported hashing algorithm\");\n  } //endregion\n  //region Main algorithm making key\n  //region Transform password to UTF-8 like string\n\n\n  const passwordViewInitial = new Uint8Array(password);\n  const passwordTransformed = new ArrayBuffer(password.byteLength * 2 + 2);\n  const passwordTransformedView = new Uint8Array(passwordTransformed);\n\n  for (let i = 0; i < passwordViewInitial.length; i++) {\n    passwordTransformedView[i * 2] = 0x00;\n    passwordTransformedView[i * 2 + 1] = passwordViewInitial[i];\n  }\n\n  passwordTransformedView[passwordTransformedView.length - 2] = 0x00;\n  passwordTransformedView[passwordTransformedView.length - 1] = 0x00;\n  password = passwordTransformed.slice(0); //endregion\n  //region Construct a string D (the \"diversifier\") by concatenating v/8 copies of ID\n\n  const D = new ArrayBuffer(v);\n  const dView = new Uint8Array(D);\n\n  for (let i = 0; i < D.byteLength; i++) dView[i] = 3; // The ID value equal to \"3\" for MACing (see B.3 of standard)\n  //endregion\n  //region Concatenate copies of the salt together to create a string S of length v * ceil(s / v) bytes (the final copy of the salt may be trunacted to create S)\n\n\n  const saltLength = salt.byteLength;\n  const sLen = v * Math.ceil(saltLength / v);\n  const S = new ArrayBuffer(sLen);\n  const sView = new Uint8Array(S);\n  const saltView = new Uint8Array(salt);\n\n  for (let i = 0; i < sLen; i++) sView[i] = saltView[i % saltLength]; //endregion\n  //region Concatenate copies of the password together to create a string P of length v * ceil(p / v) bytes (the final copy of the password may be truncated to create P)\n\n\n  const passwordLength = password.byteLength;\n  const pLen = v * Math.ceil(passwordLength / v);\n  const P = new ArrayBuffer(pLen);\n  const pView = new Uint8Array(P);\n  const passwordView = new Uint8Array(password);\n\n  for (let i = 0; i < pLen; i++) pView[i] = passwordView[i % passwordLength]; //endregion\n  //region Set I=S||P to be the concatenation of S and P\n\n\n  const sPlusPLength = S.byteLength + P.byteLength;\n  let I = new ArrayBuffer(sPlusPLength);\n  let iView = new Uint8Array(I);\n  iView.set(sView);\n  iView.set(pView, sView.length); //endregion\n  //region Set c=ceil(n / u)\n\n  const c = Math.ceil((keyLength >> 3) / u); //endregion\n  //region Initial variables\n\n  let internalSequence = Promise.resolve(I); //endregion\n  //region For i=1, 2, ..., c, do the following:\n\n  for (let i = 0; i <= c; i++) {\n    internalSequence = internalSequence.then(_I => {\n      //region Create contecanetion of D and I\n      const dAndI = new ArrayBuffer(D.byteLength + _I.byteLength);\n      const dAndIView = new Uint8Array(dAndI);\n      dAndIView.set(dView);\n      dAndIView.set(iView, dView.length); //endregion\n\n      return dAndI;\n    }); //region Make \"iterationCount\" rounds of hashing\n\n    for (let j = 0; j < iterationCount; j++) internalSequence = internalSequence.then(roundBuffer => cryptoEngine.digest({\n      name: hashAlgorithm\n    }, new Uint8Array(roundBuffer))); //endregion\n\n\n    internalSequence = internalSequence.then(roundBuffer => {\n      //region Concatenate copies of Ai to create a string B of length v bits (the final copy of Ai may be truncated to create B)\n      const B = new ArrayBuffer(v);\n      const bView = new Uint8Array(B);\n\n      for (let j = 0; j < B.byteLength; j++) bView[j] = roundBuffer[j % roundBuffer.length]; //endregion\n      //region Make new I value\n\n\n      const k = Math.ceil(saltLength / v) + Math.ceil(passwordLength / v);\n      const iRound = [];\n      let sliceStart = 0;\n      let sliceLength = v;\n\n      for (let j = 0; j < k; j++) {\n        const chunk = Array.from(new Uint8Array(I.slice(sliceStart, sliceStart + sliceLength)));\n        sliceStart += v;\n        if (sliceStart + v > I.byteLength) sliceLength = I.byteLength - sliceStart;\n        let x = 0x1ff;\n\n        for (let l = B.byteLength - 1; l >= 0; l--) {\n          x >>= 8;\n          x += bView[l] + chunk[l];\n          chunk[l] = x & 0xff;\n        }\n\n        iRound.push(...chunk);\n      }\n\n      I = new ArrayBuffer(iRound.length);\n      iView = new Uint8Array(I);\n      iView.set(iRound); //endregion\n\n      result.push(...new Uint8Array(roundBuffer));\n      return I;\n    });\n  } //endregion\n  //region Initialize final key\n\n\n  internalSequence = internalSequence.then(() => {\n    const resultBuffer = new ArrayBuffer(keyLength >> 3);\n    const resultView = new Uint8Array(resultBuffer);\n    resultView.set(new Uint8Array(result).slice(0, keyLength >> 3));\n    return resultBuffer;\n  }); //endregion\n  //endregion\n\n  return internalSequence;\n} //**************************************************************************************\n\n/**\r\n * Default cryptographic engine for Web Cryptography API\r\n */\n\n\nclass CryptoEngine {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for CryptoEngine class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Object}\r\n     * @desc Usually here we are expecting \"window.crypto\" or an equivalent from custom \"crypto engine\"\r\n     */\n    this.crypto = (0, _pvutils.getParametersValue)(parameters, \"crypto\", {});\n    /**\r\n     * @type {Object}\r\n     * @desc Usually here we are expecting \"window.crypto.subtle\" or an equivalent from custom \"crypto engine\"\r\n     */\n\n    this.subtle = (0, _pvutils.getParametersValue)(parameters, \"subtle\", {});\n    /**\r\n     * @type {string}\r\n     * @desc Name of the \"crypto engine\"\r\n     */\n\n    this.name = (0, _pvutils.getParametersValue)(parameters, \"name\", \"\"); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Import WebCrypto keys from different formats\r\n   * @param {string} format\r\n   * @param {ArrayBuffer|Uint8Array} keyData\r\n   * @param {Object} algorithm\r\n   * @param {boolean} extractable\r\n   * @param {Array} keyUsages\r\n   * @returns {Promise}\r\n   */\n\n\n  importKey(format, keyData, algorithm, extractable, keyUsages) {\n    //region Initial variables\n    let jwk = {}; //endregion\n    //region Change \"keyData\" type if needed\n\n    if (keyData instanceof Uint8Array) keyData = keyData.buffer; //endregion\n\n    switch (format.toLowerCase()) {\n      case \"raw\":\n        return this.subtle.importKey(\"raw\", keyData, algorithm, extractable, keyUsages);\n\n      case \"spki\":\n        {\n          const asn1 = asn1js.fromBER(keyData);\n          if (asn1.offset === -1) return Promise.reject(\"Incorrect keyData\");\n          const publicKeyInfo = new _PublicKeyInfo.default();\n\n          try {\n            publicKeyInfo.fromSchema(asn1.result);\n          } catch (ex) {\n            return Promise.reject(\"Incorrect keyData\");\n          } // noinspection FallThroughInSwitchStatementJS\n\n\n          switch (algorithm.name.toUpperCase()) {\n            case \"RSA-PSS\":\n              {\n                //region Get information about used hash function\n                switch (algorithm.hash.name.toUpperCase()) {\n                  case \"SHA-1\":\n                    jwk.alg = \"PS1\";\n                    break;\n\n                  case \"SHA-256\":\n                    jwk.alg = \"PS256\";\n                    break;\n\n                  case \"SHA-384\":\n                    jwk.alg = \"PS384\";\n                    break;\n\n                  case \"SHA-512\":\n                    jwk.alg = \"PS512\";\n                    break;\n\n                  default:\n                    return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);\n                } //endregion\n\n              }\n            // break omitted\n\n            case \"RSASSA-PKCS1-V1_5\":\n              {\n                keyUsages = [\"verify\"]; // Override existing keyUsages value since the key is a public key\n\n                jwk.kty = \"RSA\";\n                jwk.ext = extractable;\n                jwk.key_ops = keyUsages;\n                if (publicKeyInfo.algorithm.algorithmId !== \"1.2.840.113549.1.1.1\") return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`); //region Get information about used hash function\n\n                if (\"alg\" in jwk === false) {\n                  switch (algorithm.hash.name.toUpperCase()) {\n                    case \"SHA-1\":\n                      jwk.alg = \"RS1\";\n                      break;\n\n                    case \"SHA-256\":\n                      jwk.alg = \"RS256\";\n                      break;\n\n                    case \"SHA-384\":\n                      jwk.alg = \"RS384\";\n                      break;\n\n                    case \"SHA-512\":\n                      jwk.alg = \"RS512\";\n                      break;\n\n                    default:\n                      return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);\n                  }\n                } //endregion\n                //region Create RSA Public Key elements\n\n\n                const publicKeyJSON = publicKeyInfo.toJSON();\n\n                for (var _i = 0, _Object$keys = Object.keys(publicKeyJSON); _i < _Object$keys.length; _i++) {\n                  const key = _Object$keys[_i];\n                  jwk[key] = publicKeyJSON[key];\n                } //endregion\n\n              }\n              break;\n\n            case \"ECDSA\":\n              keyUsages = [\"verify\"];\n            // Override existing keyUsages value since the key is a public key\n            // break omitted\n\n            case \"ECDH\":\n              {\n                //region Initial variables\n                jwk = {\n                  kty: \"EC\",\n                  ext: extractable,\n                  key_ops: keyUsages\n                }; //endregion\n                //region Get information about algorithm\n\n                if (publicKeyInfo.algorithm.algorithmId !== \"1.2.840.10045.2.1\") return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`); //endregion\n                //region Create ECDSA Public Key elements\n\n                const publicKeyJSON = publicKeyInfo.toJSON();\n\n                for (var _i2 = 0, _Object$keys2 = Object.keys(publicKeyJSON); _i2 < _Object$keys2.length; _i2++) {\n                  const key = _Object$keys2[_i2];\n                  jwk[key] = publicKeyJSON[key];\n                } //endregion\n\n              }\n              break;\n\n            case \"RSA-OAEP\":\n              {\n                jwk.kty = \"RSA\";\n                jwk.ext = extractable;\n                jwk.key_ops = keyUsages;\n                if (this.name.toLowerCase() === \"safari\") jwk.alg = \"RSA-OAEP\";else {\n                  switch (algorithm.hash.name.toUpperCase()) {\n                    case \"SHA-1\":\n                      jwk.alg = \"RSA-OAEP\";\n                      break;\n\n                    case \"SHA-256\":\n                      jwk.alg = \"RSA-OAEP-256\";\n                      break;\n\n                    case \"SHA-384\":\n                      jwk.alg = \"RSA-OAEP-384\";\n                      break;\n\n                    case \"SHA-512\":\n                      jwk.alg = \"RSA-OAEP-512\";\n                      break;\n\n                    default:\n                      return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);\n                  }\n                } //region Create ECDSA Public Key elements\n\n                const publicKeyJSON = publicKeyInfo.toJSON();\n\n                for (var _i3 = 0, _Object$keys3 = Object.keys(publicKeyJSON); _i3 < _Object$keys3.length; _i3++) {\n                  const key = _Object$keys3[_i3];\n                  jwk[key] = publicKeyJSON[key];\n                } //endregion\n\n              }\n              break;\n\n            case \"RSAES-PKCS1-V1_5\":\n              {\n                jwk.kty = \"RSA\";\n                jwk.ext = extractable;\n                jwk.key_ops = keyUsages;\n                jwk.alg = \"PS1\";\n                const publicKeyJSON = publicKeyInfo.toJSON();\n\n                for (var _i4 = 0, _Object$keys4 = Object.keys(publicKeyJSON); _i4 < _Object$keys4.length; _i4++) {\n                  const key = _Object$keys4[_i4];\n                  jwk[key] = publicKeyJSON[key];\n                }\n              }\n              break;\n\n            default:\n              return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);\n          }\n        }\n        break;\n\n      case \"pkcs8\":\n        {\n          const privateKeyInfo = new _PrivateKeyInfo.default(); //region Parse \"PrivateKeyInfo\" object\n\n          const asn1 = asn1js.fromBER(keyData);\n          if (asn1.offset === -1) return Promise.reject(\"Incorrect keyData\");\n\n          try {\n            privateKeyInfo.fromSchema(asn1.result);\n          } catch (ex) {\n            return Promise.reject(\"Incorrect keyData\");\n          }\n\n          if (\"parsedKey\" in privateKeyInfo === false) return Promise.reject(\"Incorrect keyData\"); //endregion\n          // noinspection FallThroughInSwitchStatementJS\n          // noinspection FallThroughInSwitchStatementJS\n\n          switch (algorithm.name.toUpperCase()) {\n            case \"RSA-PSS\":\n              {\n                //region Get information about used hash function\n                switch (algorithm.hash.name.toUpperCase()) {\n                  case \"SHA-1\":\n                    jwk.alg = \"PS1\";\n                    break;\n\n                  case \"SHA-256\":\n                    jwk.alg = \"PS256\";\n                    break;\n\n                  case \"SHA-384\":\n                    jwk.alg = \"PS384\";\n                    break;\n\n                  case \"SHA-512\":\n                    jwk.alg = \"PS512\";\n                    break;\n\n                  default:\n                    return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);\n                } //endregion\n\n              }\n            // break omitted\n\n            case \"RSASSA-PKCS1-V1_5\":\n              {\n                keyUsages = [\"sign\"]; // Override existing keyUsages value since the key is a private key\n\n                jwk.kty = \"RSA\";\n                jwk.ext = extractable;\n                jwk.key_ops = keyUsages; //region Get information about used hash function\n\n                if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== \"1.2.840.113549.1.1.1\") return Promise.reject(`Incorrect private key algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`); //endregion\n                //region Get information about used hash function\n\n                if (\"alg\" in jwk === false) {\n                  switch (algorithm.hash.name.toUpperCase()) {\n                    case \"SHA-1\":\n                      jwk.alg = \"RS1\";\n                      break;\n\n                    case \"SHA-256\":\n                      jwk.alg = \"RS256\";\n                      break;\n\n                    case \"SHA-384\":\n                      jwk.alg = \"RS384\";\n                      break;\n\n                    case \"SHA-512\":\n                      jwk.alg = \"RS512\";\n                      break;\n\n                    default:\n                      return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);\n                  }\n                } //endregion\n                //region Create RSA Private Key elements\n\n\n                const privateKeyJSON = privateKeyInfo.toJSON();\n\n                for (var _i5 = 0, _Object$keys5 = Object.keys(privateKeyJSON); _i5 < _Object$keys5.length; _i5++) {\n                  const key = _Object$keys5[_i5];\n                  jwk[key] = privateKeyJSON[key];\n                } //endregion\n\n              }\n              break;\n\n            case \"ECDSA\":\n              keyUsages = [\"sign\"];\n            // Override existing keyUsages value since the key is a private key\n            // break omitted\n\n            case \"ECDH\":\n              {\n                //region Initial variables\n                jwk = {\n                  kty: \"EC\",\n                  ext: extractable,\n                  key_ops: keyUsages\n                }; //endregion\n                //region Get information about used hash function\n\n                if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== \"1.2.840.10045.2.1\") return Promise.reject(`Incorrect algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`); //endregion\n                //region Create ECDSA Private Key elements\n\n                const privateKeyJSON = privateKeyInfo.toJSON();\n\n                for (var _i6 = 0, _Object$keys6 = Object.keys(privateKeyJSON); _i6 < _Object$keys6.length; _i6++) {\n                  const key = _Object$keys6[_i6];\n                  jwk[key] = privateKeyJSON[key];\n                } //endregion\n\n              }\n              break;\n\n            case \"RSA-OAEP\":\n              {\n                jwk.kty = \"RSA\";\n                jwk.ext = extractable;\n                jwk.key_ops = keyUsages; //region Get information about used hash function\n\n                if (this.name.toLowerCase() === \"safari\") jwk.alg = \"RSA-OAEP\";else {\n                  switch (algorithm.hash.name.toUpperCase()) {\n                    case \"SHA-1\":\n                      jwk.alg = \"RSA-OAEP\";\n                      break;\n\n                    case \"SHA-256\":\n                      jwk.alg = \"RSA-OAEP-256\";\n                      break;\n\n                    case \"SHA-384\":\n                      jwk.alg = \"RSA-OAEP-384\";\n                      break;\n\n                    case \"SHA-512\":\n                      jwk.alg = \"RSA-OAEP-512\";\n                      break;\n\n                    default:\n                      return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);\n                  }\n                } //endregion\n                //region Create RSA Private Key elements\n\n                const privateKeyJSON = privateKeyInfo.toJSON();\n\n                for (var _i7 = 0, _Object$keys7 = Object.keys(privateKeyJSON); _i7 < _Object$keys7.length; _i7++) {\n                  const key = _Object$keys7[_i7];\n                  jwk[key] = privateKeyJSON[key];\n                } //endregion\n\n              }\n              break;\n\n            case \"RSAES-PKCS1-V1_5\":\n              {\n                keyUsages = [\"decrypt\"]; // Override existing keyUsages value since the key is a private key\n\n                jwk.kty = \"RSA\";\n                jwk.ext = extractable;\n                jwk.key_ops = keyUsages;\n                jwk.alg = \"PS1\"; //region Create RSA Private Key elements\n\n                const privateKeyJSON = privateKeyInfo.toJSON();\n\n                for (var _i8 = 0, _Object$keys8 = Object.keys(privateKeyJSON); _i8 < _Object$keys8.length; _i8++) {\n                  const key = _Object$keys8[_i8];\n                  jwk[key] = privateKeyJSON[key];\n                } //endregion\n\n              }\n              break;\n\n            default:\n              return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);\n          }\n        }\n        break;\n\n      case \"jwk\":\n        jwk = keyData;\n        break;\n\n      default:\n        return Promise.reject(`Incorrect format: ${format}`);\n    } //region Special case for Safari browser (since its acting not as WebCrypto standard describes)\n\n\n    if (this.name.toLowerCase() === \"safari\") {\n      // Try to use both ways - import using ArrayBuffer and pure JWK (for Safari Technology Preview)\n      return Promise.resolve().then(() => this.subtle.importKey(\"jwk\", (0, _pvutils.stringToArrayBuffer)(JSON.stringify(jwk)), algorithm, extractable, keyUsages)).then(result => result, () => this.subtle.importKey(\"jwk\", jwk, algorithm, extractable, keyUsages));\n    } //endregion\n\n\n    return this.subtle.importKey(\"jwk\", jwk, algorithm, extractable, keyUsages);\n  } //**********************************************************************************\n\n  /**\r\n   * Export WebCrypto keys to different formats\r\n   * @param {string} format\r\n   * @param {Object} key\r\n   * @returns {Promise}\r\n   */\n\n\n  exportKey(format, key) {\n    let sequence = this.subtle.exportKey(\"jwk\", key); //region Currently Safari returns ArrayBuffer as JWK thus we need an additional transformation\n\n    if (this.name.toLowerCase() === \"safari\") {\n      sequence = sequence.then(result => {\n        // Some additional checks for Safari Technology Preview\n        if (result instanceof ArrayBuffer) return JSON.parse((0, _pvutils.arrayBufferToString)(result));\n        return result;\n      });\n    } //endregion\n\n\n    switch (format.toLowerCase()) {\n      case \"raw\":\n        return this.subtle.exportKey(\"raw\", key);\n\n      case \"spki\":\n        sequence = sequence.then(result => {\n          const publicKeyInfo = new _PublicKeyInfo.default();\n\n          try {\n            publicKeyInfo.fromJSON(result);\n          } catch (ex) {\n            return Promise.reject(\"Incorrect key data\");\n          }\n\n          return publicKeyInfo.toSchema().toBER(false);\n        });\n        break;\n\n      case \"pkcs8\":\n        sequence = sequence.then(result => {\n          const privateKeyInfo = new _PrivateKeyInfo.default();\n\n          try {\n            privateKeyInfo.fromJSON(result);\n          } catch (ex) {\n            return Promise.reject(\"Incorrect key data\");\n          }\n\n          return privateKeyInfo.toSchema().toBER(false);\n        });\n        break;\n\n      case \"jwk\":\n        break;\n\n      default:\n        return Promise.reject(`Incorrect format: ${format}`);\n    }\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert WebCrypto keys between different export formats\r\n   * @param {string} inputFormat\r\n   * @param {string} outputFormat\r\n   * @param {ArrayBuffer|Object} keyData\r\n   * @param {Object} algorithm\r\n   * @param {boolean} extractable\r\n   * @param {Array} keyUsages\r\n   * @returns {Promise}\r\n   */\n\n\n  convert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages) {\n    switch (inputFormat.toLowerCase()) {\n      case \"raw\":\n        switch (outputFormat.toLowerCase()) {\n          case \"raw\":\n            return Promise.resolve(keyData);\n\n          case \"spki\":\n            return Promise.resolve().then(() => this.importKey(\"raw\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"spki\", result));\n\n          case \"pkcs8\":\n            return Promise.resolve().then(() => this.importKey(\"raw\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"pkcs8\", result));\n\n          case \"jwk\":\n            return Promise.resolve().then(() => this.importKey(\"raw\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"jwk\", result));\n\n          default:\n            return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);\n        }\n\n      case \"spki\":\n        switch (outputFormat.toLowerCase()) {\n          case \"raw\":\n            return Promise.resolve().then(() => this.importKey(\"spki\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"raw\", result));\n\n          case \"spki\":\n            return Promise.resolve(keyData);\n\n          case \"pkcs8\":\n            return Promise.reject(\"Impossible to convert between SPKI/PKCS8\");\n\n          case \"jwk\":\n            return Promise.resolve().then(() => this.importKey(\"spki\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"jwk\", result));\n\n          default:\n            return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);\n        }\n\n      case \"pkcs8\":\n        switch (outputFormat.toLowerCase()) {\n          case \"raw\":\n            return Promise.resolve().then(() => this.importKey(\"pkcs8\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"raw\", result));\n\n          case \"spki\":\n            return Promise.reject(\"Impossible to convert between SPKI/PKCS8\");\n\n          case \"pkcs8\":\n            return Promise.resolve(keyData);\n\n          case \"jwk\":\n            return Promise.resolve().then(() => this.importKey(\"pkcs8\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"jwk\", result));\n\n          default:\n            return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);\n        }\n\n      case \"jwk\":\n        switch (outputFormat.toLowerCase()) {\n          case \"raw\":\n            return Promise.resolve().then(() => this.importKey(\"jwk\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"raw\", result));\n\n          case \"spki\":\n            return Promise.resolve().then(() => this.importKey(\"jwk\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"spki\", result));\n\n          case \"pkcs8\":\n            return Promise.resolve().then(() => this.importKey(\"jwk\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"pkcs8\", result));\n\n          case \"jwk\":\n            return Promise.resolve(keyData);\n\n          default:\n            return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);\n        }\n\n      default:\n        return Promise.reject(`Incorrect inputFormat: ${inputFormat}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Wrapper for standard function \"encrypt\"\r\n   * @param args\r\n   * @returns {Promise}\r\n   */\n\n\n  encrypt(...args) {\n    return this.subtle.encrypt(...args);\n  } //**********************************************************************************\n\n  /**\r\n   * Wrapper for standard function \"decrypt\"\r\n   * @param args\r\n   * @returns {Promise}\r\n   */\n\n\n  decrypt(...args) {\n    return this.subtle.decrypt(...args);\n  } //**********************************************************************************\n\n  /**\r\n   * Wrapper for standard function \"sign\"\r\n   * @param args\r\n   * @returns {Promise}\r\n   */\n\n\n  sign(...args) {\n    return this.subtle.sign(...args);\n  } //**********************************************************************************\n\n  /**\r\n   * Wrapper for standard function \"verify\"\r\n   * @param args\r\n   * @returns {Promise}\r\n   */\n\n\n  verify(...args) {\n    return this.subtle.verify(...args);\n  } //**********************************************************************************\n\n  /**\r\n   * Wrapper for standard function \"digest\"\r\n   * @param args\r\n   * @returns {Promise}\r\n   */\n\n\n  digest(...args) {\n    return this.subtle.digest(...args);\n  } //**********************************************************************************\n\n  /**\r\n   * Wrapper for standard function \"generateKey\"\r\n   * @param args\r\n   * @returns {Promise}\r\n   */\n\n\n  generateKey(...args) {\n    return this.subtle.generateKey(...args);\n  } //**********************************************************************************\n\n  /**\r\n   * Wrapper for standard function \"deriveKey\"\r\n   * @param args\r\n   * @returns {Promise}\r\n   */\n\n\n  deriveKey(...args) {\n    return this.subtle.deriveKey(...args);\n  } //**********************************************************************************\n\n  /**\r\n   * Wrapper for standard function \"deriveBits\"\r\n   * @param args\r\n   * @returns {Promise}\r\n   */\n\n\n  deriveBits(...args) {\n    return this.subtle.deriveBits(...args);\n  } //**********************************************************************************\n\n  /**\r\n   * Wrapper for standard function \"wrapKey\"\r\n   * @param args\r\n   * @returns {Promise}\r\n   */\n\n\n  wrapKey(...args) {\n    return this.subtle.wrapKey(...args);\n  } //**********************************************************************************\n\n  /**\r\n   * Wrapper for standard function \"unwrapKey\"\r\n   * @param args\r\n   * @returns {Promise}\r\n   */\n\n\n  unwrapKey(...args) {\n    return this.subtle.unwrapKey(...args);\n  } //**********************************************************************************\n\n  /**\r\n   * Initialize input Uint8Array by random values (with help from current \"crypto engine\")\r\n   * @param {!Uint8Array} view\r\n   * @returns {*}\r\n   */\n\n\n  getRandomValues(view) {\n    if (\"getRandomValues\" in this.crypto === false) throw new Error(\"No support for getRandomValues\");\n    return this.crypto.getRandomValues(view);\n  } //**********************************************************************************\n\n  /**\r\n   * Get WebCrypto algorithm by wel-known OID\r\n   * @param {string} oid well-known OID to search for\r\n   * @returns {Object}\r\n   */\n\n\n  getAlgorithmByOID(oid) {\n    switch (oid) {\n      case \"1.2.840.113549.1.1.1\":\n        return {\n          name: \"RSAES-PKCS1-v1_5\"\n        };\n\n      case \"1.2.840.113549.1.1.5\":\n        return {\n          name: \"RSASSA-PKCS1-v1_5\",\n          hash: {\n            name: \"SHA-1\"\n          }\n        };\n\n      case \"1.2.840.113549.1.1.11\":\n        return {\n          name: \"RSASSA-PKCS1-v1_5\",\n          hash: {\n            name: \"SHA-256\"\n          }\n        };\n\n      case \"1.2.840.113549.1.1.12\":\n        return {\n          name: \"RSASSA-PKCS1-v1_5\",\n          hash: {\n            name: \"SHA-384\"\n          }\n        };\n\n      case \"1.2.840.113549.1.1.13\":\n        return {\n          name: \"RSASSA-PKCS1-v1_5\",\n          hash: {\n            name: \"SHA-512\"\n          }\n        };\n\n      case \"1.2.840.113549.1.1.10\":\n        return {\n          name: \"RSA-PSS\"\n        };\n\n      case \"1.2.840.113549.1.1.7\":\n        return {\n          name: \"RSA-OAEP\"\n        };\n\n      case \"1.2.840.10045.2.1\":\n      case \"1.2.840.10045.4.1\":\n        return {\n          name: \"ECDSA\",\n          hash: {\n            name: \"SHA-1\"\n          }\n        };\n\n      case \"1.2.840.10045.4.3.2\":\n        return {\n          name: \"ECDSA\",\n          hash: {\n            name: \"SHA-256\"\n          }\n        };\n\n      case \"1.2.840.10045.4.3.3\":\n        return {\n          name: \"ECDSA\",\n          hash: {\n            name: \"SHA-384\"\n          }\n        };\n\n      case \"1.2.840.10045.4.3.4\":\n        return {\n          name: \"ECDSA\",\n          hash: {\n            name: \"SHA-512\"\n          }\n        };\n\n      case \"1.3.133.16.840.63.0.2\":\n        return {\n          name: \"ECDH\",\n          kdf: \"SHA-1\"\n        };\n\n      case \"1.3.132.1.11.1\":\n        return {\n          name: \"ECDH\",\n          kdf: \"SHA-256\"\n        };\n\n      case \"1.3.132.1.11.2\":\n        return {\n          name: \"ECDH\",\n          kdf: \"SHA-384\"\n        };\n\n      case \"1.3.132.1.11.3\":\n        return {\n          name: \"ECDH\",\n          kdf: \"SHA-512\"\n        };\n\n      case \"2.16.840.1.101.3.4.1.2\":\n        return {\n          name: \"AES-CBC\",\n          length: 128\n        };\n\n      case \"2.16.840.1.101.3.4.1.22\":\n        return {\n          name: \"AES-CBC\",\n          length: 192\n        };\n\n      case \"2.16.840.1.101.3.4.1.42\":\n        return {\n          name: \"AES-CBC\",\n          length: 256\n        };\n\n      case \"2.16.840.1.101.3.4.1.6\":\n        return {\n          name: \"AES-GCM\",\n          length: 128\n        };\n\n      case \"2.16.840.1.101.3.4.1.26\":\n        return {\n          name: \"AES-GCM\",\n          length: 192\n        };\n\n      case \"2.16.840.1.101.3.4.1.46\":\n        return {\n          name: \"AES-GCM\",\n          length: 256\n        };\n\n      case \"2.16.840.1.101.3.4.1.4\":\n        return {\n          name: \"AES-CFB\",\n          length: 128\n        };\n\n      case \"2.16.840.1.101.3.4.1.24\":\n        return {\n          name: \"AES-CFB\",\n          length: 192\n        };\n\n      case \"2.16.840.1.101.3.4.1.44\":\n        return {\n          name: \"AES-CFB\",\n          length: 256\n        };\n\n      case \"2.16.840.1.101.3.4.1.5\":\n        return {\n          name: \"AES-KW\",\n          length: 128\n        };\n\n      case \"2.16.840.1.101.3.4.1.25\":\n        return {\n          name: \"AES-KW\",\n          length: 192\n        };\n\n      case \"2.16.840.1.101.3.4.1.45\":\n        return {\n          name: \"AES-KW\",\n          length: 256\n        };\n\n      case \"1.2.840.113549.2.7\":\n        return {\n          name: \"HMAC\",\n          hash: {\n            name: \"SHA-1\"\n          }\n        };\n\n      case \"1.2.840.113549.2.9\":\n        return {\n          name: \"HMAC\",\n          hash: {\n            name: \"SHA-256\"\n          }\n        };\n\n      case \"1.2.840.113549.2.10\":\n        return {\n          name: \"HMAC\",\n          hash: {\n            name: \"SHA-384\"\n          }\n        };\n\n      case \"1.2.840.113549.2.11\":\n        return {\n          name: \"HMAC\",\n          hash: {\n            name: \"SHA-512\"\n          }\n        };\n\n      case \"1.2.840.113549.1.9.16.3.5\":\n        return {\n          name: \"DH\"\n        };\n\n      case \"1.3.14.3.2.26\":\n        return {\n          name: \"SHA-1\"\n        };\n\n      case \"2.16.840.1.101.3.4.2.1\":\n        return {\n          name: \"SHA-256\"\n        };\n\n      case \"2.16.840.1.101.3.4.2.2\":\n        return {\n          name: \"SHA-384\"\n        };\n\n      case \"2.16.840.1.101.3.4.2.3\":\n        return {\n          name: \"SHA-512\"\n        };\n\n      case \"1.2.840.113549.1.5.12\":\n        return {\n          name: \"PBKDF2\"\n        };\n      //region Special case - OIDs for ECC curves\n\n      case \"1.2.840.10045.3.1.7\":\n        return {\n          name: \"P-256\"\n        };\n\n      case \"1.3.132.0.34\":\n        return {\n          name: \"P-384\"\n        };\n\n      case \"1.3.132.0.35\":\n        return {\n          name: \"P-521\"\n        };\n      //endregion\n\n      default:\n    }\n\n    return {};\n  } //**********************************************************************************\n\n  /**\r\n   * Get OID for each specific algorithm\r\n   * @param {Object} algorithm\r\n   * @returns {string}\r\n   */\n\n\n  getOIDByAlgorithm(algorithm) {\n    let result = \"\";\n\n    switch (algorithm.name.toUpperCase()) {\n      case \"RSAES-PKCS1-V1_5\":\n        result = \"1.2.840.113549.1.1.1\";\n        break;\n\n      case \"RSASSA-PKCS1-V1_5\":\n        switch (algorithm.hash.name.toUpperCase()) {\n          case \"SHA-1\":\n            result = \"1.2.840.113549.1.1.5\";\n            break;\n\n          case \"SHA-256\":\n            result = \"1.2.840.113549.1.1.11\";\n            break;\n\n          case \"SHA-384\":\n            result = \"1.2.840.113549.1.1.12\";\n            break;\n\n          case \"SHA-512\":\n            result = \"1.2.840.113549.1.1.13\";\n            break;\n\n          default:\n        }\n\n        break;\n\n      case \"RSA-PSS\":\n        result = \"1.2.840.113549.1.1.10\";\n        break;\n\n      case \"RSA-OAEP\":\n        result = \"1.2.840.113549.1.1.7\";\n        break;\n\n      case \"ECDSA\":\n        switch (algorithm.hash.name.toUpperCase()) {\n          case \"SHA-1\":\n            result = \"1.2.840.10045.4.1\";\n            break;\n\n          case \"SHA-256\":\n            result = \"1.2.840.10045.4.3.2\";\n            break;\n\n          case \"SHA-384\":\n            result = \"1.2.840.10045.4.3.3\";\n            break;\n\n          case \"SHA-512\":\n            result = \"1.2.840.10045.4.3.4\";\n            break;\n\n          default:\n        }\n\n        break;\n\n      case \"ECDH\":\n        switch (algorithm.kdf.toUpperCase()) {\n          // Non-standard addition - hash algorithm of KDF function\n          case \"SHA-1\":\n            result = \"1.3.133.16.840.63.0.2\"; // dhSinglePass-stdDH-sha1kdf-scheme\n\n            break;\n\n          case \"SHA-256\":\n            result = \"1.3.132.1.11.1\"; // dhSinglePass-stdDH-sha256kdf-scheme\n\n            break;\n\n          case \"SHA-384\":\n            result = \"1.3.132.1.11.2\"; // dhSinglePass-stdDH-sha384kdf-scheme\n\n            break;\n\n          case \"SHA-512\":\n            result = \"1.3.132.1.11.3\"; // dhSinglePass-stdDH-sha512kdf-scheme\n\n            break;\n\n          default:\n        }\n\n        break;\n\n      case \"AES-CTR\":\n        break;\n\n      case \"AES-CBC\":\n        switch (algorithm.length) {\n          case 128:\n            result = \"2.16.840.1.101.3.4.1.2\";\n            break;\n\n          case 192:\n            result = \"2.16.840.1.101.3.4.1.22\";\n            break;\n\n          case 256:\n            result = \"2.16.840.1.101.3.4.1.42\";\n            break;\n\n          default:\n        }\n\n        break;\n\n      case \"AES-CMAC\":\n        break;\n\n      case \"AES-GCM\":\n        switch (algorithm.length) {\n          case 128:\n            result = \"2.16.840.1.101.3.4.1.6\";\n            break;\n\n          case 192:\n            result = \"2.16.840.1.101.3.4.1.26\";\n            break;\n\n          case 256:\n            result = \"2.16.840.1.101.3.4.1.46\";\n            break;\n\n          default:\n        }\n\n        break;\n\n      case \"AES-CFB\":\n        switch (algorithm.length) {\n          case 128:\n            result = \"2.16.840.1.101.3.4.1.4\";\n            break;\n\n          case 192:\n            result = \"2.16.840.1.101.3.4.1.24\";\n            break;\n\n          case 256:\n            result = \"2.16.840.1.101.3.4.1.44\";\n            break;\n\n          default:\n        }\n\n        break;\n\n      case \"AES-KW\":\n        switch (algorithm.length) {\n          case 128:\n            result = \"2.16.840.1.101.3.4.1.5\";\n            break;\n\n          case 192:\n            result = \"2.16.840.1.101.3.4.1.25\";\n            break;\n\n          case 256:\n            result = \"2.16.840.1.101.3.4.1.45\";\n            break;\n\n          default:\n        }\n\n        break;\n\n      case \"HMAC\":\n        switch (algorithm.hash.name.toUpperCase()) {\n          case \"SHA-1\":\n            result = \"1.2.840.113549.2.7\";\n            break;\n\n          case \"SHA-256\":\n            result = \"1.2.840.113549.2.9\";\n            break;\n\n          case \"SHA-384\":\n            result = \"1.2.840.113549.2.10\";\n            break;\n\n          case \"SHA-512\":\n            result = \"1.2.840.113549.2.11\";\n            break;\n\n          default:\n        }\n\n        break;\n\n      case \"DH\":\n        result = \"1.2.840.113549.1.9.16.3.5\";\n        break;\n\n      case \"SHA-1\":\n        result = \"1.3.14.3.2.26\";\n        break;\n\n      case \"SHA-256\":\n        result = \"2.16.840.1.101.3.4.2.1\";\n        break;\n\n      case \"SHA-384\":\n        result = \"2.16.840.1.101.3.4.2.2\";\n        break;\n\n      case \"SHA-512\":\n        result = \"2.16.840.1.101.3.4.2.3\";\n        break;\n\n      case \"CONCAT\":\n        break;\n\n      case \"HKDF\":\n        break;\n\n      case \"PBKDF2\":\n        result = \"1.2.840.113549.1.5.12\";\n        break;\n      //region Special case - OIDs for ECC curves\n\n      case \"P-256\":\n        result = \"1.2.840.10045.3.1.7\";\n        break;\n\n      case \"P-384\":\n        result = \"1.3.132.0.34\";\n        break;\n\n      case \"P-521\":\n        result = \"1.3.132.0.35\";\n        break;\n      //endregion\n\n      default:\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Get default algorithm parameters for each kind of operation\r\n   * @param {string} algorithmName Algorithm name to get common parameters for\r\n   * @param {string} operation Kind of operation: \"sign\", \"encrypt\", \"generatekey\", \"importkey\", \"exportkey\", \"verify\"\r\n   * @returns {*}\r\n   */\n\n\n  getAlgorithmParameters(algorithmName, operation) {\n    let result = {\n      algorithm: {},\n      usages: []\n    };\n\n    switch (algorithmName.toUpperCase()) {\n      case \"RSAES-PKCS1-V1_5\":\n      case \"RSASSA-PKCS1-V1_5\":\n        switch (operation.toLowerCase()) {\n          case \"generatekey\":\n            result = {\n              algorithm: {\n                name: \"RSASSA-PKCS1-v1_5\",\n                modulusLength: 2048,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                hash: {\n                  name: \"SHA-256\"\n                }\n              },\n              usages: [\"sign\", \"verify\"]\n            };\n            break;\n\n          case \"verify\":\n          case \"sign\":\n          case \"importkey\":\n            result = {\n              algorithm: {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: {\n                  name: \"SHA-256\"\n                }\n              },\n              usages: [\"verify\"] // For importKey(\"pkcs8\") usage must be \"sign\" only\n\n            };\n            break;\n\n          case \"exportkey\":\n          default:\n            return {\n              algorithm: {\n                name: \"RSASSA-PKCS1-v1_5\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"RSA-PSS\":\n        switch (operation.toLowerCase()) {\n          case \"sign\":\n          case \"verify\":\n            result = {\n              algorithm: {\n                name: \"RSA-PSS\",\n                hash: {\n                  name: \"SHA-1\"\n                },\n                saltLength: 20\n              },\n              usages: [\"sign\", \"verify\"]\n            };\n            break;\n\n          case \"generatekey\":\n            result = {\n              algorithm: {\n                name: \"RSA-PSS\",\n                modulusLength: 2048,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                hash: {\n                  name: \"SHA-1\"\n                }\n              },\n              usages: [\"sign\", \"verify\"]\n            };\n            break;\n\n          case \"importkey\":\n            result = {\n              algorithm: {\n                name: \"RSA-PSS\",\n                hash: {\n                  name: \"SHA-1\"\n                }\n              },\n              usages: [\"verify\"] // For importKey(\"pkcs8\") usage must be \"sign\" only\n\n            };\n            break;\n\n          case \"exportkey\":\n          default:\n            return {\n              algorithm: {\n                name: \"RSA-PSS\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"RSA-OAEP\":\n        switch (operation.toLowerCase()) {\n          case \"encrypt\":\n          case \"decrypt\":\n            result = {\n              algorithm: {\n                name: \"RSA-OAEP\"\n              },\n              usages: [\"encrypt\", \"decrypt\"]\n            };\n            break;\n\n          case \"generatekey\":\n            result = {\n              algorithm: {\n                name: \"RSA-OAEP\",\n                modulusLength: 2048,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                hash: {\n                  name: \"SHA-256\"\n                }\n              },\n              usages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n            };\n            break;\n\n          case \"importkey\":\n            result = {\n              algorithm: {\n                name: \"RSA-OAEP\",\n                hash: {\n                  name: \"SHA-256\"\n                }\n              },\n              usages: [\"encrypt\"] // encrypt for \"spki\" and decrypt for \"pkcs8\"\n\n            };\n            break;\n\n          case \"exportkey\":\n          default:\n            return {\n              algorithm: {\n                name: \"RSA-OAEP\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"ECDSA\":\n        switch (operation.toLowerCase()) {\n          case \"generatekey\":\n            result = {\n              algorithm: {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\"\n              },\n              usages: [\"sign\", \"verify\"]\n            };\n            break;\n\n          case \"importkey\":\n            result = {\n              algorithm: {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\"\n              },\n              usages: [\"verify\"] // \"sign\" for \"pkcs8\"\n\n            };\n            break;\n\n          case \"verify\":\n          case \"sign\":\n            result = {\n              algorithm: {\n                name: \"ECDSA\",\n                hash: {\n                  name: \"SHA-256\"\n                }\n              },\n              usages: [\"sign\"]\n            };\n            break;\n\n          default:\n            return {\n              algorithm: {\n                name: \"ECDSA\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"ECDH\":\n        switch (operation.toLowerCase()) {\n          case \"exportkey\":\n          case \"importkey\":\n          case \"generatekey\":\n            result = {\n              algorithm: {\n                name: \"ECDH\",\n                namedCurve: \"P-256\"\n              },\n              usages: [\"deriveKey\", \"deriveBits\"]\n            };\n            break;\n\n          case \"derivekey\":\n          case \"derivebits\":\n            result = {\n              algorithm: {\n                name: \"ECDH\",\n                namedCurve: \"P-256\",\n                public: [] // Must be a \"publicKey\"\n\n              },\n              usages: [\"encrypt\", \"decrypt\"]\n            };\n            break;\n\n          default:\n            return {\n              algorithm: {\n                name: \"ECDH\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"AES-CTR\":\n        switch (operation.toLowerCase()) {\n          case \"importkey\":\n          case \"exportkey\":\n          case \"generatekey\":\n            result = {\n              algorithm: {\n                name: \"AES-CTR\",\n                length: 256\n              },\n              usages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n            };\n            break;\n\n          case \"decrypt\":\n          case \"encrypt\":\n            result = {\n              algorithm: {\n                name: \"AES-CTR\",\n                counter: new Uint8Array(16),\n                length: 10\n              },\n              usages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n            };\n            break;\n\n          default:\n            return {\n              algorithm: {\n                name: \"AES-CTR\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"AES-CBC\":\n        switch (operation.toLowerCase()) {\n          case \"importkey\":\n          case \"exportkey\":\n          case \"generatekey\":\n            result = {\n              algorithm: {\n                name: \"AES-CBC\",\n                length: 256\n              },\n              usages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n            };\n            break;\n\n          case \"decrypt\":\n          case \"encrypt\":\n            result = {\n              algorithm: {\n                name: \"AES-CBC\",\n                iv: this.getRandomValues(new Uint8Array(16)) // For \"decrypt\" the value should be replaced with value got on \"encrypt\" step\n\n              },\n              usages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n            };\n            break;\n\n          default:\n            return {\n              algorithm: {\n                name: \"AES-CBC\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"AES-GCM\":\n        switch (operation.toLowerCase()) {\n          case \"importkey\":\n          case \"exportkey\":\n          case \"generatekey\":\n            result = {\n              algorithm: {\n                name: \"AES-GCM\",\n                length: 256\n              },\n              usages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n            };\n            break;\n\n          case \"decrypt\":\n          case \"encrypt\":\n            result = {\n              algorithm: {\n                name: \"AES-GCM\",\n                iv: this.getRandomValues(new Uint8Array(16)) // For \"decrypt\" the value should be replaced with value got on \"encrypt\" step\n\n              },\n              usages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n            };\n            break;\n\n          default:\n            return {\n              algorithm: {\n                name: \"AES-GCM\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"AES-KW\":\n        switch (operation.toLowerCase()) {\n          case \"importkey\":\n          case \"exportkey\":\n          case \"generatekey\":\n          case \"wrapkey\":\n          case \"unwrapkey\":\n            result = {\n              algorithm: {\n                name: \"AES-KW\",\n                length: 256\n              },\n              usages: [\"wrapKey\", \"unwrapKey\"]\n            };\n            break;\n\n          default:\n            return {\n              algorithm: {\n                name: \"AES-KW\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"HMAC\":\n        switch (operation.toLowerCase()) {\n          case \"sign\":\n          case \"verify\":\n            result = {\n              algorithm: {\n                name: \"HMAC\"\n              },\n              usages: [\"sign\", \"verify\"]\n            };\n            break;\n\n          case \"importkey\":\n          case \"exportkey\":\n          case \"generatekey\":\n            result = {\n              algorithm: {\n                name: \"HMAC\",\n                length: 32,\n                hash: {\n                  name: \"SHA-256\"\n                }\n              },\n              usages: [\"sign\", \"verify\"]\n            };\n            break;\n\n          default:\n            return {\n              algorithm: {\n                name: \"HMAC\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"HKDF\":\n        switch (operation.toLowerCase()) {\n          case \"derivekey\":\n            result = {\n              algorithm: {\n                name: \"HKDF\",\n                hash: \"SHA-256\",\n                salt: new Uint8Array([]),\n                info: new Uint8Array([])\n              },\n              usages: [\"encrypt\", \"decrypt\"]\n            };\n            break;\n\n          default:\n            return {\n              algorithm: {\n                name: \"HKDF\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      case \"PBKDF2\":\n        switch (operation.toLowerCase()) {\n          case \"derivekey\":\n            result = {\n              algorithm: {\n                name: \"PBKDF2\",\n                hash: {\n                  name: \"SHA-256\"\n                },\n                salt: new Uint8Array([]),\n                iterations: 10000\n              },\n              usages: [\"encrypt\", \"decrypt\"]\n            };\n            break;\n\n          default:\n            return {\n              algorithm: {\n                name: \"PBKDF2\"\n              },\n              usages: []\n            };\n        }\n\n        break;\n\n      default:\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Getting hash algorithm by signature algorithm\r\n   * @param {AlgorithmIdentifier} signatureAlgorithm Signature algorithm\r\n   * @returns {string}\r\n   */\n\n\n  getHashAlgorithm(signatureAlgorithm) {\n    let result = \"\";\n\n    switch (signatureAlgorithm.algorithmId) {\n      case \"1.2.840.10045.4.1\": // ecdsa-with-SHA1\n\n      case \"1.2.840.113549.1.1.5\":\n        result = \"SHA-1\";\n        break;\n\n      case \"1.2.840.10045.4.3.2\": // ecdsa-with-SHA256\n\n      case \"1.2.840.113549.1.1.11\":\n        result = \"SHA-256\";\n        break;\n\n      case \"1.2.840.10045.4.3.3\": // ecdsa-with-SHA384\n\n      case \"1.2.840.113549.1.1.12\":\n        result = \"SHA-384\";\n        break;\n\n      case \"1.2.840.10045.4.3.4\": // ecdsa-with-SHA512\n\n      case \"1.2.840.113549.1.1.13\":\n        result = \"SHA-512\";\n        break;\n\n      case \"1.2.840.113549.1.1.10\":\n        // RSA-PSS\n        {\n          try {\n            const params = new _RSASSAPSSParams.default({\n              schema: signatureAlgorithm.algorithmParams\n            });\n\n            if (\"hashAlgorithm\" in params) {\n              const algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);\n              if (\"name\" in algorithm === false) return \"\";\n              result = algorithm.name;\n            } else result = \"SHA-1\";\n          } catch (ex) {}\n        }\n        break;\n\n      default:\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Specialized function encrypting \"EncryptedContentInfo\" object using parameters\r\n   * @param {Object} parameters\r\n   * @returns {Promise}\r\n   */\n\n\n  encryptEncryptedContentInfo(parameters) {\n    //region Check for input parameters\n    if (parameters instanceof Object === false) return Promise.reject(\"Parameters must have type \\\"Object\\\"\");\n    if (\"password\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\"\");\n    if (\"contentEncryptionAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"contentEncryptionAlgorithm\\\"\");\n    if (\"hmacHashAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"hmacHashAlgorithm\\\"\");\n    if (\"iterationCount\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"iterationCount\\\"\");\n    if (\"contentToEncrypt\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"contentToEncrypt\\\"\");\n    if (\"contentType\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"contentType\\\"\");\n    const contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm);\n    if (contentEncryptionOID === \"\") return Promise.reject(\"Wrong \\\"contentEncryptionAlgorithm\\\" value\");\n    const pbkdf2OID = this.getOIDByAlgorithm({\n      name: \"PBKDF2\"\n    });\n    if (pbkdf2OID === \"\") return Promise.reject(\"Can not find OID for PBKDF2\");\n    const hmacOID = this.getOIDByAlgorithm({\n      name: \"HMAC\",\n      hash: {\n        name: parameters.hmacHashAlgorithm\n      }\n    });\n    if (hmacOID === \"\") return Promise.reject(`Incorrect value for \"hmacHashAlgorithm\": ${parameters.hmacHashAlgorithm}`); //endregion\n    //region Initial variables\n\n    let sequence = Promise.resolve();\n    const ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long\n\n    const ivView = new Uint8Array(ivBuffer);\n    this.getRandomValues(ivView);\n    const saltBuffer = new ArrayBuffer(64);\n    const saltView = new Uint8Array(saltBuffer);\n    this.getRandomValues(saltView);\n    const contentView = new Uint8Array(parameters.contentToEncrypt);\n    const pbkdf2Params = new _PBKDF2Params.default({\n      salt: new asn1js.OctetString({\n        valueHex: saltBuffer\n      }),\n      iterationCount: parameters.iterationCount,\n      prf: new _AlgorithmIdentifier.default({\n        algorithmId: hmacOID,\n        algorithmParams: new asn1js.Null()\n      })\n    }); //endregion\n    //region Derive PBKDF2 key from \"password\" buffer\n\n    sequence = sequence.then(() => {\n      const passwordView = new Uint8Array(parameters.password);\n      return this.importKey(\"raw\", passwordView, \"PBKDF2\", false, [\"deriveKey\"]);\n    }, error => Promise.reject(error)); //endregion\n    //region Derive key for \"contentEncryptionAlgorithm\"\n\n    sequence = sequence.then(result => this.deriveKey({\n      name: \"PBKDF2\",\n      hash: {\n        name: parameters.hmacHashAlgorithm\n      },\n      salt: saltView,\n      iterations: parameters.iterationCount\n    }, result, parameters.contentEncryptionAlgorithm, false, [\"encrypt\"]), error => Promise.reject(error)); //endregion\n    //region Encrypt content\n\n    sequence = sequence.then(result => this.encrypt({\n      name: parameters.contentEncryptionAlgorithm.name,\n      iv: ivView\n    }, result, contentView), error => Promise.reject(error)); //endregion\n    //region Store all parameters in EncryptedData object\n\n    sequence = sequence.then(result => {\n      const pbes2Parameters = new _PBES2Params.default({\n        keyDerivationFunc: new _AlgorithmIdentifier.default({\n          algorithmId: pbkdf2OID,\n          algorithmParams: pbkdf2Params.toSchema()\n        }),\n        encryptionScheme: new _AlgorithmIdentifier.default({\n          algorithmId: contentEncryptionOID,\n          algorithmParams: new asn1js.OctetString({\n            valueHex: ivBuffer\n          })\n        })\n      });\n      return new _EncryptedContentInfo.default({\n        contentType: parameters.contentType,\n        contentEncryptionAlgorithm: new _AlgorithmIdentifier.default({\n          algorithmId: \"1.2.840.113549.1.5.13\",\n          // pkcs5PBES2\n          algorithmParams: pbes2Parameters.toSchema()\n        }),\n        encryptedContent: new asn1js.OctetString({\n          valueHex: result\n        })\n      });\n    }, error => Promise.reject(error)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Decrypt data stored in \"EncryptedContentInfo\" object using parameters\r\n   * @param parameters\r\n   * @return {Promise}\r\n   */\n\n\n  decryptEncryptedContentInfo(parameters) {\n    //region Check for input parameters\n    if (parameters instanceof Object === false) return Promise.reject(\"Parameters must have type \\\"Object\\\"\");\n    if (\"password\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\"\");\n    if (\"encryptedContentInfo\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"encryptedContentInfo\\\"\");\n    if (parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== \"1.2.840.113549.1.5.13\") // pkcs5PBES2\n      return Promise.reject(`Unknown \"contentEncryptionAlgorithm\": ${parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n    //region Initial variables\n\n    let sequence = Promise.resolve();\n    let pbes2Parameters;\n\n    try {\n      pbes2Parameters = new _PBES2Params.default({\n        schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams\n      });\n    } catch (ex) {\n      return Promise.reject(\"Incorrectly encoded \\\"pbes2Parameters\\\"\");\n    }\n\n    let pbkdf2Params;\n\n    try {\n      pbkdf2Params = new _PBKDF2Params.default({\n        schema: pbes2Parameters.keyDerivationFunc.algorithmParams\n      });\n    } catch (ex) {\n      return Promise.reject(\"Incorrectly encoded \\\"pbkdf2Params\\\"\");\n    }\n\n    const contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId);\n    if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect OID for \"contentEncryptionAlgorithm\": ${pbes2Parameters.encryptionScheme.algorithmId}`);\n    const ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;\n    const ivView = new Uint8Array(ivBuffer);\n    const saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;\n    const saltView = new Uint8Array(saltBuffer);\n    const iterationCount = pbkdf2Params.iterationCount;\n    let hmacHashAlgorithm = \"SHA-1\";\n\n    if (\"prf\" in pbkdf2Params) {\n      const algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId);\n      if (\"name\" in algorithm === false) return Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\n      hmacHashAlgorithm = algorithm.hash.name;\n    } //endregion\n    //region Derive PBKDF2 key from \"password\" buffer\n\n\n    sequence = sequence.then(() => this.importKey(\"raw\", parameters.password, \"PBKDF2\", false, [\"deriveKey\"]), error => Promise.reject(error)); //endregion\n    //region Derive key for \"contentEncryptionAlgorithm\"\n\n    sequence = sequence.then(result => this.deriveKey({\n      name: \"PBKDF2\",\n      hash: {\n        name: hmacHashAlgorithm\n      },\n      salt: saltView,\n      iterations: iterationCount\n    }, result, contentEncryptionAlgorithm, false, [\"decrypt\"]), error => Promise.reject(error)); //endregion\n    //region Decrypt internal content using derived key\n\n    sequence = sequence.then(result => {\n      //region Create correct data block for decryption\n      let dataBuffer = new ArrayBuffer(0);\n      if (parameters.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false) dataBuffer = parameters.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else {\n        var _iterator = _createForOfIteratorHelper(parameters.encryptedContentInfo.encryptedContent.valueBlock.value),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            const content = _step.value;\n            dataBuffer = (0, _pvutils.utilConcatBuf)(dataBuffer, content.valueBlock.valueHex);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } //endregion\n\n      return this.decrypt({\n        name: contentEncryptionAlgorithm.name,\n        iv: ivView\n      }, result, dataBuffer);\n    }, error => Promise.reject(error)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Stamping (signing) data using algorithm simular to HMAC\r\n   * @param {Object} parameters\r\n   * @return {Promise.<T>|Promise}\r\n   */\n\n\n  stampDataWithPassword(parameters) {\n    //region Check for input parameters\n    if (parameters instanceof Object === false) return Promise.reject(\"Parameters must have type \\\"Object\\\"\");\n    if (\"password\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\"\");\n    if (\"hashAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"hashAlgorithm\\\"\");\n    if (\"salt\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"iterationCount\\\"\");\n    if (\"iterationCount\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"salt\\\"\");\n    if (\"contentToStamp\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"contentToStamp\\\"\"); //endregion\n    //region Choose correct length for HMAC key\n\n    let length;\n\n    switch (parameters.hashAlgorithm.toLowerCase()) {\n      case \"sha-1\":\n        length = 160;\n        break;\n\n      case \"sha-256\":\n        length = 256;\n        break;\n\n      case \"sha-384\":\n        length = 384;\n        break;\n\n      case \"sha-512\":\n        length = 512;\n        break;\n\n      default:\n        return Promise.reject(`Incorrect \"parameters.hashAlgorithm\" parameter: ${parameters.hashAlgorithm}`);\n    } //endregion\n    //region Initial variables\n\n\n    let sequence = Promise.resolve();\n    const hmacAlgorithm = {\n      name: \"HMAC\",\n      length,\n      hash: {\n        name: parameters.hashAlgorithm\n      }\n    }; //endregion\n    //region Create PKCS#12 key for integrity checking\n\n    sequence = sequence.then(() => makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount)); //endregion\n    //region Import HMAC key\n    // noinspection JSCheckFunctionSignatures\n\n    sequence = sequence.then(result => this.importKey(\"raw\", new Uint8Array(result), hmacAlgorithm, false, [\"sign\"])); //endregion\n    //region Make signed HMAC value\n\n    sequence = sequence.then(result => this.sign(hmacAlgorithm, result, new Uint8Array(parameters.contentToStamp)), error => Promise.reject(error)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n\n  verifyDataStampedWithPassword(parameters) {\n    //region Check for input parameters\n    if (parameters instanceof Object === false) return Promise.reject(\"Parameters must have type \\\"Object\\\"\");\n    if (\"password\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\"\");\n    if (\"hashAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"hashAlgorithm\\\"\");\n    if (\"salt\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"iterationCount\\\"\");\n    if (\"iterationCount\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"salt\\\"\");\n    if (\"contentToVerify\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"contentToVerify\\\"\");\n    if (\"signatureToVerify\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"signatureToVerify\\\"\"); //endregion\n    //region Choose correct length for HMAC key\n\n    let length;\n\n    switch (parameters.hashAlgorithm.toLowerCase()) {\n      case \"sha-1\":\n        length = 160;\n        break;\n\n      case \"sha-256\":\n        length = 256;\n        break;\n\n      case \"sha-384\":\n        length = 384;\n        break;\n\n      case \"sha-512\":\n        length = 512;\n        break;\n\n      default:\n        return Promise.reject(`Incorrect \"parameters.hashAlgorithm\" parameter: ${parameters.hashAlgorithm}`);\n    } //endregion\n    //region Initial variables\n\n\n    let sequence = Promise.resolve();\n    const hmacAlgorithm = {\n      name: \"HMAC\",\n      length,\n      hash: {\n        name: parameters.hashAlgorithm\n      }\n    }; //endregion\n    //region Create PKCS#12 key for integrity checking\n\n    sequence = sequence.then(() => makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount)); //endregion\n    //region Import HMAC key\n    // noinspection JSCheckFunctionSignatures\n\n    sequence = sequence.then(result => this.importKey(\"raw\", new Uint8Array(result), hmacAlgorithm, false, [\"verify\"])); //endregion\n    //region Make signed HMAC value\n\n    sequence = sequence.then(result => this.verify(hmacAlgorithm, result, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify)), error => Promise.reject(error)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Get signature parameters by analyzing private key algorithm\r\n   * @param {Object} privateKey The private key user would like to use\r\n   * @param {string} [hashAlgorithm=\"SHA-1\"] Hash algorithm user would like to use\r\n   * @return {Promise.<T>|Promise}\r\n   */\n\n\n  getSignatureParameters(privateKey, hashAlgorithm = \"SHA-1\") {\n    //region Check hashing algorithm\n    const oid = this.getOIDByAlgorithm({\n      name: hashAlgorithm\n    });\n    if (oid === \"\") return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`); //endregion\n    //region Initial variables\n\n    const signatureAlgorithm = new _AlgorithmIdentifier.default(); //endregion\n    //region Get a \"default parameters\" for current algorithm\n\n    const parameters = this.getAlgorithmParameters(privateKey.algorithm.name, \"sign\");\n    parameters.algorithm.hash.name = hashAlgorithm; //endregion\n    //region Fill internal structures base on \"privateKey\" and \"hashAlgorithm\"\n\n    switch (privateKey.algorithm.name.toUpperCase()) {\n      case \"RSASSA-PKCS1-V1_5\":\n      case \"ECDSA\":\n        signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(parameters.algorithm);\n        break;\n\n      case \"RSA-PSS\":\n        {\n          //region Set \"saltLength\" as a length (in octets) of hash function result\n          switch (hashAlgorithm.toUpperCase()) {\n            case \"SHA-256\":\n              parameters.algorithm.saltLength = 32;\n              break;\n\n            case \"SHA-384\":\n              parameters.algorithm.saltLength = 48;\n              break;\n\n            case \"SHA-512\":\n              parameters.algorithm.saltLength = 64;\n              break;\n\n            default:\n          } //endregion\n          //region Fill \"RSASSA_PSS_params\" object\n\n\n          const paramsObject = {};\n\n          if (hashAlgorithm.toUpperCase() !== \"SHA-1\") {\n            const hashAlgorithmOID = this.getOIDByAlgorithm({\n              name: hashAlgorithm\n            });\n            if (hashAlgorithmOID === \"\") return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);\n            paramsObject.hashAlgorithm = new _AlgorithmIdentifier.default({\n              algorithmId: hashAlgorithmOID,\n              algorithmParams: new asn1js.Null()\n            });\n            paramsObject.maskGenAlgorithm = new _AlgorithmIdentifier.default({\n              algorithmId: \"1.2.840.113549.1.1.8\",\n              // MGF1\n              algorithmParams: paramsObject.hashAlgorithm.toSchema()\n            });\n          }\n\n          if (parameters.algorithm.saltLength !== 20) paramsObject.saltLength = parameters.algorithm.saltLength;\n          const pssParameters = new _RSASSAPSSParams.default(paramsObject); //endregion\n          //region Automatically set signature algorithm\n\n          signatureAlgorithm.algorithmId = \"1.2.840.113549.1.1.10\";\n          signatureAlgorithm.algorithmParams = pssParameters.toSchema(); //endregion\n        }\n        break;\n\n      default:\n        return Promise.reject(`Unsupported signature algorithm: ${privateKey.algorithm.name}`);\n    } //endregion\n\n\n    return Promise.resolve().then(() => ({\n      signatureAlgorithm,\n      parameters\n    }));\n  } //**********************************************************************************\n\n  /**\r\n   * Sign data with pre-defined private key\r\n   * @param {ArrayBuffer} data Data to be signed\r\n   * @param {Object} privateKey Private key to use\r\n   * @param {Object} parameters Parameters for used algorithm\r\n   * @return {Promise.<T>|Promise}\r\n   */\n\n\n  signWithPrivateKey(data, privateKey, parameters) {\n    return this.sign(parameters.algorithm, privateKey, new Uint8Array(data)).then(result => {\n      //region Special case for ECDSA algorithm\n      if (parameters.algorithm.name === \"ECDSA\") result = (0, _common.createCMSECDSASignature)(result); //endregion\n\n      return result;\n    }, error => Promise.reject(`Signing error: ${error}`));\n  } //**********************************************************************************\n\n\n  fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm) {\n    const parameters = {}; //region Find signer's hashing algorithm\n\n    const shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);\n    if (shaAlgorithm === \"\") return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`); //endregion\n    //region Get information about public key algorithm and default parameters for import\n\n    let algorithmId;\n    if (signatureAlgorithm.algorithmId === \"1.2.840.113549.1.1.10\") algorithmId = signatureAlgorithm.algorithmId;else algorithmId = publicKeyInfo.algorithm.algorithmId;\n    const algorithmObject = this.getAlgorithmByOID(algorithmId);\n    if (\"name\" in algorithmObject === \"\") return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);\n    parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, \"importkey\");\n    if (\"hash\" in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm; //region Special case for ECDSA\n\n    if (algorithmObject.name === \"ECDSA\") {\n      //region Get information about named curve\n      let algorithmParamsChecked = false;\n\n      if (\"algorithmParams\" in publicKeyInfo.algorithm === true) {\n        if (\"idBlock\" in publicKeyInfo.algorithm.algorithmParams) {\n          if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;\n        }\n      }\n\n      if (algorithmParamsChecked === false) return Promise.reject(\"Incorrect type for ECDSA public key parameters\");\n      const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());\n      if (\"name\" in curveObject === false) return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`); //endregion\n\n      parameters.algorithm.algorithm.namedCurve = curveObject.name;\n    } //endregion\n    //endregion\n\n\n    return parameters;\n  } //**********************************************************************************\n\n\n  getPublicKey(publicKeyInfo, signatureAlgorithm, parameters = null) {\n    if (parameters === null) parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);\n    const publicKeyInfoSchema = publicKeyInfo.toSchema();\n    const publicKeyInfoBuffer = publicKeyInfoSchema.toBER(false);\n    const publicKeyInfoView = new Uint8Array(publicKeyInfoBuffer);\n    return this.importKey(\"spki\", publicKeyInfoView, parameters.algorithm.algorithm, true, parameters.algorithm.usages);\n  } //**********************************************************************************\n\n\n  verifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm, shaAlgorithm = null) {\n    //region Initial variables\n    let sequence = Promise.resolve(); //endregion\n    //region Find signer's hashing algorithm\n\n    if (shaAlgorithm === null) {\n      shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);\n      if (shaAlgorithm === \"\") return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`); //region Import public key\n\n      sequence = sequence.then(() => this.getPublicKey(publicKeyInfo, signatureAlgorithm)); //endregion\n    } else {\n      const parameters = {}; //region Get information about public key algorithm and default parameters for import\n\n      let algorithmId;\n      if (signatureAlgorithm.algorithmId === \"1.2.840.113549.1.1.10\") algorithmId = signatureAlgorithm.algorithmId;else algorithmId = publicKeyInfo.algorithm.algorithmId;\n      const algorithmObject = this.getAlgorithmByOID(algorithmId);\n      if (\"name\" in algorithmObject === \"\") return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);\n      parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, \"importkey\");\n      if (\"hash\" in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm; //region Special case for ECDSA\n\n      if (algorithmObject.name === \"ECDSA\") {\n        //region Get information about named curve\n        let algorithmParamsChecked = false;\n\n        if (\"algorithmParams\" in publicKeyInfo.algorithm === true) {\n          if (\"idBlock\" in publicKeyInfo.algorithm.algorithmParams) {\n            if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;\n          }\n        }\n\n        if (algorithmParamsChecked === false) return Promise.reject(\"Incorrect type for ECDSA public key parameters\");\n        const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());\n        if (\"name\" in curveObject === false) return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`); //endregion\n\n        parameters.algorithm.algorithm.namedCurve = curveObject.name;\n      } //endregion\n      //endregion\n      //region Import public key\n\n\n      sequence = sequence.then(() => this.getPublicKey(publicKeyInfo, null, parameters)); //endregion\n    } //endregion\n    //region Verify signature\n\n\n    sequence = sequence.then(publicKey => {\n      //region Get default algorithm parameters for verification\n      const algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, \"verify\");\n      if (\"hash\" in algorithm.algorithm) algorithm.algorithm.hash.name = shaAlgorithm; //endregion\n      //region Special case for ECDSA signatures\n\n      let signatureValue = signature.valueBlock.valueHex;\n\n      if (publicKey.algorithm.name === \"ECDSA\") {\n        const asn1 = asn1js.fromBER(signatureValue); // noinspection JSCheckFunctionSignatures\n\n        signatureValue = (0, _common.createECDSASignatureFromCMS)(asn1.result);\n      } //endregion\n      //region Special case for RSA-PSS\n\n\n      if (publicKey.algorithm.name === \"RSA-PSS\") {\n        let pssParameters;\n\n        try {\n          pssParameters = new _RSASSAPSSParams.default({\n            schema: signatureAlgorithm.algorithmParams\n          });\n        } catch (ex) {\n          return Promise.reject(ex);\n        }\n\n        if (\"saltLength\" in pssParameters) algorithm.algorithm.saltLength = pssParameters.saltLength;else algorithm.algorithm.saltLength = 20;\n        let hashAlgo = \"SHA-1\";\n\n        if (\"hashAlgorithm\" in pssParameters) {\n          const hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId);\n          if (\"name\" in hashAlgorithm === false) return Promise.reject(`Unrecognized hash algorithm: ${pssParameters.hashAlgorithm.algorithmId}`);\n          hashAlgo = hashAlgorithm.name;\n        }\n\n        algorithm.algorithm.hash.name = hashAlgo;\n      } //endregion\n\n\n      return this.verify(algorithm.algorithm, publicKey, new Uint8Array(signatureValue), new Uint8Array(data));\n    }); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = CryptoEngine;\n//# sourceMappingURL=CryptoEngine.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/CryptoEngine.js\n// module id = ./node_modules/pkijs/build/CryptoEngine.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC3447\r\n */\nclass DigestInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for DigestInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc digestAlgorithm\r\n     */\n    this.digestAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"digestAlgorithm\", DigestInfo.defaultValues(\"digestAlgorithm\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc digest\r\n     */\n\n    this.digest = (0, _pvutils.getParametersValue)(parameters, \"digest\", DigestInfo.defaultValues(\"digest\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"digestAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"digest\":\n        return new asn1js.OctetString();\n\n      default:\n        throw new Error(`Invalid member name for DigestInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"digestAlgorithm\":\n        return _AlgorithmIdentifier.default.compareWithDefault(\"algorithmId\", memberValue.algorithmId) && \"algorithmParams\" in memberValue === false;\n\n      case \"digest\":\n        return memberValue.isEqual(DigestInfo.defaultValues(memberName));\n\n      default:\n        throw new Error(`Invalid member name for DigestInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * DigestInfo ::= SEQUENCE {\r\n   *    digestAlgorithm DigestAlgorithmIdentifier,\r\n   *    digest Digest }\r\n   *\r\n   * Digest ::= OCTET STRING\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [type]\r\n     * @property {string} [setName]\r\n     * @property {string} [values]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_AlgorithmIdentifier.default.schema(names.digestAlgorithm || {\n        names: {\n          blockName: \"digestAlgorithm\"\n        }\n      }), new asn1js.OctetString({\n        name: names.digest || \"digest\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"digestAlgorithm\", \"digest\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, DigestInfo.schema({\n      names: {\n        digestAlgorithm: {\n          names: {\n            blockName: \"digestAlgorithm\"\n          }\n        },\n        digest: \"digest\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for DigestInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.digestAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.digestAlgorithm\n    });\n    this.digest = asn1.result.digest; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.digestAlgorithm.toSchema(), this.digest]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      digestAlgorithm: this.digestAlgorithm.toJSON(),\n      digest: this.digest.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = DigestInfo;\n//# sourceMappingURL=DigestInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/DigestInfo.js\n// module id = ./node_modules/pkijs/build/DigestInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _GeneralName = _interopRequireDefault(require(\"./GeneralName.js\"));\n\nvar _RelativeDistinguishedNames = _interopRequireDefault(require(\"./RelativeDistinguishedNames.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass DistributionPoint {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for DistributionPoint class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   * @property {Object} [distributionPoint]\r\n   * @property {Object} [reasons]\r\n   * @property {Object} [cRLIssuer]\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    if (\"distributionPoint\" in parameters)\n      /**\r\n       * @type {Array.<GeneralName>}\r\n       * @desc distributionPoint\r\n       */\n      this.distributionPoint = (0, _pvutils.getParametersValue)(parameters, \"distributionPoint\", DistributionPoint.defaultValues(\"distributionPoint\"));\n    if (\"reasons\" in parameters)\n      /**\r\n       * @type {BitString}\r\n       * @desc values\r\n       */\n      this.reasons = (0, _pvutils.getParametersValue)(parameters, \"reasons\", DistributionPoint.defaultValues(\"reasons\"));\n    if (\"cRLIssuer\" in parameters)\n      /**\r\n       * @type {Array.<GeneralName>}\r\n       * @desc cRLIssuer\r\n       */\n      this.cRLIssuer = (0, _pvutils.getParametersValue)(parameters, \"cRLIssuer\", DistributionPoint.defaultValues(\"cRLIssuer\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"distributionPoint\":\n        return [];\n\n      case \"reasons\":\n        return new asn1js.BitString();\n\n      case \"cRLIssuer\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for DistributionPoint class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * DistributionPoint ::= SEQUENCE {\r\n   *    distributionPoint       [0]     DistributionPointName OPTIONAL,\r\n   *    reasons                 [1]     ReasonFlags OPTIONAL,\r\n   *    cRLIssuer               [2]     GeneralNames OPTIONAL }\r\n   *\r\n   * DistributionPointName ::= CHOICE {\r\n   *    fullName                [0]     GeneralNames,\r\n   *    nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }\r\n   *\r\n   * ReasonFlags ::= BIT STRING {\r\n   *    unused                  (0),\r\n   *    keyCompromise           (1),\r\n   *    cACompromise            (2),\r\n   *    affiliationChanged      (3),\r\n   *    superseded              (4),\r\n   *    cessationOfOperation    (5),\r\n   *    certificateHold         (6),\r\n   *    privilegeWithdrawn      (7),\r\n   *    aACompromise            (8) }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [distributionPoint]\r\n     * @property {string} [distributionPointNames]\r\n     * @property {string} [reasons]\r\n     * @property {string} [cRLIssuer]\r\n     * @property {string} [cRLIssuerNames]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Choice({\n          value: [new asn1js.Constructed({\n            name: names.distributionPoint || \"\",\n            optional: true,\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 0 // [0]\n\n            },\n            value: [new asn1js.Repeated({\n              name: names.distributionPointNames || \"\",\n              value: _GeneralName.default.schema()\n            })]\n          }), new asn1js.Constructed({\n            name: names.distributionPoint || \"\",\n            optional: true,\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 1 // [1]\n\n            },\n            value: _RelativeDistinguishedNames.default.schema().valueBlock.value\n          })]\n        })]\n      }), new asn1js.Primitive({\n        name: names.reasons || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        }\n      }), // IMPLICIT bitstring value\n      new asn1js.Constructed({\n        name: names.cRLIssuer || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        value: [new asn1js.Repeated({\n          name: names.cRLIssuerNames || \"\",\n          value: _GeneralName.default.schema()\n        })]\n      }) // IMPLICIT bitstring value\n      ]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"distributionPoint\", \"distributionPointNames\", \"reasons\", \"cRLIssuer\", \"cRLIssuerNames\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, DistributionPoint.schema({\n      names: {\n        distributionPoint: \"distributionPoint\",\n        distributionPointNames: \"distributionPointNames\",\n        reasons: \"reasons\",\n        cRLIssuer: \"cRLIssuer\",\n        cRLIssuerNames: \"cRLIssuerNames\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for DistributionPoint\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"distributionPoint\" in asn1.result) {\n      if (asn1.result.distributionPoint.idBlock.tagNumber === 0) // GENERAL_NAMES variant\n        this.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new _GeneralName.default({\n          schema: element\n        }));\n\n      if (asn1.result.distributionPoint.idBlock.tagNumber === 1) // RDN variant\n        {\n          this.distributionPoint = new _RelativeDistinguishedNames.default({\n            schema: new asn1js.Sequence({\n              value: asn1.result.distributionPoint.valueBlock.value\n            })\n          });\n        }\n    }\n\n    if (\"reasons\" in asn1.result) this.reasons = new asn1js.BitString({\n      valueHex: asn1.result.reasons.valueBlock.valueHex\n    });\n    if (\"cRLIssuer\" in asn1.result) this.cRLIssuer = Array.from(asn1.result.cRLIssuerNames, element => new _GeneralName.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    if (\"distributionPoint\" in this) {\n      let internalValue;\n\n      if (this.distributionPoint instanceof Array) {\n        internalValue = new asn1js.Constructed({\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: Array.from(this.distributionPoint, element => element.toSchema())\n        });\n      } else {\n        internalValue = new asn1js.Constructed({\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 1 // [1]\n\n          },\n          value: [this.distributionPoint.toSchema()]\n        });\n      }\n\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [internalValue]\n      }));\n    }\n\n    if (\"reasons\" in this) {\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        valueHex: this.reasons.valueBlock.valueHex\n      }));\n    }\n\n    if (\"cRLIssuer\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        value: Array.from(this.cRLIssuer, element => element.toSchema())\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {};\n\n    if (\"distributionPoint\" in this) {\n      if (this.distributionPoint instanceof Array) object.distributionPoint = Array.from(this.distributionPoint, element => element.toJSON());else object.distributionPoint = this.distributionPoint.toJSON();\n    }\n\n    if (\"reasons\" in this) object.reasons = this.reasons.toJSON();\n    if (\"cRLIssuer\" in this) object.cRLIssuer = Array.from(this.cRLIssuer, element => element.toJSON());\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = DistributionPoint;\n//# sourceMappingURL=DistributionPoint.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/DistributionPoint.js\n// module id = ./node_modules/pkijs/build/DistributionPoint.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC6318\r\n */\nclass ECCCMSSharedInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for ECCCMSSharedInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc keyInfo\r\n     */\n    this.keyInfo = (0, _pvutils.getParametersValue)(parameters, \"keyInfo\", ECCCMSSharedInfo.defaultValues(\"keyInfo\"));\n    if (\"entityUInfo\" in parameters)\n      /**\r\n       * @type {OctetString}\r\n       * @desc entityUInfo\r\n       */\n      this.entityUInfo = (0, _pvutils.getParametersValue)(parameters, \"entityUInfo\", ECCCMSSharedInfo.defaultValues(\"entityUInfo\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc suppPubInfo\r\n     */\n\n    this.suppPubInfo = (0, _pvutils.getParametersValue)(parameters, \"suppPubInfo\", ECCCMSSharedInfo.defaultValues(\"suppPubInfo\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"keyInfo\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"entityUInfo\":\n        return new asn1js.OctetString();\n\n      case \"suppPubInfo\":\n        return new asn1js.OctetString();\n\n      default:\n        throw new Error(`Invalid member name for ECCCMSSharedInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"keyInfo\":\n      case \"entityUInfo\":\n      case \"suppPubInfo\":\n        return memberValue.isEqual(ECCCMSSharedInfo.defaultValues(memberName));\n\n      default:\n        throw new Error(`Invalid member name for ECCCMSSharedInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * ECC-CMS-SharedInfo  ::=  SEQUENCE {\r\n   *    keyInfo      AlgorithmIdentifier,\r\n   *    entityUInfo  [0] EXPLICIT OCTET STRING OPTIONAL,\r\n   *    suppPubInfo  [2] EXPLICIT OCTET STRING }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [keyInfo]\r\n     * @property {string} [entityUInfo]\r\n     * @property {string} [suppPubInfo]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_AlgorithmIdentifier.default.schema(names.keyInfo || {}), new asn1js.Constructed({\n        name: names.entityUInfo || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        optional: true,\n        value: [new asn1js.OctetString()]\n      }), new asn1js.Constructed({\n        name: names.suppPubInfo || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        value: [new asn1js.OctetString()]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"keyInfo\", \"entityUInfo\", \"suppPubInfo\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, ECCCMSSharedInfo.schema({\n      names: {\n        keyInfo: {\n          names: {\n            blockName: \"keyInfo\"\n          }\n        },\n        entityUInfo: \"entityUInfo\",\n        suppPubInfo: \"suppPubInfo\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for ECCCMSSharedInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.keyInfo = new _AlgorithmIdentifier.default({\n      schema: asn1.result.keyInfo\n    });\n    if (\"entityUInfo\" in asn1.result) this.entityUInfo = asn1.result.entityUInfo.valueBlock.value[0];\n    this.suppPubInfo = asn1.result.suppPubInfo.valueBlock.value[0]; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create output array for sequence \n    const outputArray = [];\n    outputArray.push(this.keyInfo.toSchema());\n\n    if (\"entityUInfo\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [this.entityUInfo]\n      }));\n    }\n\n    outputArray.push(new asn1js.Constructed({\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 2 // [2]\n\n      },\n      value: [this.suppPubInfo]\n    })); //endregion \n    //region Construct and return new ASN.1 schema for this object \n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion \n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      keyInfo: this.keyInfo.toJSON()\n    };\n    if (\"entityUInfo\" in this) _object.entityUInfo = this.entityUInfo.toJSON();\n    _object.suppPubInfo = this.suppPubInfo.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = ECCCMSSharedInfo;\n//# sourceMappingURL=ECCCMSSharedInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/ECCCMSSharedInfo.js\n// module id = ./node_modules/pkijs/build/ECCCMSSharedInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _ECPublicKey = _interopRequireDefault(require(\"./ECPublicKey.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5915\r\n */\nclass ECPrivateKey {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for ECPrivateKey class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", ECPrivateKey.defaultValues(\"version\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc privateKey\r\n     */\n\n    this.privateKey = (0, _pvutils.getParametersValue)(parameters, \"privateKey\", ECPrivateKey.defaultValues(\"privateKey\"));\n    if (\"namedCurve\" in parameters)\n      /**\r\n       * @type {string}\r\n       * @desc namedCurve\r\n       */\n      this.namedCurve = (0, _pvutils.getParametersValue)(parameters, \"namedCurve\", ECPrivateKey.defaultValues(\"namedCurve\"));\n    if (\"publicKey\" in parameters)\n      /**\r\n       * @type {ECPublicKey}\r\n       * @desc publicKey\r\n       */\n      this.publicKey = (0, _pvutils.getParametersValue)(parameters, \"publicKey\", ECPrivateKey.defaultValues(\"publicKey\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n    //region If input argument array contains \"json\" for this object\n\n    if (\"json\" in parameters) this.fromJSON(parameters.json); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 1;\n\n      case \"privateKey\":\n        return new asn1js.OctetString();\n\n      case \"namedCurve\":\n        return \"\";\n\n      case \"publicKey\":\n        return new _ECPublicKey.default();\n\n      default:\n        throw new Error(`Invalid member name for ECCPrivateKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n        return memberValue === ECPrivateKey.defaultValues(memberName);\n\n      case \"privateKey\":\n        return memberValue.isEqual(ECPrivateKey.defaultValues(memberName));\n\n      case \"namedCurve\":\n        return memberValue === \"\";\n\n      case \"publicKey\":\n        return _ECPublicKey.default.compareWithDefault(\"namedCurve\", memberValue.namedCurve) && _ECPublicKey.default.compareWithDefault(\"x\", memberValue.x) && _ECPublicKey.default.compareWithDefault(\"y\", memberValue.y);\n\n      default:\n        throw new Error(`Invalid member name for ECCPrivateKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * ECPrivateKey ::= SEQUENCE {\r\n   * version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),\r\n   * privateKey     OCTET STRING,\r\n   * parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,\r\n   * publicKey  [1] BIT STRING OPTIONAL\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [privateKey]\r\n     * @property {string} [namedCurve]\r\n     * @property {string} [publicKey]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), new asn1js.OctetString({\n        name: names.privateKey || \"\"\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.ObjectIdentifier({\n          name: names.namedCurve || \"\"\n        })]\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [new asn1js.BitString({\n          name: names.publicKey || \"\"\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"privateKey\", \"namedCurve\", \"publicKey\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, ECPrivateKey.schema({\n      names: {\n        version: \"version\",\n        privateKey: \"privateKey\",\n        namedCurve: \"namedCurve\",\n        publicKey: \"publicKey\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for ECPrivateKey\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n    this.privateKey = asn1.result.privateKey;\n    if (\"namedCurve\" in asn1.result) this.namedCurve = asn1.result.namedCurve.valueBlock.toString();\n\n    if (\"publicKey\" in asn1.result) {\n      const publicKeyData = {\n        schema: asn1.result.publicKey.valueBlock.valueHex\n      };\n      if (\"namedCurve\" in this) publicKeyData.namedCurve = this.namedCurve;\n      this.publicKey = new _ECPublicKey.default(publicKeyData);\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    const outputArray = [new asn1js.Integer({\n      value: this.version\n    }), this.privateKey];\n\n    if (\"namedCurve\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.ObjectIdentifier({\n          value: this.namedCurve\n        })]\n      }));\n    }\n\n    if (\"publicKey\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [new asn1js.BitString({\n          valueHex: this.publicKey.toSchema().toBER(false)\n        })]\n      }));\n    }\n\n    return new asn1js.Sequence({\n      value: outputArray\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    if (\"namedCurve\" in this === false || ECPrivateKey.compareWithDefault(\"namedCurve\", this.namedCurve)) throw new Error(\"Not enough information for making JSON: absent \\\"namedCurve\\\" value\");\n    let crvName = \"\";\n\n    switch (this.namedCurve) {\n      case \"1.2.840.10045.3.1.7\":\n        // P-256\n        crvName = \"P-256\";\n        break;\n\n      case \"1.3.132.0.34\":\n        // P-384\n        crvName = \"P-384\";\n        break;\n\n      case \"1.3.132.0.35\":\n        // P-521\n        crvName = \"P-521\";\n        break;\n\n      default:\n    }\n\n    const privateKeyJSON = {\n      crv: crvName,\n      d: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.privateKey.valueBlock.valueHex), true, true, false)\n    };\n\n    if (\"publicKey\" in this) {\n      const publicKeyJSON = this.publicKey.toJSON();\n      privateKeyJSON.x = publicKeyJSON.x;\n      privateKeyJSON.y = publicKeyJSON.y;\n    }\n\n    return privateKeyJSON;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert JSON value into current object\r\n   * @param {Object} json\r\n   */\n\n\n  fromJSON(json) {\n    let coodinateLength = 0;\n\n    if (\"crv\" in json) {\n      switch (json.crv.toUpperCase()) {\n        case \"P-256\":\n          this.namedCurve = \"1.2.840.10045.3.1.7\";\n          coodinateLength = 32;\n          break;\n\n        case \"P-384\":\n          this.namedCurve = \"1.3.132.0.34\";\n          coodinateLength = 48;\n          break;\n\n        case \"P-521\":\n          this.namedCurve = \"1.3.132.0.35\";\n          coodinateLength = 66;\n          break;\n\n        default:\n      }\n    } else throw new Error(\"Absent mandatory parameter \\\"crv\\\"\");\n\n    if (\"d\" in json) {\n      const convertBuffer = (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.d, true));\n\n      if (convertBuffer.byteLength < coodinateLength) {\n        const buffer = new ArrayBuffer(coodinateLength);\n        const view = new Uint8Array(buffer);\n        const convertBufferView = new Uint8Array(convertBuffer);\n        view.set(convertBufferView, 1);\n        this.privateKey = new asn1js.OctetString({\n          valueHex: buffer\n        });\n      } else this.privateKey = new asn1js.OctetString({\n        valueHex: convertBuffer.slice(0, coodinateLength)\n      });\n    } else throw new Error(\"Absent mandatory parameter \\\"d\\\"\");\n\n    if (\"x\" in json && \"y\" in json) this.publicKey = new _ECPublicKey.default({\n      json\n    });\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = ECPrivateKey;\n//# sourceMappingURL=ECPrivateKey.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/ECPrivateKey.js\n// module id = ./node_modules/pkijs/build/ECPrivateKey.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5480\r\n */\nclass ECPublicKey {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for ECCPublicKey class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc type\r\n     */\n    this.x = (0, _pvutils.getParametersValue)(parameters, \"x\", ECPublicKey.defaultValues(\"x\"));\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc values\r\n     */\n\n    this.y = (0, _pvutils.getParametersValue)(parameters, \"y\", ECPublicKey.defaultValues(\"y\"));\n    /**\r\n     * @type {string}\r\n     * @desc namedCurve\r\n     */\n\n    this.namedCurve = (0, _pvutils.getParametersValue)(parameters, \"namedCurve\", ECPublicKey.defaultValues(\"namedCurve\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n    //region If input argument array contains \"json\" for this object\n\n    if (\"json\" in parameters) this.fromJSON(parameters.json); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"x\":\n      case \"y\":\n        return new ArrayBuffer(0);\n\n      case \"namedCurve\":\n        return \"\";\n\n      default:\n        throw new Error(`Invalid member name for ECCPublicKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"x\":\n      case \"y\":\n        return (0, _pvutils.isEqualBuffer)(memberValue, ECPublicKey.defaultValues(memberName));\n\n      case \"namedCurve\":\n        return memberValue === \"\";\n\n      default:\n        throw new Error(`Invalid member name for ECCPublicKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    return new asn1js.RawData();\n  } //**********************************************************************************\n\n  /**\r\n   * Convert ArrayBuffer into current class\r\n   * @param {!ArrayBuffer} schema Special case: schema is an ArrayBuffer\r\n   */\n\n\n  fromSchema(schema) {\n    //region Check the schema is valid\n    if (schema instanceof ArrayBuffer === false) throw new Error(\"Object's schema was not verified against input data for ECPublicKey\");\n    const view = new Uint8Array(schema);\n    if (view[0] !== 0x04) throw new Error(\"Object's schema was not verified against input data for ECPublicKey\"); //endregion\n    //region Get internal properties from parsed schema\n\n    let coordinateLength;\n\n    switch (this.namedCurve) {\n      case \"1.2.840.10045.3.1.7\":\n        // P-256\n        coordinateLength = 32;\n        break;\n\n      case \"1.3.132.0.34\":\n        // P-384\n        coordinateLength = 48;\n        break;\n\n      case \"1.3.132.0.35\":\n        // P-521\n        coordinateLength = 66;\n        break;\n\n      default:\n        throw new Error(`Incorrect curve OID: ${this.namedCurve}`);\n    }\n\n    if (schema.byteLength !== coordinateLength * 2 + 1) throw new Error(\"Object's schema was not verified against input data for ECPublicKey\");\n    this.x = schema.slice(1, coordinateLength + 1);\n    this.y = schema.slice(1 + coordinateLength, coordinateLength * 2 + 1); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    return new asn1js.RawData({\n      data: (0, _pvutils.utilConcatBuf)(new Uint8Array([0x04]).buffer, this.x, this.y)\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let crvName = \"\";\n\n    switch (this.namedCurve) {\n      case \"1.2.840.10045.3.1.7\":\n        // P-256\n        crvName = \"P-256\";\n        break;\n\n      case \"1.3.132.0.34\":\n        // P-384\n        crvName = \"P-384\";\n        break;\n\n      case \"1.3.132.0.35\":\n        // P-521\n        crvName = \"P-521\";\n        break;\n\n      default:\n    }\n\n    return {\n      crv: crvName,\n      x: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.x), true, true, false),\n      y: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.y), true, true, false)\n    };\n  } //**********************************************************************************\n\n  /**\r\n   * Convert JSON value into current object\r\n   * @param {Object} json\r\n   */\n\n\n  fromJSON(json) {\n    let coodinateLength = 0;\n\n    if (\"crv\" in json) {\n      switch (json.crv.toUpperCase()) {\n        case \"P-256\":\n          this.namedCurve = \"1.2.840.10045.3.1.7\";\n          coodinateLength = 32;\n          break;\n\n        case \"P-384\":\n          this.namedCurve = \"1.3.132.0.34\";\n          coodinateLength = 48;\n          break;\n\n        case \"P-521\":\n          this.namedCurve = \"1.3.132.0.35\";\n          coodinateLength = 66;\n          break;\n\n        default:\n      }\n    } else throw new Error(\"Absent mandatory parameter \\\"crv\\\"\");\n\n    if (\"x\" in json) {\n      const convertBuffer = (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.x, true));\n\n      if (convertBuffer.byteLength < coodinateLength) {\n        this.x = new ArrayBuffer(coodinateLength);\n        const view = new Uint8Array(this.x);\n        const convertBufferView = new Uint8Array(convertBuffer);\n        view.set(convertBufferView, 1);\n      } else this.x = convertBuffer.slice(0, coodinateLength);\n    } else throw new Error(\"Absent mandatory parameter \\\"x\\\"\");\n\n    if (\"y\" in json) {\n      const convertBuffer = (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.y, true));\n\n      if (convertBuffer.byteLength < coodinateLength) {\n        this.y = new ArrayBuffer(coodinateLength);\n        const view = new Uint8Array(this.y);\n        const convertBufferView = new Uint8Array(convertBuffer);\n        view.set(convertBufferView, 1);\n      } else this.y = convertBuffer.slice(0, coodinateLength);\n    } else throw new Error(\"Absent mandatory parameter \\\"y\\\"\");\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = ECPublicKey;\n//# sourceMappingURL=ECPublicKey.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/ECPublicKey.js\n// module id = ./node_modules/pkijs/build/ECPublicKey.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass EncapsulatedContentInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for EncapsulatedContentInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc eContentType\r\n     */\n    this.eContentType = (0, _pvutils.getParametersValue)(parameters, \"eContentType\", EncapsulatedContentInfo.defaultValues(\"eContentType\"));\n\n    if (\"eContent\" in parameters) {\n      /**\r\n       * @type {OctetString}\r\n       * @desc eContent\r\n       */\n      this.eContent = (0, _pvutils.getParametersValue)(parameters, \"eContent\", EncapsulatedContentInfo.defaultValues(\"eContent\"));\n\n      if (this.eContent.idBlock.tagClass === 1 && this.eContent.idBlock.tagNumber === 4) {\n        //region Divide OCTETSTRING value down to small pieces\n        if (this.eContent.idBlock.isConstructed === false) {\n          const constrString = new asn1js.OctetString({\n            idBlock: {\n              isConstructed: true\n            },\n            isConstructed: true\n          });\n          let offset = 0;\n          let length = this.eContent.valueBlock.valueHex.byteLength;\n\n          while (length > 0) {\n            const pieceView = new Uint8Array(this.eContent.valueBlock.valueHex, offset, offset + 65536 > this.eContent.valueBlock.valueHex.byteLength ? this.eContent.valueBlock.valueHex.byteLength - offset : 65536);\n\n            const _array = new ArrayBuffer(pieceView.length);\n\n            const _view = new Uint8Array(_array);\n\n            for (let i = 0; i < _view.length; i++) _view[i] = pieceView[i];\n\n            constrString.valueBlock.value.push(new asn1js.OctetString({\n              valueHex: _array\n            }));\n            length -= pieceView.length;\n            offset += pieceView.length;\n          }\n\n          this.eContent = constrString;\n        } //endregion\n\n      }\n    } //endregion\n    //region If input argument array contains \"schema\" for this object\n\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"eContentType\":\n        return \"\";\n\n      case \"eContent\":\n        return new asn1js.OctetString();\n\n      default:\n        throw new Error(`Invalid member name for EncapsulatedContentInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"eContentType\":\n        return memberValue === \"\";\n\n      case \"eContent\":\n        {\n          if (memberValue.idBlock.tagClass === 1 && memberValue.idBlock.tagNumber === 4) return memberValue.isEqual(EncapsulatedContentInfo.defaultValues(\"eContent\"));\n          return false;\n        }\n\n      default:\n        throw new Error(`Invalid member name for EncapsulatedContentInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * EncapsulatedContentInfo ::= SEQUENCE {\r\n   *    eContentType ContentType,\r\n   *    eContent [0] EXPLICIT OCTET STRING OPTIONAL } * Changed it to ANY, as in PKCS#7\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [type]\r\n     * @property {string} [setName]\r\n     * @property {string} [values]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.eContentType || \"\"\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Any({\n          name: names.eContent || \"\"\n        }) // In order to aling this with PKCS#7 and CMS as well\n        ]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"eContentType\", \"eContent\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, EncapsulatedContentInfo.schema({\n      names: {\n        eContentType: \"eContentType\",\n        eContent: \"eContent\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for EncapsulatedContentInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.eContentType = asn1.result.eContentType.valueBlock.toString();\n    if (\"eContent\" in asn1.result) this.eContent = asn1.result.eContent; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence \n    const outputArray = [];\n    outputArray.push(new asn1js.ObjectIdentifier({\n      value: this.eContentType\n    }));\n\n    if (\"eContent\" in this) {\n      if (EncapsulatedContentInfo.compareWithDefault(\"eContent\", this.eContent) === false) {\n        outputArray.push(new asn1js.Constructed({\n          optional: true,\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: [this.eContent]\n        }));\n      }\n    } //endregion \n    //region Construct and return new ASN.1 schema for this object \n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion \n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      eContentType: this.eContentType\n    };\n\n    if (\"eContent\" in this) {\n      if (EncapsulatedContentInfo.compareWithDefault(\"eContent\", this.eContent) === false) _object.eContent = this.eContent.toJSON();\n    }\n\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = EncapsulatedContentInfo;\n//# sourceMappingURL=EncapsulatedContentInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/EncapsulatedContentInfo.js\n// module id = ./node_modules/pkijs/build/EncapsulatedContentInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass EncryptedContentInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for EncryptedContentInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc contentType\r\n     */\n    this.contentType = (0, _pvutils.getParametersValue)(parameters, \"contentType\", EncryptedContentInfo.defaultValues(\"contentType\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc contentEncryptionAlgorithm\r\n     */\n\n    this.contentEncryptionAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"contentEncryptionAlgorithm\", EncryptedContentInfo.defaultValues(\"contentEncryptionAlgorithm\"));\n\n    if (\"encryptedContent\" in parameters) {\n      /**\r\n       * @type {OctetString}\r\n       * @desc encryptedContent (!!!) could be contructive or primitive value (!!!)\r\n       */\n      this.encryptedContent = parameters.encryptedContent;\n\n      if (this.encryptedContent.idBlock.tagClass === 1 && this.encryptedContent.idBlock.tagNumber === 4) {\n        //region Divide OCTETSTRING value down to small pieces\n        if (this.encryptedContent.idBlock.isConstructed === false) {\n          const constrString = new asn1js.OctetString({\n            idBlock: {\n              isConstructed: true\n            },\n            isConstructed: true\n          });\n          let offset = 0;\n          let length = this.encryptedContent.valueBlock.valueHex.byteLength;\n\n          while (length > 0) {\n            const pieceView = new Uint8Array(this.encryptedContent.valueBlock.valueHex, offset, offset + 1024 > this.encryptedContent.valueBlock.valueHex.byteLength ? this.encryptedContent.valueBlock.valueHex.byteLength - offset : 1024);\n\n            const _array = new ArrayBuffer(pieceView.length);\n\n            const _view = new Uint8Array(_array);\n\n            for (let i = 0; i < _view.length; i++) _view[i] = pieceView[i];\n\n            constrString.valueBlock.value.push(new asn1js.OctetString({\n              valueHex: _array\n            }));\n            length -= pieceView.length;\n            offset += pieceView.length;\n          }\n\n          this.encryptedContent = constrString;\n        } //endregion\n\n      }\n    } //endregion\n    //region If input argument array contains \"schema\" for this object\n\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"contentType\":\n        return \"\";\n\n      case \"contentEncryptionAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"encryptedContent\":\n        return new asn1js.OctetString();\n\n      default:\n        throw new Error(`Invalid member name for EncryptedContentInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"contentType\":\n        return memberValue === \"\";\n\n      case \"contentEncryptionAlgorithm\":\n        return memberValue.algorithmId === \"\" && \"algorithmParams\" in memberValue === false;\n\n      case \"encryptedContent\":\n        return memberValue.isEqual(EncryptedContentInfo.defaultValues(memberName));\n\n      default:\n        throw new Error(`Invalid member name for EncryptedContentInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * EncryptedContentInfo ::= SEQUENCE {\r\n   *    contentType ContentType,\r\n   *    contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,\r\n   *    encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }\r\n   *\r\n   * Comment: Strange, but modern crypto engines create \"encryptedContent\" as \"[0] EXPLICIT EncryptedContent\"\r\n   *\r\n   * EncryptedContent ::= OCTET STRING\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [contentType]\r\n     * @property {string} [contentEncryptionAlgorithm]\r\n     * @property {string} [encryptedContent]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.contentType || \"\"\n      }), _AlgorithmIdentifier.default.schema(names.contentEncryptionAlgorithm || {}), // The CHOICE we need because \"EncryptedContent\" could have either \"constructive\"\n      // or \"primitive\" form of encoding and we need to handle both variants\n      new asn1js.Choice({\n        value: [new asn1js.Constructed({\n          name: names.encryptedContent || \"\",\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: [new asn1js.Repeated({\n            value: new asn1js.OctetString()\n          })]\n        }), new asn1js.Primitive({\n          name: names.encryptedContent || \"\",\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          }\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"contentType\", \"contentEncryptionAlgorithm\", \"encryptedContent\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, EncryptedContentInfo.schema({\n      names: {\n        contentType: \"contentType\",\n        contentEncryptionAlgorithm: {\n          names: {\n            blockName: \"contentEncryptionAlgorithm\"\n          }\n        },\n        encryptedContent: \"encryptedContent\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for EncryptedContentInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.contentType = asn1.result.contentType.valueBlock.toString();\n    this.contentEncryptionAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.contentEncryptionAlgorithm\n    });\n\n    if (\"encryptedContent\" in asn1.result) {\n      this.encryptedContent = asn1.result.encryptedContent;\n      this.encryptedContent.idBlock.tagClass = 1; // UNIVERSAL\n\n      this.encryptedContent.idBlock.tagNumber = 4; // OCTETSTRING (!!!) The value still has instance of \"in_window.org.pkijs.asn1.ASN1_CONSTRUCTED / ASN1_PRIMITIVE\"\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const sequenceLengthBlock = {\n      isIndefiniteForm: false\n    };\n    const outputArray = [];\n    outputArray.push(new asn1js.ObjectIdentifier({\n      value: this.contentType\n    }));\n    outputArray.push(this.contentEncryptionAlgorithm.toSchema());\n\n    if (\"encryptedContent\" in this) {\n      sequenceLengthBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;\n      const encryptedValue = this.encryptedContent;\n      encryptedValue.idBlock.tagClass = 3; // CONTEXT-SPECIFIC\n\n      encryptedValue.idBlock.tagNumber = 0; // [0]\n\n      encryptedValue.lenBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;\n      outputArray.push(encryptedValue);\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      lenBlock: sequenceLengthBlock,\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      contentType: this.contentType,\n      contentEncryptionAlgorithm: this.contentEncryptionAlgorithm.toJSON()\n    };\n    if (\"encryptedContent\" in this) _object.encryptedContent = this.encryptedContent.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = EncryptedContentInfo;\n//# sourceMappingURL=EncryptedContentInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/EncryptedContentInfo.js\n// module id = ./node_modules/pkijs/build/EncryptedContentInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _EncryptedContentInfo = _interopRequireDefault(require(\"./EncryptedContentInfo.js\"));\n\nvar _Attribute = _interopRequireDefault(require(\"./Attribute.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass EncryptedData {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for EncryptedData class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", EncryptedData.defaultValues(\"version\"));\n    /**\r\n     * @type {EncryptedContentInfo}\r\n     * @desc encryptedContentInfo\r\n     */\n\n    this.encryptedContentInfo = (0, _pvutils.getParametersValue)(parameters, \"encryptedContentInfo\", EncryptedData.defaultValues(\"encryptedContentInfo\"));\n    if (\"unprotectedAttrs\" in parameters)\n      /**\r\n       * @type {Array.<Attribute>}\r\n       * @desc unprotectedAttrs\r\n       */\n      this.unprotectedAttrs = (0, _pvutils.getParametersValue)(parameters, \"unprotectedAttrs\", EncryptedData.defaultValues(\"unprotectedAttrs\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"encryptedContentInfo\":\n        return new _EncryptedContentInfo.default();\n\n      case \"unprotectedAttrs\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for EncryptedData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n        return memberValue === 0;\n\n      case \"encryptedContentInfo\":\n        return _EncryptedContentInfo.default.compareWithDefault(\"contentType\", memberValue.contentType) && _EncryptedContentInfo.default.compareWithDefault(\"contentEncryptionAlgorithm\", memberValue.contentEncryptionAlgorithm) && _EncryptedContentInfo.default.compareWithDefault(\"encryptedContent\", memberValue.encryptedContent);\n\n      case \"unprotectedAttrs\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for EncryptedData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * EncryptedData ::= SEQUENCE {\r\n   *    version CMSVersion,\r\n   *    encryptedContentInfo EncryptedContentInfo,\r\n   *    unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [encryptedContentInfo]\r\n     * @property {string} [unprotectedAttrs]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), _EncryptedContentInfo.default.schema(names.encryptedContentInfo || {}), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [new asn1js.Repeated({\n          name: names.unprotectedAttrs || \"\",\n          value: _Attribute.default.schema()\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"encryptedContentInfo\", \"unprotectedAttrs\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, EncryptedData.schema({\n      names: {\n        version: \"version\",\n        encryptedContentInfo: {\n          names: {\n            blockName: \"encryptedContentInfo\"\n          }\n        },\n        unprotectedAttrs: \"unprotectedAttrs\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for EncryptedData\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n    this.encryptedContentInfo = new _EncryptedContentInfo.default({\n      schema: asn1.result.encryptedContentInfo\n    });\n    if (\"unprotectedAttrs\" in asn1.result) this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, element => new _Attribute.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.Integer({\n      value: this.version\n    }));\n    outputArray.push(this.encryptedContentInfo.toSchema());\n\n    if (\"unprotectedAttrs\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: Array.from(this.unprotectedAttrs, element => element.toSchema())\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      version: this.version,\n      encryptedContentInfo: this.encryptedContentInfo.toJSON()\n    };\n    if (\"unprotectedAttrs\" in this) _object.unprotectedAttrs = Array.from(this.unprotectedAttrs, element => element.toJSON());\n    return _object;\n  } //**********************************************************************************\n\n  /**\r\n   * Create a new CMS Encrypted Data content\r\n   * @param {Object} parameters Parameters neccessary for encryption\r\n   * @returns {Promise}\r\n   */\n\n\n  encrypt(parameters) {\n    //region Check for input parameters\n    if (parameters instanceof Object === false) return Promise.reject(\"Parameters must have type \\\"Object\\\"\"); //endregion\n    //region Get cryptographic engine\n\n    const engine = (0, _common.getEngine)();\n    if (typeof engine === \"undefined\") return Promise.reject(\"Unable to initialize cryptographic engine\"); //endregion\n    //region Set \"contentType\" parameter\n\n    parameters.contentType = \"1.2.840.113549.1.7.1\"; // \"data\"\n    //endregion\n\n    if (\"encryptEncryptedContentInfo\" in engine.subtle) {\n      return engine.subtle.encryptEncryptedContentInfo(parameters).then(result => {\n        this.encryptedContentInfo = result;\n      });\n    }\n\n    return Promise.reject(`No support for \"encryptEncryptedContentInfo\" in current crypto engine ${engine.name}`);\n  } //**********************************************************************************\n\n  /**\r\n   * Create a new CMS Encrypted Data content\r\n   * @param {Object} parameters Parameters neccessary for encryption\r\n   */\n\n\n  decrypt(parameters) {\n    //region Check for input parameters\n    if (parameters instanceof Object === false) return Promise.reject(\"Parameters must have type \\\"Object\\\"\"); //endregion\n    //region Get cryptographic engine\n\n    const engine = (0, _common.getEngine)();\n    if (typeof engine === \"undefined\") return Promise.reject(\"Unable to initialize cryptographic engine\"); //endregion\n    //region Set \"encryptedContentInfo\" value\n\n    parameters.encryptedContentInfo = this.encryptedContentInfo; //endregion\n\n    if (\"decryptEncryptedContentInfo\" in engine.subtle) return engine.subtle.decryptEncryptedContentInfo(parameters);\n    return Promise.reject(`No support for \"decryptEncryptedContentInfo\" in current crypto engine ${engine.name}`);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = EncryptedData;\n//# sourceMappingURL=EncryptedData.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/EncryptedData.js\n// module id = ./node_modules/pkijs/build/EncryptedData.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _OriginatorInfo = _interopRequireDefault(require(\"./OriginatorInfo.js\"));\n\nvar _RecipientInfo = _interopRequireDefault(require(\"./RecipientInfo.js\"));\n\nvar _EncryptedContentInfo = _interopRequireDefault(require(\"./EncryptedContentInfo.js\"));\n\nvar _Attribute = _interopRequireDefault(require(\"./Attribute.js\"));\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _RSAESOAEPParams = _interopRequireDefault(require(\"./RSAESOAEPParams.js\"));\n\nvar _KeyTransRecipientInfo = _interopRequireDefault(require(\"./KeyTransRecipientInfo.js\"));\n\nvar _IssuerAndSerialNumber = _interopRequireDefault(require(\"./IssuerAndSerialNumber.js\"));\n\nvar _RecipientEncryptedKey = _interopRequireDefault(require(\"./RecipientEncryptedKey.js\"));\n\nvar _KeyAgreeRecipientIdentifier = _interopRequireDefault(require(\"./KeyAgreeRecipientIdentifier.js\"));\n\nvar _KeyAgreeRecipientInfo = _interopRequireDefault(require(\"./KeyAgreeRecipientInfo.js\"));\n\nvar _RecipientEncryptedKeys = _interopRequireDefault(require(\"./RecipientEncryptedKeys.js\"));\n\nvar _KEKRecipientInfo = _interopRequireDefault(require(\"./KEKRecipientInfo.js\"));\n\nvar _KEKIdentifier = _interopRequireDefault(require(\"./KEKIdentifier.js\"));\n\nvar _PBKDF2Params = _interopRequireDefault(require(\"./PBKDF2Params.js\"));\n\nvar _PasswordRecipientinfo = _interopRequireDefault(require(\"./PasswordRecipientinfo.js\"));\n\nvar _ECCCMSSharedInfo = _interopRequireDefault(require(\"./ECCCMSSharedInfo.js\"));\n\nvar _OriginatorIdentifierOrKey = _interopRequireDefault(require(\"./OriginatorIdentifierOrKey.js\"));\n\nvar _OriginatorPublicKey = _interopRequireDefault(require(\"./OriginatorPublicKey.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass EnvelopedData {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for EnvelopedData class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", EnvelopedData.defaultValues(\"version\"));\n    if (\"originatorInfo\" in parameters)\n      /**\r\n       * @type {OriginatorInfo}\r\n       * @desc originatorInfo\r\n       */\n      this.originatorInfo = (0, _pvutils.getParametersValue)(parameters, \"originatorInfo\", EnvelopedData.defaultValues(\"originatorInfo\"));\n    /**\r\n     * @type {Array.<RecipientInfo>}\r\n     * @desc recipientInfos\r\n     */\n\n    this.recipientInfos = (0, _pvutils.getParametersValue)(parameters, \"recipientInfos\", EnvelopedData.defaultValues(\"recipientInfos\"));\n    /**\r\n     * @type {EncryptedContentInfo}\r\n     * @desc encryptedContentInfo\r\n     */\n\n    this.encryptedContentInfo = (0, _pvutils.getParametersValue)(parameters, \"encryptedContentInfo\", EnvelopedData.defaultValues(\"encryptedContentInfo\"));\n    if (\"unprotectedAttrs\" in parameters)\n      /**\r\n       * @type {Array.<Attribute>}\r\n       * @desc unprotectedAttrs\r\n       */\n      this.unprotectedAttrs = (0, _pvutils.getParametersValue)(parameters, \"unprotectedAttrs\", EnvelopedData.defaultValues(\"unprotectedAttrs\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"originatorInfo\":\n        return new _OriginatorInfo.default();\n\n      case \"recipientInfos\":\n        return [];\n\n      case \"encryptedContentInfo\":\n        return new _EncryptedContentInfo.default();\n\n      case \"unprotectedAttrs\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n        return memberValue === EnvelopedData.defaultValues(memberName);\n\n      case \"originatorInfo\":\n        return memberValue.certs.certificates.length === 0 && memberValue.crls.crls.length === 0;\n\n      case \"recipientInfos\":\n      case \"unprotectedAttrs\":\n        return memberValue.length === 0;\n\n      case \"encryptedContentInfo\":\n        return _EncryptedContentInfo.default.compareWithDefault(\"contentType\", memberValue.contentType) && _EncryptedContentInfo.default.compareWithDefault(\"contentEncryptionAlgorithm\", memberValue.contentEncryptionAlgorithm) && _EncryptedContentInfo.default.compareWithDefault(\"encryptedContent\", memberValue.encryptedContent);\n\n      default:\n        throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * EnvelopedData ::= SEQUENCE {\r\n   *    version CMSVersion,\r\n   *    originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,\r\n   *    recipientInfos RecipientInfos,\r\n   *    encryptedContentInfo EncryptedContentInfo,\r\n   *    unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [originatorInfo]\r\n     * @property {string} [recipientInfos]\r\n     * @property {string} [encryptedContentInfo]\r\n     * @property {string} [unprotectedAttrs]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), new asn1js.Constructed({\n        name: names.originatorInfo || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: _OriginatorInfo.default.schema().valueBlock.value\n      }), new asn1js.Set({\n        value: [new asn1js.Repeated({\n          name: names.recipientInfos || \"\",\n          value: _RecipientInfo.default.schema()\n        })]\n      }), _EncryptedContentInfo.default.schema(names.encryptedContentInfo || {}), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [new asn1js.Repeated({\n          name: names.unprotectedAttrs || \"\",\n          value: _Attribute.default.schema()\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"originatorInfo\", \"recipientInfos\", \"encryptedContentInfo\", \"unprotectedAttrs\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, EnvelopedData.schema({\n      names: {\n        version: \"version\",\n        originatorInfo: \"originatorInfo\",\n        recipientInfos: \"recipientInfos\",\n        encryptedContentInfo: {\n          names: {\n            blockName: \"encryptedContentInfo\"\n          }\n        },\n        unprotectedAttrs: \"unprotectedAttrs\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for EnvelopedData\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n\n    if (\"originatorInfo\" in asn1.result) {\n      this.originatorInfo = new _OriginatorInfo.default({\n        schema: new asn1js.Sequence({\n          value: asn1.result.originatorInfo.valueBlock.value\n        })\n      });\n    }\n\n    this.recipientInfos = Array.from(asn1.result.recipientInfos, element => new _RecipientInfo.default({\n      schema: element\n    }));\n    this.encryptedContentInfo = new _EncryptedContentInfo.default({\n      schema: asn1.result.encryptedContentInfo\n    });\n    if (\"unprotectedAttrs\" in asn1.result) this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, element => new _Attribute.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.Integer({\n      value: this.version\n    }));\n\n    if (\"originatorInfo\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: this.originatorInfo.toSchema().valueBlock.value\n      }));\n    }\n\n    outputArray.push(new asn1js.Set({\n      value: Array.from(this.recipientInfos, element => element.toSchema())\n    }));\n    outputArray.push(this.encryptedContentInfo.toSchema());\n\n    if (\"unprotectedAttrs\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: Array.from(this.unprotectedAttrs, element => element.toSchema())\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      version: this.version\n    };\n    if (\"originatorInfo\" in this) _object.originatorInfo = this.originatorInfo.toJSON();\n    _object.recipientInfos = Array.from(this.recipientInfos, element => element.toJSON());\n    _object.encryptedContentInfo = this.encryptedContentInfo.toJSON();\n    if (\"unprotectedAttrs\" in this) _object.unprotectedAttrs = Array.from(this.unprotectedAttrs, element => element.toJSON());\n    return _object;\n  } //**********************************************************************************\n\n  /**\r\n   * Helpers function for filling \"RecipientInfo\" based on recipient's certificate.\r\n   * Problem with WebCrypto is that for RSA certificates we have only one option - \"key transport\" and\r\n   * for ECC certificates we also have one option - \"key agreement\". As soon as Google will implement\r\n   * DH algorithm it would be possible to use \"key agreement\" also for RSA certificates.\r\n   * @param {Certificate} [certificate] Recipient's certificate\r\n   * @param {Object} [parameters] Additional parameters neccessary for \"fine tunning\" of encryption process\r\n   * @param {number} [variant] Variant = 1 is for \"key transport\", variant = 2 is for \"key agreement\". In fact the \"variant\" is unneccessary now because Google has no DH algorithm implementation. Thus key encryption scheme would be choosen by certificate type only: \"key transport\" for RSA and \"key agreement\" for ECC certificates.\r\n   */\n\n\n  addRecipientByCertificate(certificate, parameters, variant) {\n    //region Initial variables \n    const encryptionParameters = parameters || {}; //endregion \n    //region Check type of certificate\n\n    if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(\"1.2.840.113549\") !== -1) variant = 1; // For the moment it is the only variant for RSA-based certificates\n    else {\n        if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(\"1.2.840.10045\") !== -1) variant = 2; // For the moment it is the only variant for ECC-based certificates\n        else throw new Error(`Unknown type of certificate's public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);\n      } //endregion \n    //region Initialize encryption parameters \n\n    if (\"oaepHashAlgorithm\" in encryptionParameters === false) encryptionParameters.oaepHashAlgorithm = \"SHA-512\";\n    if (\"kdfAlgorithm\" in encryptionParameters === false) encryptionParameters.kdfAlgorithm = \"SHA-512\";\n    if (\"kekEncryptionLength\" in encryptionParameters === false) encryptionParameters.kekEncryptionLength = 256;\n    if (\"useOAEP\" in encryptionParameters === false) encryptionParameters.useOAEP = true; //endregion\n    //region Add new \"recipient\" depends on \"variant\" and certificate type \n\n    switch (variant) {\n      case 1:\n        // Key transport scheme\n        {\n          let algorithmId;\n          let algorithmParams;\n\n          if (encryptionParameters.useOAEP === true) {\n            //region keyEncryptionAlgorithm\n            algorithmId = (0, _common.getOIDByAlgorithm)({\n              name: \"RSA-OAEP\"\n            });\n            if (algorithmId === \"\") throw new Error(\"Can not find OID for RSA-OAEP\"); //endregion\n            //region RSAES-OAEP-params\n\n            const hashOID = (0, _common.getOIDByAlgorithm)({\n              name: encryptionParameters.oaepHashAlgorithm\n            });\n            if (hashOID === \"\") throw new Error(`Unknown OAEP hash algorithm: ${encryptionParameters.oaepHashAlgorithm}`);\n            const hashAlgorithm = new _AlgorithmIdentifier.default({\n              algorithmId: hashOID,\n              algorithmParams: new asn1js.Null()\n            });\n            const rsaOAEPParams = new _RSAESOAEPParams.default({\n              hashAlgorithm,\n              maskGenAlgorithm: new _AlgorithmIdentifier.default({\n                algorithmId: \"1.2.840.113549.1.1.8\",\n                // id-mgf1\n                algorithmParams: hashAlgorithm.toSchema()\n              })\n            });\n            algorithmParams = rsaOAEPParams.toSchema(); //endregion\n          } else // Use old RSAES-PKCS1-v1_5 schema instead\n            {\n              //region keyEncryptionAlgorithm\n              algorithmId = (0, _common.getOIDByAlgorithm)({\n                name: \"RSAES-PKCS1-v1_5\"\n              });\n              if (algorithmId === \"\") throw new Error(\"Can not find OID for RSAES-PKCS1-v1_5\"); //endregion\n\n              algorithmParams = new asn1js.Null();\n            } //region KeyTransRecipientInfo\n\n\n          const keyInfo = new _KeyTransRecipientInfo.default({\n            version: 0,\n            rid: new _IssuerAndSerialNumber.default({\n              issuer: certificate.issuer,\n              serialNumber: certificate.serialNumber\n            }),\n            keyEncryptionAlgorithm: new _AlgorithmIdentifier.default({\n              algorithmId,\n              algorithmParams\n            }),\n            recipientCertificate: certificate // \"encryptedKey\" will be calculated in \"encrypt\" function\n\n          }); //endregion\n          //region Final values for \"CMS_ENVELOPED_DATA\"\n\n          this.recipientInfos.push(new _RecipientInfo.default({\n            variant: 1,\n            value: keyInfo\n          })); //endregion\n        }\n        break;\n\n      case 2:\n        // Key agreement scheme\n        {\n          //region RecipientEncryptedKey\n          const encryptedKey = new _RecipientEncryptedKey.default({\n            rid: new _KeyAgreeRecipientIdentifier.default({\n              variant: 1,\n              value: new _IssuerAndSerialNumber.default({\n                issuer: certificate.issuer,\n                serialNumber: certificate.serialNumber\n              })\n            }) // \"encryptedKey\" will be calculated in \"encrypt\" function\n\n          }); //endregion\n          //region keyEncryptionAlgorithm\n\n          const aesKWoid = (0, _common.getOIDByAlgorithm)({\n            name: \"AES-KW\",\n            length: encryptionParameters.kekEncryptionLength\n          });\n          if (aesKWoid === \"\") throw new Error(`Unknown length for key encryption algorithm: ${encryptionParameters.kekEncryptionLength}`);\n          const aesKW = new _AlgorithmIdentifier.default({\n            algorithmId: aesKWoid,\n            algorithmParams: new asn1js.Null()\n          }); //endregion\n          //region KeyAgreeRecipientInfo\n\n          const ecdhOID = (0, _common.getOIDByAlgorithm)({\n            name: \"ECDH\",\n            kdf: encryptionParameters.kdfAlgorithm\n          });\n          if (ecdhOID === \"\") throw new Error(`Unknown KDF algorithm: ${encryptionParameters.kdfAlgorithm}`); // In fact there is no need in so long UKM, but RFC2631\n          // has requirement that \"UserKeyMaterial\" must be 512 bits long\n\n          const ukmBuffer = new ArrayBuffer(64);\n          const ukmView = new Uint8Array(ukmBuffer);\n          (0, _common.getRandomValues)(ukmView); // Generate random values in 64 bytes long buffer\n\n          const keyInfo = new _KeyAgreeRecipientInfo.default({\n            version: 3,\n            // \"originator\" will be calculated in \"encrypt\" function because ephemeral key would be generated there\n            ukm: new asn1js.OctetString({\n              valueHex: ukmBuffer\n            }),\n            keyEncryptionAlgorithm: new _AlgorithmIdentifier.default({\n              algorithmId: ecdhOID,\n              algorithmParams: aesKW.toSchema()\n            }),\n            recipientEncryptedKeys: new _RecipientEncryptedKeys.default({\n              encryptedKeys: [encryptedKey]\n            }),\n            recipientCertificate: certificate\n          }); //endregion\n          //region Final values for \"CMS_ENVELOPED_DATA\"\n\n          this.recipientInfos.push(new _RecipientInfo.default({\n            variant: 2,\n            value: keyInfo\n          })); //endregion\n        }\n        break;\n\n      default:\n        throw new Error(`Unknown \"variant\" value: ${variant}`);\n    } //endregion \n\n\n    return true;\n  } //**********************************************************************************\n\n  /**\r\n   * Add recipient based on pre-defined data like password or KEK\r\n   * @param {ArrayBuffer} preDefinedData ArrayBuffer with pre-defined data\r\n   * @param {Object} parameters Additional parameters neccessary for \"fine tunning\" of encryption process\r\n   * @param {number} variant Variant = 1 for pre-defined \"key encryption key\" (KEK). Variant = 2 for password-based encryption.\r\n   */\n\n\n  addRecipientByPreDefinedData(preDefinedData, parameters, variant) {\n    //region Initial variables\n    const encryptionParameters = parameters || {}; //endregion\n    //region Check initial parameters\n\n    if (preDefinedData instanceof ArrayBuffer === false) throw new Error(\"Please pass \\\"preDefinedData\\\" in ArrayBuffer type\");\n    if (preDefinedData.byteLength === 0) throw new Error(\"Pre-defined data could have zero length\"); //endregion\n    //region Initialize encryption parameters\n\n    if (\"keyIdentifier\" in encryptionParameters === false) {\n      const keyIdentifierBuffer = new ArrayBuffer(16);\n      const keyIdentifierView = new Uint8Array(keyIdentifierBuffer);\n      (0, _common.getRandomValues)(keyIdentifierView);\n      encryptionParameters.keyIdentifier = keyIdentifierBuffer;\n    }\n\n    if (\"hmacHashAlgorithm\" in encryptionParameters === false) encryptionParameters.hmacHashAlgorithm = \"SHA-512\";\n    if (\"iterationCount\" in encryptionParameters === false) encryptionParameters.iterationCount = 2048;\n\n    if (\"keyEncryptionAlgorithm\" in encryptionParameters === false) {\n      encryptionParameters.keyEncryptionAlgorithm = {\n        name: \"AES-KW\",\n        length: 256\n      };\n    }\n\n    if (\"keyEncryptionAlgorithmParams\" in encryptionParameters === false) encryptionParameters.keyEncryptionAlgorithmParams = new asn1js.Null(); //endregion\n    //region Add new recipient based on passed variant\n\n    switch (variant) {\n      case 1:\n        // KEKRecipientInfo\n        {\n          //region keyEncryptionAlgorithm\n          const kekOID = (0, _common.getOIDByAlgorithm)(encryptionParameters.keyEncryptionAlgorithm);\n          if (kekOID === \"\") throw new Error(\"Incorrect value for \\\"keyEncryptionAlgorithm\\\"\"); //endregion\n          //region KEKRecipientInfo\n\n          const keyInfo = new _KEKRecipientInfo.default({\n            version: 4,\n            kekid: new _KEKIdentifier.default({\n              keyIdentifier: new asn1js.OctetString({\n                valueHex: encryptionParameters.keyIdentifier\n              })\n            }),\n            keyEncryptionAlgorithm: new _AlgorithmIdentifier.default({\n              algorithmId: kekOID,\n\n              /*\r\n               For AES-KW params are NULL, but for other algorithm could another situation.\r\n               */\n              algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams\n            }),\n            preDefinedKEK: preDefinedData // \"encryptedKey\" would be set in \"ecrypt\" function\n\n          }); //endregion\n          //region Final values for \"CMS_ENVELOPED_DATA\"\n\n          this.recipientInfos.push(new _RecipientInfo.default({\n            variant: 3,\n            value: keyInfo\n          })); //endregion\n        }\n        break;\n\n      case 2:\n        // PasswordRecipientinfo\n        {\n          //region keyDerivationAlgorithm\n          const pbkdf2OID = (0, _common.getOIDByAlgorithm)({\n            name: \"PBKDF2\"\n          });\n          if (pbkdf2OID === \"\") throw new Error(\"Can not find OID for PBKDF2\"); //endregion\n          //region Salt\n\n          const saltBuffer = new ArrayBuffer(64);\n          const saltView = new Uint8Array(saltBuffer);\n          (0, _common.getRandomValues)(saltView); //endregion\n          //region HMAC-based algorithm\n\n          const hmacOID = (0, _common.getOIDByAlgorithm)({\n            name: \"HMAC\",\n            hash: {\n              name: encryptionParameters.hmacHashAlgorithm\n            }\n          });\n          if (hmacOID === \"\") throw new Error(`Incorrect value for \"hmacHashAlgorithm\": ${encryptionParameters.hmacHashAlgorithm}`); //endregion\n          //region PBKDF2-params\n\n          const pbkdf2Params = new _PBKDF2Params.default({\n            salt: new asn1js.OctetString({\n              valueHex: saltBuffer\n            }),\n            iterationCount: encryptionParameters.iterationCount,\n            prf: new _AlgorithmIdentifier.default({\n              algorithmId: hmacOID,\n              algorithmParams: new asn1js.Null()\n            })\n          }); //endregion\n          //region keyEncryptionAlgorithm\n\n          const kekOID = (0, _common.getOIDByAlgorithm)(encryptionParameters.keyEncryptionAlgorithm);\n          if (kekOID === \"\") throw new Error(\"Incorrect value for \\\"keyEncryptionAlgorithm\\\"\"); //endregion\n          //region PasswordRecipientinfo\n\n          const keyInfo = new _PasswordRecipientinfo.default({\n            version: 0,\n            keyDerivationAlgorithm: new _AlgorithmIdentifier.default({\n              algorithmId: pbkdf2OID,\n              algorithmParams: pbkdf2Params.toSchema()\n            }),\n            keyEncryptionAlgorithm: new _AlgorithmIdentifier.default({\n              algorithmId: kekOID,\n\n              /*\r\n               For AES-KW params are NULL, but for other algorithm could be another situation.\r\n               */\n              algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams\n            }),\n            password: preDefinedData // \"encryptedKey\" would be set in \"ecrypt\" function\n\n          }); //endregion\n          //region Final values for \"CMS_ENVELOPED_DATA\"\n\n          this.recipientInfos.push(new _RecipientInfo.default({\n            variant: 4,\n            value: keyInfo\n          })); //endregion\n        }\n        break;\n\n      default:\n        throw new Error(`Unknown value for \"variant\": ${variant}`);\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Create a new CMS Enveloped Data content with encrypted data\r\n   * @param {Object} contentEncryptionAlgorithm WebCrypto algorithm. For the moment here could be only \"AES-CBC\" or \"AES-GCM\" algorithms.\r\n   * @param {ArrayBuffer} contentToEncrypt Content to encrypt\r\n   * @returns {Promise}\r\n   */\n\n\n  encrypt(contentEncryptionAlgorithm, contentToEncrypt) {\n    //region Initial variables\n    let sequence = Promise.resolve();\n    const ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long\n\n    const ivView = new Uint8Array(ivBuffer);\n    (0, _common.getRandomValues)(ivView);\n    const contentView = new Uint8Array(contentToEncrypt);\n    let sessionKey;\n    let encryptedContent;\n    let exportedSessionKey;\n    const recipientsPromises = [];\n\n    const _this = this; //endregion\n    //region Check for input parameters\n\n\n    const contentEncryptionOID = (0, _common.getOIDByAlgorithm)(contentEncryptionAlgorithm);\n    if (contentEncryptionOID === \"\") return Promise.reject(\"Wrong \\\"contentEncryptionAlgorithm\\\" value\"); //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Generate new content encryption key\n\n    sequence = sequence.then(() => crypto.generateKey(contentEncryptionAlgorithm, true, [\"encrypt\"])); //endregion\n    //region Encrypt content\n\n    sequence = sequence.then(result => {\n      sessionKey = result;\n      return crypto.encrypt({\n        name: contentEncryptionAlgorithm.name,\n        iv: ivView\n      }, sessionKey, contentView);\n    }, error => Promise.reject(error)); //endregion\n    //region Export raw content of content encryption key\n\n    sequence = sequence.then(result => {\n      //region Create output OCTETSTRING with encrypted content\n      encryptedContent = result; //endregion\n\n      return crypto.exportKey(\"raw\", sessionKey);\n    }, error => Promise.reject(error)).then(result => {\n      exportedSessionKey = result;\n      return true;\n    }, error => Promise.reject(error)); //endregion\n    //region Append common information to CMS_ENVELOPED_DATA\n\n    sequence = sequence.then(() => {\n      this.version = 2;\n      this.encryptedContentInfo = new _EncryptedContentInfo.default({\n        contentType: \"1.2.840.113549.1.7.1\",\n        // \"data\"\n        contentEncryptionAlgorithm: new _AlgorithmIdentifier.default({\n          algorithmId: contentEncryptionOID,\n          algorithmParams: new asn1js.OctetString({\n            valueHex: ivBuffer\n          })\n        }),\n        encryptedContent: new asn1js.OctetString({\n          valueHex: encryptedContent\n        })\n      });\n    }, error => Promise.reject(error)); //endregion\n    //region Special sub-functions to work with each recipient's type\n\n    function SubKeyAgreeRecipientInfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let ecdhPublicKey;\n      let ecdhPrivateKey;\n      let recipientCurve;\n      let recipientCurveLength;\n      let exportedECDHPublicKey; //endregion\n      //region Get \"namedCurve\" parameter from recipient's certificate\n\n      currentSequence = currentSequence.then(() => {\n        const curveObject = _this.recipientInfos[index].value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;\n        if (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) return Promise.reject(`Incorrect \"recipientCertificate\" for index ${index}`);\n        const curveOID = curveObject.valueBlock.toString();\n\n        switch (curveOID) {\n          case \"1.2.840.10045.3.1.7\":\n            recipientCurve = \"P-256\";\n            recipientCurveLength = 256;\n            break;\n\n          case \"1.3.132.0.34\":\n            recipientCurve = \"P-384\";\n            recipientCurveLength = 384;\n            break;\n\n          case \"1.3.132.0.35\":\n            recipientCurve = \"P-521\";\n            recipientCurveLength = 528;\n            break;\n\n          default:\n            return Promise.reject(`Incorrect curve OID for index ${index}`);\n        }\n\n        return recipientCurve;\n      }, error => Promise.reject(error)); //endregion\n      //region Generate ephemeral ECDH key\n\n      currentSequence = currentSequence.then(result => crypto.generateKey({\n        name: \"ECDH\",\n        namedCurve: result\n      }, true, [\"deriveBits\"]), error => Promise.reject(error)); //endregion\n      //region Export public key of ephemeral ECDH key pair\n\n      currentSequence = currentSequence.then(result => {\n        ecdhPublicKey = result.publicKey;\n        ecdhPrivateKey = result.privateKey;\n        return crypto.exportKey(\"spki\", ecdhPublicKey);\n      }, error => Promise.reject(error)); //endregion\n      //region Import recipient's public key\n\n      currentSequence = currentSequence.then(result => {\n        exportedECDHPublicKey = result;\n        return _this.recipientInfos[index].value.recipientCertificate.getPublicKey({\n          algorithm: {\n            algorithm: {\n              name: \"ECDH\",\n              namedCurve: recipientCurve\n            },\n            usages: []\n          }\n        });\n      }, error => Promise.reject(error)); //endregion\n      //region Create shared secret\n\n      currentSequence = currentSequence.then(result => crypto.deriveBits({\n        name: \"ECDH\",\n        public: result\n      }, ecdhPrivateKey, recipientCurveLength), error => Promise.reject(error)); //endregion\n      //region Apply KDF function to shared secret\n\n      currentSequence = currentSequence.then(\n      /**\r\n       * @param {ArrayBuffer} result\r\n       */\n      result => {\n        //region Get length of used AES-KW algorithm\n        const aesKWAlgorithm = new _AlgorithmIdentifier.default({\n          schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams\n        });\n        const KWalgorithm = (0, _common.getAlgorithmByOID)(aesKWAlgorithm.algorithmId);\n        if (\"name\" in KWalgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`); //endregion\n        //region Translate AES-KW length to ArrayBuffer\n\n        let kwLength = KWalgorithm.length;\n        const kwLengthBuffer = new ArrayBuffer(4);\n        const kwLengthView = new Uint8Array(kwLengthBuffer);\n\n        for (let j = 3; j >= 0; j--) {\n          kwLengthView[j] = kwLength;\n          kwLength >>= 8;\n        } //endregion\n        //region Create and encode \"ECC-CMS-SharedInfo\" structure\n\n\n        const eccInfo = new _ECCCMSSharedInfo.default({\n          keyInfo: new _AlgorithmIdentifier.default({\n            algorithmId: aesKWAlgorithm.algorithmId,\n\n            /*\r\n             Initially RFC5753 says that AES algorithms have absent parameters.\r\n             But since early implementations all put NULL here. Thus, in order to be\r\n             \"backward compatible\", index also put NULL here.\r\n             */\n            algorithmParams: new asn1js.Null()\n          }),\n          entityUInfo: _this.recipientInfos[index].value.ukm,\n          suppPubInfo: new asn1js.OctetString({\n            valueHex: kwLengthBuffer\n          })\n        });\n        const encodedInfo = eccInfo.toSchema().toBER(false); //endregion\n        //region Get SHA algorithm used together with ECDH\n\n        const ecdhAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in ecdhAlgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return (0, _common.kdf)(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);\n      }, error => Promise.reject(error)); //endregion\n      //region Import AES-KW key from result of KDF function\n\n      currentSequence = currentSequence.then(result => crypto.importKey(\"raw\", result, {\n        name: \"AES-KW\"\n      }, true, [\"wrapKey\"]), error => Promise.reject(error)); //endregion\n      //region Finally wrap session key by using AES-KW algorithm\n\n      currentSequence = currentSequence.then(result => crypto.wrapKey(\"raw\", sessionKey, result, {\n        name: \"AES-KW\"\n      }), error => Promise.reject(error)); //endregion\n      //region Append all neccessary data to current CMS_RECIPIENT_INFO object\n\n      currentSequence = currentSequence.then(result => {\n        //region OriginatorIdentifierOrKey\n        const asn1 = asn1js.fromBER(exportedECDHPublicKey);\n        const originator = new _OriginatorIdentifierOrKey.default();\n        originator.variant = 3;\n        originator.value = new _OriginatorPublicKey.default({\n          schema: asn1.result\n        }); // There is option when we can stay with ECParameters, but here index prefer to avoid the params\n\n        if (\"algorithmParams\" in originator.value.algorithm) delete originator.value.algorithm.algorithmParams;\n        _this.recipientInfos[index].value.originator = originator; //endregion\n        //region RecipientEncryptedKey\n\n        /*\r\n         We will not support using of same ephemeral key for many recipients\r\n         */\n\n        _this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new asn1js.OctetString({\n          valueHex: result\n        }); //endregion\n\n        return {\n          ecdhPrivateKey\n        };\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    }\n\n    function SubKeyTransRecipientInfo(_x) {\n      return _SubKeyTransRecipientInfo.apply(this, arguments);\n    }\n\n    function _SubKeyTransRecipientInfo() {\n      _SubKeyTransRecipientInfo = _asyncToGenerator(function* (index) {\n        const algorithmParameters = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in algorithmParameters === false) throw new Error(`Unknown keyEncryptionAlgorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //region RSA-OAEP case\n\n        if (algorithmParameters.name === \"RSA-OAEP\") {\n          const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;\n          const rsaOAEPParams = new _RSAESOAEPParams.default({\n            schema\n          });\n          algorithmParameters.hash = (0, _common.getAlgorithmByOID)(rsaOAEPParams.hashAlgorithm.algorithmId);\n          if (\"name\" in algorithmParameters.hash === false) throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);\n        } //endregion\n\n\n        try {\n          const publicKey = yield _this.recipientInfos[index].value.recipientCertificate.getPublicKey({\n            algorithm: {\n              algorithm: algorithmParameters,\n              usages: [\"encrypt\", \"wrapKey\"]\n            }\n          });\n          const encryptedKey = yield crypto.encrypt(publicKey.algorithm, publicKey, exportedSessionKey); //region RecipientEncryptedKey\n\n          _this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({\n            valueHex: encryptedKey\n          }); //endregion\n        } catch (ex) {\n          const jjj = 0;\n        }\n      });\n      return _SubKeyTransRecipientInfo.apply(this, arguments);\n    }\n\n    function SubKEKRecipientInfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let kekAlgorithm; //endregion\n      //region Import KEK from pre-defined data\n\n      currentSequence = currentSequence.then(() => {\n        //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n        kekAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.importKey(\"raw\", new Uint8Array(_this.recipientInfos[index].value.preDefinedKEK), kekAlgorithm, true, [\"wrapKey\"]); // Too specific for AES-KW\n      }, error => Promise.reject(error)); //endregion\n      //region Wrap previously exported session key\n\n      currentSequence = currentSequence.then(result => crypto.wrapKey(\"raw\", sessionKey, result, kekAlgorithm), error => Promise.reject(error)); //endregion\n      //region Append all neccessary data to current CMS_RECIPIENT_INFO object\n\n      currentSequence = currentSequence.then(result => {\n        //region RecipientEncryptedKey\n        _this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({\n          valueHex: result\n        }); //endregion\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    }\n\n    function SubPasswordRecipientinfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let pbkdf2Params;\n      let kekAlgorithm; //endregion\n      //region Check that we have encoded \"keyDerivationAlgorithm\" plus \"PBKDF2_params\" in there\n\n      currentSequence = currentSequence.then(() => {\n        if (\"keyDerivationAlgorithm\" in _this.recipientInfos[index].value === false) return Promise.reject(\"Please append encoded \\\"keyDerivationAlgorithm\\\"\");\n        if (\"algorithmParams\" in _this.recipientInfos[index].value.keyDerivationAlgorithm === false) return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n\n        try {\n          pbkdf2Params = new _PBKDF2Params.default({\n            schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams\n          });\n        } catch (ex) {\n          return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n        }\n\n        return Promise.resolve();\n      }, error => Promise.reject(error)); //endregion\n      //region Derive PBKDF2 key from \"password\" buffer\n\n      currentSequence = currentSequence.then(() => {\n        const passwordView = new Uint8Array(_this.recipientInfos[index].value.password);\n        return crypto.importKey(\"raw\", passwordView, \"PBKDF2\", false, [\"deriveKey\"]);\n      }, error => Promise.reject(error)); //endregion\n      //region Derive key for \"keyEncryptionAlgorithm\"\n\n      currentSequence = currentSequence.then(result => {\n        //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n        kekAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n        //region Get HMAC hash algorithm\n\n        let hmacHashAlgorithm = \"SHA-1\";\n\n        if (\"prf\" in pbkdf2Params) {\n          const algorithm = (0, _common.getAlgorithmByOID)(pbkdf2Params.prf.algorithmId);\n          if (\"name\" in algorithm === false) return Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\n          hmacHashAlgorithm = algorithm.hash.name;\n        } //endregion\n        //region Get PBKDF2 \"salt\" value\n\n\n        const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex); //endregion\n        //region Get PBKDF2 iterations count\n\n        const iterations = pbkdf2Params.iterationCount; //endregion\n\n        return crypto.deriveKey({\n          name: \"PBKDF2\",\n          hash: {\n            name: hmacHashAlgorithm\n          },\n          salt: saltView,\n          iterations\n        }, result, kekAlgorithm, true, [\"wrapKey\"]); // Usages are too specific for KEK algorithm\n      }, error => Promise.reject(error)); //endregion\n      //region Wrap previously exported session key (Also too specific for KEK algorithm)\n\n      currentSequence = currentSequence.then(result => crypto.wrapKey(\"raw\", sessionKey, result, kekAlgorithm), error => Promise.reject(error)); //endregion\n      //region Append all neccessary data to current CMS_RECIPIENT_INFO object\n\n      currentSequence = currentSequence.then(result => {\n        //region RecipientEncryptedKey\n        _this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({\n          valueHex: result\n        }); //endregion\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    } //endregion\n    //region Create special routines for each \"recipient\"\n\n\n    sequence = sequence.then(() => {\n      for (let i = 0; i < this.recipientInfos.length; i++) {\n        //region Initial variables\n        let currentSequence = Promise.resolve(); //endregion\n\n        switch (this.recipientInfos[i].variant) {\n          case 1:\n            // KeyTransRecipientInfo\n            currentSequence = SubKeyTransRecipientInfo(i);\n            break;\n\n          case 2:\n            // KeyAgreeRecipientInfo\n            currentSequence = SubKeyAgreeRecipientInfo(i);\n            break;\n\n          case 3:\n            // KEKRecipientInfo\n            currentSequence = SubKEKRecipientInfo(i);\n            break;\n\n          case 4:\n            // PasswordRecipientinfo\n            currentSequence = SubPasswordRecipientinfo(i);\n            break;\n\n          default:\n            return Promise.reject(`Uknown recipient type in array with index ${i}`);\n        }\n\n        recipientsPromises.push(currentSequence);\n      }\n\n      return Promise.all(recipientsPromises);\n    }, error => Promise.reject(error)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Decrypt existing CMS Enveloped Data content\r\n   * @param {number} recipientIndex Index of recipient\r\n   * @param {Object} parameters Additional parameters\r\n   * @returns {Promise}\r\n   */\n\n\n  decrypt(recipientIndex, parameters) {\n    //region Initial variables\n    let sequence = Promise.resolve();\n    const decryptionParameters = parameters || {};\n\n    const _this = this; //endregion\n    //region Check for input parameters\n\n\n    if (recipientIndex + 1 > this.recipientInfos.length) return Promise.reject(`Maximum value for \"index\" is: ${this.recipientInfos.length - 1}`); //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Special sub-functions to work with each recipient's type\n\n    function SubKeyAgreeRecipientInfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let recipientCurve;\n      let recipientCurveLength;\n      let curveOID;\n      let ecdhPrivateKey; //endregion\n      //region Get \"namedCurve\" parameter from recipient's certificate\n\n      currentSequence = currentSequence.then(() => {\n        if (\"recipientCertificate\" in decryptionParameters === false) return Promise.reject(\"Parameter \\\"recipientCertificate\\\" is mandatory for \\\"KeyAgreeRecipientInfo\\\"\");\n        if (\"recipientPrivateKey\" in decryptionParameters === false) return Promise.reject(\"Parameter \\\"recipientPrivateKey\\\" is mandatory for \\\"KeyAgreeRecipientInfo\\\"\");\n        const curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;\n        if (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) return Promise.reject(`Incorrect \"recipientCertificate\" for index ${index}`);\n        curveOID = curveObject.valueBlock.toString();\n\n        switch (curveOID) {\n          case \"1.2.840.10045.3.1.7\":\n            recipientCurve = \"P-256\";\n            recipientCurveLength = 256;\n            break;\n\n          case \"1.3.132.0.34\":\n            recipientCurve = \"P-384\";\n            recipientCurveLength = 384;\n            break;\n\n          case \"1.3.132.0.35\":\n            recipientCurve = \"P-521\";\n            recipientCurveLength = 528;\n            break;\n\n          default:\n            return Promise.reject(`Incorrect curve OID for index ${index}`);\n        }\n\n        return crypto.importKey(\"pkcs8\", decryptionParameters.recipientPrivateKey, {\n          name: \"ECDH\",\n          namedCurve: recipientCurve\n        }, true, [\"deriveBits\"]);\n      }, error => Promise.reject(error)); //endregion\n      //region Import sender's ephemeral public key\n\n      currentSequence = currentSequence.then(result => {\n        ecdhPrivateKey = result; //region Change \"OriginatorPublicKey\" if \"curve\" parameter absent\n\n        if (\"algorithmParams\" in _this.recipientInfos[index].value.originator.value.algorithm === false) _this.recipientInfos[index].value.originator.value.algorithm.algorithmParams = new asn1js.ObjectIdentifier({\n          value: curveOID\n        }); //endregion\n        //region Create ArrayBuffer with sender's public key\n\n        const buffer = _this.recipientInfos[index].value.originator.value.toSchema().toBER(false); //endregion\n\n\n        return crypto.importKey(\"spki\", buffer, {\n          name: \"ECDH\",\n          namedCurve: recipientCurve\n        }, true, []);\n      }, error => Promise.reject(error)); //endregion\n      //region Create shared secret\n\n      currentSequence = currentSequence.then(result => crypto.deriveBits({\n        name: \"ECDH\",\n        public: result\n      }, ecdhPrivateKey, recipientCurveLength), error => Promise.reject(error)); //endregion\n      //region Apply KDF function to shared secret\n\n      currentSequence = currentSequence.then(\n      /**\r\n       * @param {ArrayBuffer} result\r\n       */\n      result => {\n        //region Get length of used AES-KW algorithm\n        const aesKWAlgorithm = new _AlgorithmIdentifier.default({\n          schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams\n        });\n        const KWalgorithm = (0, _common.getAlgorithmByOID)(aesKWAlgorithm.algorithmId);\n        if (\"name\" in KWalgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`); //endregion\n        //region Translate AES-KW length to ArrayBuffer\n\n        let kwLength = KWalgorithm.length;\n        const kwLengthBuffer = new ArrayBuffer(4);\n        const kwLengthView = new Uint8Array(kwLengthBuffer);\n\n        for (let j = 3; j >= 0; j--) {\n          kwLengthView[j] = kwLength;\n          kwLength >>= 8;\n        } //endregion\n        //region Create and encode \"ECC-CMS-SharedInfo\" structure\n\n\n        const eccInfo = new _ECCCMSSharedInfo.default({\n          keyInfo: new _AlgorithmIdentifier.default({\n            algorithmId: aesKWAlgorithm.algorithmId,\n\n            /*\r\n             Initially RFC5753 says that AES algorithms have absent parameters.\r\n             But since early implementations all put NULL here. Thus, in order to be\r\n             \"backward compatible\", index also put NULL here.\r\n             */\n            algorithmParams: new asn1js.Null()\n          }),\n          entityUInfo: _this.recipientInfos[index].value.ukm,\n          suppPubInfo: new asn1js.OctetString({\n            valueHex: kwLengthBuffer\n          })\n        });\n        const encodedInfo = eccInfo.toSchema().toBER(false); //endregion\n        //region Get SHA algorithm used together with ECDH\n\n        const ecdhAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in ecdhAlgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return (0, _common.kdf)(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);\n      }, error => Promise.reject(error)); //endregion\n      //region Import AES-KW key from result of KDF function\n\n      currentSequence = currentSequence.then(result => crypto.importKey(\"raw\", result, {\n        name: \"AES-KW\"\n      }, true, [\"unwrapKey\"]), error => Promise.reject(error)); //endregion\n      //region Finally unwrap session key\n\n      currentSequence = currentSequence.then(result => {\n        //region Get WebCrypto form of content encryption algorithm\n        const contentEncryptionAlgorithm = (0, _common.getAlgorithmByOID)(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n        if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.unwrapKey(\"raw\", _this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex, result, {\n          name: \"AES-KW\"\n        }, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    }\n\n    function SubKeyTransRecipientInfo(_x2) {\n      return _SubKeyTransRecipientInfo2.apply(this, arguments);\n    }\n\n    function _SubKeyTransRecipientInfo2() {\n      _SubKeyTransRecipientInfo2 = _asyncToGenerator(function* (index) {\n        if (\"recipientPrivateKey\" in decryptionParameters === false) throw new Error(\"Parameter \\\"recipientPrivateKey\\\" is mandatory for \\\"KeyTransRecipientInfo\\\"\");\n        const algorithmParameters = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in algorithmParameters === false) throw new Error(`Unknown keyEncryptionAlgorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //region RSA-OAEP case\n\n        if (algorithmParameters.name === \"RSA-OAEP\") {\n          const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;\n          const rsaOAEPParams = new _RSAESOAEPParams.default({\n            schema\n          });\n          algorithmParameters.hash = (0, _common.getAlgorithmByOID)(rsaOAEPParams.hashAlgorithm.algorithmId);\n          if (\"name\" in algorithmParameters.hash === false) throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);\n        } //endregion\n\n\n        const privateKey = yield crypto.importKey(\"pkcs8\", decryptionParameters.recipientPrivateKey, algorithmParameters, true, [\"decrypt\"]);\n        const sessionKey = yield crypto.decrypt(privateKey.algorithm, privateKey, _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex); //region Get WebCrypto form of content encryption algorithm\n\n        const contentEncryptionAlgorithm = (0, _common.getAlgorithmByOID)(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n        if (\"name\" in contentEncryptionAlgorithm === false) throw new Error(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.importKey(\"raw\", sessionKey, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n      });\n      return _SubKeyTransRecipientInfo2.apply(this, arguments);\n    }\n\n    function SubKEKRecipientInfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let kekAlgorithm; //endregion\n      //region Import KEK from pre-defined data\n\n      currentSequence = currentSequence.then(() => {\n        if (\"preDefinedData\" in decryptionParameters === false) return Promise.reject(\"Parameter \\\"preDefinedData\\\" is mandatory for \\\"KEKRecipientInfo\\\"\"); //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n\n        kekAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.importKey(\"raw\", decryptionParameters.preDefinedData, kekAlgorithm, true, [\"unwrapKey\"]); // Too specific for AES-KW\n      }, error => Promise.reject(error)); //endregion\n      //region Unwrap previously exported session key\n\n      currentSequence = currentSequence.then(result => {\n        //region Get WebCrypto form of content encryption algorithm\n        const contentEncryptionAlgorithm = (0, _common.getAlgorithmByOID)(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n        if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.unwrapKey(\"raw\", _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex, result, kekAlgorithm, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    }\n\n    function SubPasswordRecipientinfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let pbkdf2Params;\n      let kekAlgorithm; //endregion\n      //region Derive PBKDF2 key from \"password\" buffer\n\n      currentSequence = currentSequence.then(() => {\n        if (\"preDefinedData\" in decryptionParameters === false) return Promise.reject(\"Parameter \\\"preDefinedData\\\" is mandatory for \\\"KEKRecipientInfo\\\"\");\n        if (\"keyDerivationAlgorithm\" in _this.recipientInfos[index].value === false) return Promise.reject(\"Please append encoded \\\"keyDerivationAlgorithm\\\"\");\n        if (\"algorithmParams\" in _this.recipientInfos[index].value.keyDerivationAlgorithm === false) return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n\n        try {\n          pbkdf2Params = new _PBKDF2Params.default({\n            schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams\n          });\n        } catch (ex) {\n          return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n        }\n\n        return crypto.importKey(\"raw\", decryptionParameters.preDefinedData, \"PBKDF2\", false, [\"deriveKey\"]);\n      }, error => Promise.reject(error)); //endregion\n      //region Derive key for \"keyEncryptionAlgorithm\"\n\n      currentSequence = currentSequence.then(result => {\n        //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n        kekAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n        //region Get HMAC hash algorithm\n\n        let hmacHashAlgorithm = \"SHA-1\";\n\n        if (\"prf\" in pbkdf2Params) {\n          const algorithm = (0, _common.getAlgorithmByOID)(pbkdf2Params.prf.algorithmId);\n          if (\"name\" in algorithm === false) return Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\n          hmacHashAlgorithm = algorithm.hash.name;\n        } //endregion\n        //region Get PBKDF2 \"salt\" value\n\n\n        const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex); //endregion\n        //region Get PBKDF2 iterations count\n\n        const iterations = pbkdf2Params.iterationCount; //endregion\n\n        return crypto.deriveKey({\n          name: \"PBKDF2\",\n          hash: {\n            name: hmacHashAlgorithm\n          },\n          salt: saltView,\n          iterations\n        }, result, kekAlgorithm, true, [\"unwrapKey\"]); // Usages are too specific for KEK algorithm\n      }, error => Promise.reject(error)); //endregion\n      //region Unwrap previously exported session key\n\n      currentSequence = currentSequence.then(result => {\n        //region Get WebCrypto form of content encryption algorithm\n        const contentEncryptionAlgorithm = (0, _common.getAlgorithmByOID)(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n        if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.unwrapKey(\"raw\", _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex, result, kekAlgorithm, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    } //endregion\n    //region Perform steps, specific to each type of session key encryption\n\n\n    sequence = sequence.then(() => {\n      //region Initial variables\n      let currentSequence = Promise.resolve(); //endregion\n\n      switch (this.recipientInfos[recipientIndex].variant) {\n        case 1:\n          // KeyTransRecipientInfo\n          currentSequence = SubKeyTransRecipientInfo(recipientIndex);\n          break;\n\n        case 2:\n          // KeyAgreeRecipientInfo\n          currentSequence = SubKeyAgreeRecipientInfo(recipientIndex);\n          break;\n\n        case 3:\n          // KEKRecipientInfo\n          currentSequence = SubKEKRecipientInfo(recipientIndex);\n          break;\n\n        case 4:\n          // PasswordRecipientinfo\n          currentSequence = SubPasswordRecipientinfo(recipientIndex);\n          break;\n\n        default:\n          return Promise.reject(`Uknown recipient type in array with index ${recipientIndex}`);\n      }\n\n      return currentSequence;\n    }, error => Promise.reject(error)); //endregion\n    //region Finally decrypt data by session key\n\n    sequence = sequence.then(result => {\n      //region Get WebCrypto form of content encryption algorithm\n      const contentEncryptionAlgorithm = (0, _common.getAlgorithmByOID)(this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n      if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n      //region Get \"intialization vector\" for content encryption algorithm\n\n      const ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;\n      const ivView = new Uint8Array(ivBuffer); //endregion\n      //region Create correct data block for decryption\n\n      let dataBuffer = new ArrayBuffer(0);\n      if (this.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false) dataBuffer = this.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else {\n        var _iterator = _createForOfIteratorHelper(this.encryptedContentInfo.encryptedContent.valueBlock.value),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            const content = _step.value;\n            dataBuffer = (0, _pvutils.utilConcatBuf)(dataBuffer, content.valueBlock.valueHex);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } //endregion\n\n      return crypto.decrypt({\n        name: contentEncryptionAlgorithm.name,\n        iv: ivView\n      }, result, dataBuffer);\n    }, error => Promise.reject(error)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = EnvelopedData;\n//# sourceMappingURL=EnvelopedData.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/EnvelopedData.js\n// module id = ./node_modules/pkijs/build/EnvelopedData.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass ExtKeyUsage {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for ExtKeyUsage class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<string>}\r\n     * @desc keyPurposes\r\n     */\n    this.keyPurposes = (0, _pvutils.getParametersValue)(parameters, \"keyPurposes\", ExtKeyUsage.defaultValues(\"keyPurposes\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"keyPurposes\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for ExtKeyUsage class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * ExtKeyUsage ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId\r\n   *\r\n   * KeyPurposeId ::= OBJECT IDENTIFIER\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [keyPurposes]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.keyPurposes || \"\",\n        value: new asn1js.ObjectIdentifier()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"keyPurposes\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, ExtKeyUsage.schema({\n      names: {\n        keyPurposes: \"keyPurposes\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for ExtKeyUsage\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.keyPurposes = Array.from(asn1.result.keyPurposes, element => element.valueBlock.toString()); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.keyPurposes, element => new asn1js.ObjectIdentifier({\n        value: element\n      }))\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      keyPurposes: Array.from(this.keyPurposes)\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = ExtKeyUsage;\n//# sourceMappingURL=ExtKeyUsage.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/ExtKeyUsage.js\n// module id = ./node_modules/pkijs/build/ExtKeyUsage.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _SubjectDirectoryAttributes = _interopRequireDefault(require(\"./SubjectDirectoryAttributes.js\"));\n\nvar _PrivateKeyUsagePeriod = _interopRequireDefault(require(\"./PrivateKeyUsagePeriod.js\"));\n\nvar _AltName = _interopRequireDefault(require(\"./AltName.js\"));\n\nvar _BasicConstraints = _interopRequireDefault(require(\"./BasicConstraints.js\"));\n\nvar _IssuingDistributionPoint = _interopRequireDefault(require(\"./IssuingDistributionPoint.js\"));\n\nvar _GeneralNames = _interopRequireDefault(require(\"./GeneralNames.js\"));\n\nvar _NameConstraints = _interopRequireDefault(require(\"./NameConstraints.js\"));\n\nvar _CRLDistributionPoints = _interopRequireDefault(require(\"./CRLDistributionPoints.js\"));\n\nvar _CertificatePolicies = _interopRequireDefault(require(\"./CertificatePolicies.js\"));\n\nvar _PolicyMappings = _interopRequireDefault(require(\"./PolicyMappings.js\"));\n\nvar _AuthorityKeyIdentifier = _interopRequireDefault(require(\"./AuthorityKeyIdentifier.js\"));\n\nvar _PolicyConstraints = _interopRequireDefault(require(\"./PolicyConstraints.js\"));\n\nvar _ExtKeyUsage = _interopRequireDefault(require(\"./ExtKeyUsage.js\"));\n\nvar _InfoAccess = _interopRequireDefault(require(\"./InfoAccess.js\"));\n\nvar _SignedCertificateTimestampList = _interopRequireDefault(require(\"./SignedCertificateTimestampList.js\"));\n\nvar _CertificateTemplate = _interopRequireDefault(require(\"./CertificateTemplate.js\"));\n\nvar _CAVersion = _interopRequireDefault(require(\"./CAVersion.js\"));\n\nvar _QCStatements = _interopRequireDefault(require(\"./QCStatements.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass Extension {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for Extension class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc extnID\r\n     */\n    this.extnID = (0, _pvutils.getParametersValue)(parameters, \"extnID\", Extension.defaultValues(\"extnID\"));\n    /**\r\n     * @type {boolean}\r\n     * @desc critical\r\n     */\n\n    this.critical = (0, _pvutils.getParametersValue)(parameters, \"critical\", Extension.defaultValues(\"critical\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc extnValue\r\n     */\n\n    if (\"extnValue\" in parameters) this.extnValue = new asn1js.OctetString({\n      valueHex: parameters.extnValue\n    });else this.extnValue = Extension.defaultValues(\"extnValue\");\n    if (\"parsedValue\" in parameters)\n      /**\r\n       * @type {Object}\r\n       * @desc parsedValue\r\n       */\n      this.parsedValue = (0, _pvutils.getParametersValue)(parameters, \"parsedValue\", Extension.defaultValues(\"parsedValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"extnID\":\n        return \"\";\n\n      case \"critical\":\n        return false;\n\n      case \"extnValue\":\n        return new asn1js.OctetString();\n\n      case \"parsedValue\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for Extension class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * Extension  ::=  SEQUENCE  {\r\n   *    extnID      OBJECT IDENTIFIER,\r\n   *    critical    BOOLEAN DEFAULT FALSE,\r\n   *    extnValue   OCTET STRING\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [extnID]\r\n     * @property {string} [critical]\r\n     * @property {string} [extnValue]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.extnID || \"\"\n      }), new asn1js.Boolean({\n        name: names.critical || \"\",\n        optional: true\n      }), new asn1js.OctetString({\n        name: names.extnValue || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"extnID\", \"critical\", \"extnValue\"]); //endregion\n    //region Check the schema is valid\n\n    let asn1 = asn1js.compareSchema(schema, schema, Extension.schema({\n      names: {\n        extnID: \"extnID\",\n        critical: \"critical\",\n        extnValue: \"extnValue\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for Extension\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.extnID = asn1.result.extnID.valueBlock.toString();\n    if (\"critical\" in asn1.result) this.critical = asn1.result.critical.valueBlock.value;\n    this.extnValue = asn1.result.extnValue; //region Get \"parsedValue\" for well-known extensions\n\n    asn1 = asn1js.fromBER(this.extnValue.valueBlock.valueHex);\n    if (asn1.offset === -1) return;\n\n    switch (this.extnID) {\n      case \"2.5.29.9\":\n        // SubjectDirectoryAttributes\n        try {\n          this.parsedValue = new _SubjectDirectoryAttributes.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _SubjectDirectoryAttributes.default();\n          this.parsedValue.parsingError = \"Incorrectly formated SubjectDirectoryAttributes\";\n        }\n\n        break;\n\n      case \"2.5.29.14\":\n        // SubjectKeyIdentifier\n        this.parsedValue = asn1.result; // Should be just a simple OCTETSTRING\n\n        break;\n\n      case \"2.5.29.15\":\n        // KeyUsage\n        this.parsedValue = asn1.result; // Should be just a simple BITSTRING\n\n        break;\n\n      case \"2.5.29.16\":\n        // PrivateKeyUsagePeriod\n        try {\n          this.parsedValue = new _PrivateKeyUsagePeriod.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _PrivateKeyUsagePeriod.default();\n          this.parsedValue.parsingError = \"Incorrectly formated PrivateKeyUsagePeriod\";\n        }\n\n        break;\n\n      case \"2.5.29.17\": // SubjectAltName\n\n      case \"2.5.29.18\":\n        // IssuerAltName\n        try {\n          this.parsedValue = new _AltName.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _AltName.default();\n          this.parsedValue.parsingError = \"Incorrectly formated AltName\";\n        }\n\n        break;\n\n      case \"2.5.29.19\":\n        // BasicConstraints\n        try {\n          this.parsedValue = new _BasicConstraints.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _BasicConstraints.default();\n          this.parsedValue.parsingError = \"Incorrectly formated BasicConstraints\";\n        }\n\n        break;\n\n      case \"2.5.29.20\": // CRLNumber\n\n      case \"2.5.29.27\":\n        // BaseCRLNumber (delta CRL indicator)\n        this.parsedValue = asn1.result; // Should be just a simple INTEGER\n\n        break;\n\n      case \"2.5.29.21\":\n        // CRLReason\n        this.parsedValue = asn1.result; // Should be just a simple ENUMERATED\n\n        break;\n\n      case \"2.5.29.24\":\n        // InvalidityDate\n        this.parsedValue = asn1.result; // Should be just a simple GeneralizedTime\n\n        break;\n\n      case \"2.5.29.28\":\n        // IssuingDistributionPoint\n        try {\n          this.parsedValue = new _IssuingDistributionPoint.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _IssuingDistributionPoint.default();\n          this.parsedValue.parsingError = \"Incorrectly formated IssuingDistributionPoint\";\n        }\n\n        break;\n\n      case \"2.5.29.29\":\n        // CertificateIssuer\n        try {\n          this.parsedValue = new _GeneralNames.default({\n            schema: asn1.result\n          }); // Should be just a simple\n        } catch (ex) {\n          this.parsedValue = new _GeneralNames.default();\n          this.parsedValue.parsingError = \"Incorrectly formated GeneralNames\";\n        }\n\n        break;\n\n      case \"2.5.29.30\":\n        // NameConstraints\n        try {\n          this.parsedValue = new _NameConstraints.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _NameConstraints.default();\n          this.parsedValue.parsingError = \"Incorrectly formated NameConstraints\";\n        }\n\n        break;\n\n      case \"2.5.29.31\": // CRLDistributionPoints\n\n      case \"2.5.29.46\":\n        // FreshestCRL\n        try {\n          this.parsedValue = new _CRLDistributionPoints.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _CRLDistributionPoints.default();\n          this.parsedValue.parsingError = \"Incorrectly formated CRLDistributionPoints\";\n        }\n\n        break;\n\n      case \"2.5.29.32\": // CertificatePolicies\n\n      case \"1.3.6.1.4.1.311.21.10\":\n        // szOID_APPLICATION_CERT_POLICIES - Microsoft-specific OID\n        try {\n          this.parsedValue = new _CertificatePolicies.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _CertificatePolicies.default();\n          this.parsedValue.parsingError = \"Incorrectly formated CertificatePolicies\";\n        }\n\n        break;\n\n      case \"2.5.29.33\":\n        // PolicyMappings\n        try {\n          this.parsedValue = new _PolicyMappings.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _PolicyMappings.default();\n          this.parsedValue.parsingError = \"Incorrectly formated CertificatePolicies\";\n        }\n\n        break;\n\n      case \"2.5.29.35\":\n        // AuthorityKeyIdentifier\n        try {\n          this.parsedValue = new _AuthorityKeyIdentifier.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _AuthorityKeyIdentifier.default();\n          this.parsedValue.parsingError = \"Incorrectly formated AuthorityKeyIdentifier\";\n        }\n\n        break;\n\n      case \"2.5.29.36\":\n        // PolicyConstraints\n        try {\n          this.parsedValue = new _PolicyConstraints.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _PolicyConstraints.default();\n          this.parsedValue.parsingError = \"Incorrectly formated PolicyConstraints\";\n        }\n\n        break;\n\n      case \"2.5.29.37\":\n        // ExtKeyUsage\n        try {\n          this.parsedValue = new _ExtKeyUsage.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _ExtKeyUsage.default();\n          this.parsedValue.parsingError = \"Incorrectly formated ExtKeyUsage\";\n        }\n\n        break;\n\n      case \"2.5.29.54\":\n        // InhibitAnyPolicy\n        this.parsedValue = asn1.result; // Should be just a simple INTEGER\n\n        break;\n\n      case \"1.3.6.1.5.5.7.1.1\": // AuthorityInfoAccess\n\n      case \"1.3.6.1.5.5.7.1.11\":\n        // SubjectInfoAccess\n        try {\n          this.parsedValue = new _InfoAccess.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _InfoAccess.default();\n          this.parsedValue.parsingError = \"Incorrectly formated InfoAccess\";\n        }\n\n        break;\n\n      case \"1.3.6.1.4.1.11129.2.4.2\":\n        // SignedCertificateTimestampList\n        try {\n          this.parsedValue = new _SignedCertificateTimestampList.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _SignedCertificateTimestampList.default();\n          this.parsedValue.parsingError = \"Incorrectly formated SignedCertificateTimestampList\";\n        }\n\n        break;\n\n      case \"1.3.6.1.4.1.311.20.2\":\n        // szOID_ENROLL_CERTTYPE_EXTENSION - Microsoft-specific extension\n        this.parsedValue = asn1.result; // Used to be simple Unicode string\n\n        break;\n\n      case \"1.3.6.1.4.1.311.21.2\":\n        // szOID_CERTSRV_PREVIOUS_CERT_HASH - Microsoft-specific extension\n        this.parsedValue = asn1.result; // Used to be simple OctetString\n\n        break;\n\n      case \"1.3.6.1.4.1.311.21.7\":\n        // szOID_CERTIFICATE_TEMPLATE - Microsoft-specific extension\n        try {\n          this.parsedValue = new _CertificateTemplate.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _CertificateTemplate.default();\n          this.parsedValue.parsingError = \"Incorrectly formated CertificateTemplate\";\n        }\n\n        break;\n\n      case \"1.3.6.1.4.1.311.21.1\":\n        // szOID_CERTSRV_CA_VERSION - Microsoft-specific extension\n        try {\n          this.parsedValue = new _CAVersion.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _CAVersion.default();\n          this.parsedValue.parsingError = \"Incorrectly formated CAVersion\";\n        }\n\n        break;\n\n      case \"1.3.6.1.5.5.7.1.3\":\n        // QCStatements\n        try {\n          this.parsedValue = new _QCStatements.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          this.parsedValue = new _QCStatements.default();\n          this.parsedValue.parsingError = \"Incorrectly formated QCStatements\";\n        }\n\n        break;\n\n      default:\n    } //endregion\n    //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.ObjectIdentifier({\n      value: this.extnID\n    }));\n    if (this.critical !== Extension.defaultValues(\"critical\")) outputArray.push(new asn1js.Boolean({\n      value: this.critical\n    }));\n    outputArray.push(this.extnValue); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      extnID: this.extnID,\n      extnValue: this.extnValue.toJSON()\n    };\n    if (this.critical !== Extension.defaultValues(\"critical\")) object.critical = this.critical;\n\n    if (\"parsedValue\" in this) {\n      if (\"toJSON\" in this.parsedValue) object.parsedValue = this.parsedValue.toJSON();\n    }\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = Extension;\n//# sourceMappingURL=Extension.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/Extension.js\n// module id = ./node_modules/pkijs/build/Extension.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _Extension = _interopRequireDefault(require(\"./Extension.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass Extensions {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for Extensions class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<Extension>}\r\n     * @desc type\r\n     */\n    this.extensions = (0, _pvutils.getParametersValue)(parameters, \"extensions\", Extensions.defaultValues(\"extensions\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"extensions\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for Extensions class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @param {boolean} optional Flag that current schema should be optional\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}, optional = false) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [extensions]\r\n     * @property {string} [extension]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      optional,\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.extensions || \"\",\n        value: _Extension.default.schema(names.extension || {})\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"extensions\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, Extensions.schema({\n      names: {\n        extensions: \"extensions\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for Extensions\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.extensions = Array.from(asn1.result.extensions, element => new _Extension.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.extensions, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      extensions: Array.from(this.extensions, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = Extensions;\n//# sourceMappingURL=Extensions.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/Extensions.js\n// module id = ./node_modules/pkijs/build/Extensions.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _RelativeDistinguishedNames = _interopRequireDefault(require(\"./RelativeDistinguishedNames.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n//region Additional asn1js schema elements existing inside GeneralName schema\n//**************************************************************************************\n\n/**\r\n * Schema for \"builtInStandardAttributes\" of \"ORAddress\"\r\n * @param {Object} parameters\r\n * @property {Object} [names]\r\n * @param {boolean} optional\r\n * @returns {Sequence}\r\n */\nfunction builtInStandardAttributes(parameters = {}, optional = false) {\n  //builtInStandardAttributes ::= Sequence {\n  //    country-name                  CountryName OPTIONAL,\n  //    administration-domain-name    AdministrationDomainName OPTIONAL,\n  //    network-address           [0] IMPLICIT NetworkAddress OPTIONAL,\n  //    terminal-identifier       [1] IMPLICIT TerminalIdentifier OPTIONAL,\n  //    private-domain-name       [2] PrivateDomainName OPTIONAL,\n  //    organization-name         [3] IMPLICIT OrganizationName OPTIONAL,\n  //    numeric-user-identifier   [4] IMPLICIT NumericUserIdentifier OPTIONAL,\n  //    personal-name             [5] IMPLICIT PersonalName OPTIONAL,\n  //    organizational-unit-names [6] IMPLICIT OrganizationalUnitNames OPTIONAL }\n\n  /**\r\n   * @type {Object}\r\n   * @property {string} [country_name]\r\n   * @property {string} [administration_domain_name]\r\n   * @property {string} [network_address]\r\n   * @property {string} [terminal_identifier]\r\n   * @property {string} [private_domain_name]\r\n   * @property {string} [organization_name]\r\n   * @property {string} [numeric_user_identifier]\r\n   * @property {string} [personal_name]\r\n   * @property {string} [organizational_unit_names]\r\n   */\n  const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n  return new asn1js.Sequence({\n    optional,\n    value: [new asn1js.Constructed({\n      optional: true,\n      idBlock: {\n        tagClass: 2,\n        // APPLICATION-SPECIFIC\n        tagNumber: 1 // [1]\n\n      },\n      name: names.country_name || \"\",\n      value: [new asn1js.Choice({\n        value: [new asn1js.NumericString(), new asn1js.PrintableString()]\n      })]\n    }), new asn1js.Constructed({\n      optional: true,\n      idBlock: {\n        tagClass: 2,\n        // APPLICATION-SPECIFIC\n        tagNumber: 2 // [2]\n\n      },\n      name: names.administration_domain_name || \"\",\n      value: [new asn1js.Choice({\n        value: [new asn1js.NumericString(), new asn1js.PrintableString()]\n      })]\n    }), new asn1js.Primitive({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 0 // [0]\n\n      },\n      name: names.network_address || \"\",\n      isHexOnly: true\n    }), new asn1js.Primitive({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 1 // [1]\n\n      },\n      name: names.terminal_identifier || \"\",\n      isHexOnly: true\n    }), new asn1js.Constructed({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 2 // [2]\n\n      },\n      name: names.private_domain_name || \"\",\n      value: [new asn1js.Choice({\n        value: [new asn1js.NumericString(), new asn1js.PrintableString()]\n      })]\n    }), new asn1js.Primitive({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 3 // [3]\n\n      },\n      name: names.organization_name || \"\",\n      isHexOnly: true\n    }), new asn1js.Primitive({\n      optional: true,\n      name: names.numeric_user_identifier || \"\",\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 4 // [4]\n\n      },\n      isHexOnly: true\n    }), new asn1js.Constructed({\n      optional: true,\n      name: names.personal_name || \"\",\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 5 // [5]\n\n      },\n      value: [new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        isHexOnly: true\n      }), new asn1js.Primitive({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        isHexOnly: true\n      }), new asn1js.Primitive({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        isHexOnly: true\n      }), new asn1js.Primitive({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 3 // [3]\n\n        },\n        isHexOnly: true\n      })]\n    }), new asn1js.Constructed({\n      optional: true,\n      name: names.organizational_unit_names || \"\",\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 6 // [6]\n\n      },\n      value: [new asn1js.Repeated({\n        value: new asn1js.PrintableString()\n      })]\n    })]\n  });\n} //**************************************************************************************\n\n/**\r\n * Schema for \"builtInDomainDefinedAttributes\" of \"ORAddress\"\r\n * @param {boolean} optional\r\n * @returns {Sequence}\r\n */\n\n\nfunction builtInDomainDefinedAttributes(optional = false) {\n  return new asn1js.Sequence({\n    optional,\n    value: [new asn1js.PrintableString(), new asn1js.PrintableString()]\n  });\n} //**************************************************************************************\n\n/**\r\n * Schema for \"builtInDomainDefinedAttributes\" of \"ORAddress\"\r\n * @param {boolean} optional\r\n * @returns {Set}\r\n */\n\n\nfunction extensionAttributes(optional = false) {\n  return new asn1js.Set({\n    optional,\n    value: [new asn1js.Primitive({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 0 // [0]\n\n      },\n      isHexOnly: true\n    }), new asn1js.Constructed({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 1 // [1]\n\n      },\n      value: [new asn1js.Any()]\n    })]\n  });\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\n\n\nclass GeneralName {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for GeneralName class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   * @property {number} [type] value type - from a tagged value (0 for \"otherName\", 1 for \"rfc822Name\" etc.)\r\n   * @property {Object} [value] asn1js object having GeneralName value (type depends on \"type\" value)\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc value type - from a tagged value (0 for \"otherName\", 1 for \"rfc822Name\" etc.)\r\n     */\n    this.type = (0, _pvutils.getParametersValue)(parameters, \"type\", GeneralName.defaultValues(\"type\"));\n    /**\r\n     * @type {Object}\r\n     * @desc asn1js object having GeneralName value (type depends on \"type\" value)\r\n     */\n\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", GeneralName.defaultValues(\"value\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"type\":\n        return 9;\n\n      case \"value\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for GeneralName class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"type\":\n        return memberValue === GeneralName.defaultValues(memberName);\n\n      case \"value\":\n        return Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for GeneralName class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * GeneralName ::= Choice {\r\n   *    otherName                       [0]     OtherName,\r\n   *    rfc822Name                      [1]     IA5String,\r\n   *    dNSName                         [2]     IA5String,\r\n   *    x400Address                     [3]     ORAddress,\r\n   *    directoryName                   [4]     value,\r\n   *    ediPartyName                    [5]     EDIPartyName,\r\n   *    uniformResourceIdentifier       [6]     IA5String,\r\n   *    iPAddress                       [7]     OCTET STRING,\r\n   *    registeredID                    [8]     OBJECT IDENTIFIER }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {Object} [directoryName]\r\n     * @property {Object} [builtInStandardAttributes]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Choice({\n      value: [new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        name: names.blockName || \"\",\n        value: [new asn1js.ObjectIdentifier(), new asn1js.Constructed({\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: [new asn1js.Any()]\n        })]\n      }), new asn1js.Primitive({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        }\n      }), new asn1js.Primitive({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        }\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 3 // [3]\n\n        },\n        name: names.blockName || \"\",\n        value: [builtInStandardAttributes(names.builtInStandardAttributes || {}, false), builtInDomainDefinedAttributes(true), extensionAttributes(true)]\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 4 // [4]\n\n        },\n        name: names.blockName || \"\",\n        value: [_RelativeDistinguishedNames.default.schema(names.directoryName || {})]\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 5 // [5]\n\n        },\n        name: names.blockName || \"\",\n        value: [new asn1js.Constructed({\n          optional: true,\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: [new asn1js.Choice({\n            value: [new asn1js.TeletexString(), new asn1js.PrintableString(), new asn1js.UniversalString(), new asn1js.Utf8String(), new asn1js.BmpString()]\n          })]\n        }), new asn1js.Constructed({\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 1 // [1]\n\n          },\n          value: [new asn1js.Choice({\n            value: [new asn1js.TeletexString(), new asn1js.PrintableString(), new asn1js.UniversalString(), new asn1js.Utf8String(), new asn1js.BmpString()]\n          })]\n        })]\n      }), new asn1js.Primitive({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 6 // [6]\n\n        }\n      }), new asn1js.Primitive({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 7 // [7]\n\n        }\n      }), new asn1js.Primitive({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 8 // [8]\n\n        }\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"blockName\", \"otherName\", \"rfc822Name\", \"dNSName\", \"x400Address\", \"directoryName\", \"ediPartyName\", \"uniformResourceIdentifier\", \"iPAddress\", \"registeredID\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, GeneralName.schema({\n      names: {\n        blockName: \"blockName\",\n        otherName: \"otherName\",\n        rfc822Name: \"rfc822Name\",\n        dNSName: \"dNSName\",\n        x400Address: \"x400Address\",\n        directoryName: {\n          names: {\n            blockName: \"directoryName\"\n          }\n        },\n        ediPartyName: \"ediPartyName\",\n        uniformResourceIdentifier: \"uniformResourceIdentifier\",\n        iPAddress: \"iPAddress\",\n        registeredID: \"registeredID\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for GeneralName\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.type = asn1.result.blockName.idBlock.tagNumber;\n\n    switch (this.type) {\n      case 0:\n        // otherName\n        this.value = asn1.result.blockName;\n        break;\n\n      case 1: // rfc822Name + dNSName + uniformResourceIdentifier\n\n      case 2:\n      case 6:\n        {\n          const value = asn1.result.blockName;\n          value.idBlock.tagClass = 1; // UNIVERSAL\n\n          value.idBlock.tagNumber = 22; // IA5STRING\n\n          const valueBER = value.toBER(false);\n          this.value = asn1js.fromBER(valueBER).result.valueBlock.value;\n        }\n        break;\n\n      case 3:\n        // x400Address\n        this.value = asn1.result.blockName;\n        break;\n\n      case 4:\n        // directoryName\n        this.value = new _RelativeDistinguishedNames.default({\n          schema: asn1.result.directoryName\n        });\n        break;\n\n      case 5:\n        // ediPartyName\n        this.value = asn1.result.ediPartyName;\n        break;\n\n      case 7:\n        // iPAddress\n        this.value = new asn1js.OctetString({\n          valueHex: asn1.result.blockName.valueBlock.valueHex\n        });\n        break;\n\n      case 8:\n        // registeredID\n        {\n          const value = asn1.result.blockName;\n          value.idBlock.tagClass = 1; // UNIVERSAL\n\n          value.idBlock.tagNumber = 6; // ObjectIdentifier\n\n          const valueBER = value.toBER(false);\n          this.value = asn1js.fromBER(valueBER).result.valueBlock.toString(); // Getting a string representation of the ObjectIdentifier\n        }\n        break;\n\n      default:\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    switch (this.type) {\n      case 0:\n      case 3:\n      case 5:\n        return new asn1js.Constructed({\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: this.type\n          },\n          value: [this.value]\n        });\n\n      case 1:\n      case 2:\n      case 6:\n        {\n          const value = new asn1js.IA5String({\n            value: this.value\n          });\n          value.idBlock.tagClass = 3;\n          value.idBlock.tagNumber = this.type;\n          return value;\n        }\n\n      case 4:\n        return new asn1js.Constructed({\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 4\n          },\n          value: [this.value.toSchema()]\n        });\n\n      case 7:\n        {\n          const value = this.value;\n          value.idBlock.tagClass = 3;\n          value.idBlock.tagNumber = this.type;\n          return value;\n        }\n\n      case 8:\n        {\n          const value = new asn1js.ObjectIdentifier({\n            value: this.value\n          });\n          value.idBlock.tagClass = 3;\n          value.idBlock.tagNumber = this.type;\n          return value;\n        }\n\n      default:\n        return GeneralName.schema();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      type: this.type,\n      value: \"\"\n    };\n    if (typeof this.value === \"string\") _object.value = this.value;else {\n      try {\n        _object.value = this.value.toJSON();\n      } catch (ex) {}\n    }\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = GeneralName;\n//# sourceMappingURL=GeneralName.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/GeneralName.js\n// module id = ./node_modules/pkijs/build/GeneralName.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _GeneralName = _interopRequireDefault(require(\"./GeneralName.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass GeneralNames {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for GeneralNames class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<GeneralName>}\r\n     * @desc Array of \"general names\"\r\n     */\n    this.names = (0, _pvutils.getParametersValue)(parameters, \"names\", GeneralNames.defaultValues(\"names\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"names\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for GeneralNames class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @param {boolean} [optional=false] Flag would be element optional or not\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}, optional = false) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} utcTimeName Name for \"utcTimeName\" choice\r\n     * @property {string} generalTimeName Name for \"generalTimeName\" choice\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      optional,\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.generalNames || \"\",\n        value: _GeneralName.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"names\", \"generalNames\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, GeneralNames.schema({\n      names: {\n        blockName: \"names\",\n        generalNames: \"generalNames\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for GeneralNames\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.names = Array.from(asn1.result.generalNames, element => new _GeneralName.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.names, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      names: Array.from(this.names, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = GeneralNames;\n//# sourceMappingURL=GeneralNames.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/GeneralNames.js\n// module id = ./node_modules/pkijs/build/GeneralNames.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _GeneralName = _interopRequireDefault(require(\"./GeneralName.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass GeneralSubtree {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for GeneralSubtree class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {GeneralName}\r\n     * @desc base\r\n     */\n    this.base = (0, _pvutils.getParametersValue)(parameters, \"base\", GeneralSubtree.defaultValues(\"base\"));\n    /**\r\n     * @type {number|Integer}\r\n     * @desc base\r\n     */\n\n    this.minimum = (0, _pvutils.getParametersValue)(parameters, \"minimum\", GeneralSubtree.defaultValues(\"minimum\"));\n    if (\"maximum\" in parameters)\n      /**\r\n       * @type {number|Integer}\r\n       * @desc minimum\r\n       */\n      this.maximum = (0, _pvutils.getParametersValue)(parameters, \"maximum\", GeneralSubtree.defaultValues(\"maximum\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"base\":\n        return new _GeneralName.default();\n\n      case \"minimum\":\n        return 0;\n\n      case \"maximum\":\n        return 0;\n\n      default:\n        throw new Error(`Invalid member name for GeneralSubtree class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * GeneralSubtree ::= SEQUENCE {\r\n   *    base                    GeneralName,\r\n   *    minimum         [0]     BaseDistance DEFAULT 0,\r\n   *    maximum         [1]     BaseDistance OPTIONAL }\r\n   *\r\n   * BaseDistance ::= INTEGER (0..MAX)\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [base]\r\n     * @property {string} [minimum]\r\n     * @property {string} [maximum]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_GeneralName.default.schema(names.base || {}), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Integer({\n          name: names.minimum || \"\"\n        })]\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [new asn1js.Integer({\n          name: names.maximum || \"\"\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"base\", \"minimum\", \"maximum\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, GeneralSubtree.schema({\n      names: {\n        base: {\n          names: {\n            blockName: \"base\"\n          }\n        },\n        minimum: \"minimum\",\n        maximum: \"maximum\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for GeneralSubtree\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.base = new _GeneralName.default({\n      schema: asn1.result.base\n    });\n\n    if (\"minimum\" in asn1.result) {\n      if (asn1.result.minimum.valueBlock.isHexOnly) this.minimum = asn1.result.minimum;else this.minimum = asn1.result.minimum.valueBlock.valueDec;\n    }\n\n    if (\"maximum\" in asn1.result) {\n      if (asn1.result.maximum.valueBlock.isHexOnly) this.maximum = asn1.result.maximum;else this.maximum = asn1.result.maximum.valueBlock.valueDec;\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(this.base.toSchema());\n\n    if (this.minimum !== 0) {\n      let valueMinimum = 0;\n      if (this.minimum instanceof asn1js.Integer) valueMinimum = this.minimum;else valueMinimum = new asn1js.Integer({\n        value: this.minimum\n      });\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [valueMinimum]\n      }));\n    }\n\n    if (\"maximum\" in this) {\n      let valueMaximum = 0;\n      if (this.maximum instanceof asn1js.Integer) valueMaximum = this.maximum;else valueMaximum = new asn1js.Integer({\n        value: this.maximum\n      });\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [valueMaximum]\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      base: this.base.toJSON()\n    };\n\n    if (this.minimum !== 0) {\n      if (typeof this.minimum === \"number\") object.minimum = this.minimum;else object.minimum = this.minimum.toJSON();\n    }\n\n    if (\"maximum\" in this) {\n      if (typeof this.maximum === \"number\") object.maximum = this.maximum;else object.maximum = this.maximum.toJSON();\n    }\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = GeneralSubtree;\n//# sourceMappingURL=GeneralSubtree.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/GeneralSubtree.js\n// module id = ./node_modules/pkijs/build/GeneralSubtree.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AccessDescription = _interopRequireDefault(require(\"./AccessDescription.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass InfoAccess {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for InfoAccess class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<AccessDescription>}\r\n     * @desc accessDescriptions\r\n     */\n    this.accessDescriptions = (0, _pvutils.getParametersValue)(parameters, \"accessDescriptions\", InfoAccess.defaultValues(\"accessDescriptions\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"accessDescriptions\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for InfoAccess class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * AuthorityInfoAccessSyntax  ::=\r\n   * SEQUENCE SIZE (1..MAX) OF AccessDescription\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [accessDescriptions]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.accessDescriptions || \"\",\n        value: _AccessDescription.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"accessDescriptions\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, InfoAccess.schema({\n      names: {\n        accessDescriptions: \"accessDescriptions\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for InfoAccess\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.accessDescriptions = Array.from(asn1.result.accessDescriptions, element => new _AccessDescription.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.accessDescriptions, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      accessDescriptions: Array.from(this.accessDescriptions, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = InfoAccess;\n//# sourceMappingURL=InfoAccess.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/InfoAccess.js\n// module id = ./node_modules/pkijs/build/InfoAccess.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _RelativeDistinguishedNames = _interopRequireDefault(require(\"./RelativeDistinguishedNames.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass IssuerAndSerialNumber {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for IssuerAndSerialNumber class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {RelativeDistinguishedNames}\r\n     * @desc issuer\r\n     */\n    this.issuer = (0, _pvutils.getParametersValue)(parameters, \"issuer\", IssuerAndSerialNumber.defaultValues(\"issuer\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc serialNumber\r\n     */\n\n    this.serialNumber = (0, _pvutils.getParametersValue)(parameters, \"serialNumber\", IssuerAndSerialNumber.defaultValues(\"serialNumber\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"issuer\":\n        return new _RelativeDistinguishedNames.default();\n\n      case \"serialNumber\":\n        return new asn1js.Integer();\n\n      default:\n        throw new Error(`Invalid member name for IssuerAndSerialNumber class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * IssuerAndSerialNumber ::= SEQUENCE {\r\n   *    issuer Name,\r\n   *    serialNumber CertificateSerialNumber }\r\n   *\r\n   * CertificateSerialNumber ::= INTEGER\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [issuer]\r\n     * @property {string} [serialNumber]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_RelativeDistinguishedNames.default.schema(names.issuer || {}), new asn1js.Integer({\n        name: names.serialNumber || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"issuer\", \"serialNumber\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, IssuerAndSerialNumber.schema({\n      names: {\n        issuer: {\n          names: {\n            blockName: \"issuer\"\n          }\n        },\n        serialNumber: \"serialNumber\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for IssuerAndSerialNumber\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.issuer = new _RelativeDistinguishedNames.default({\n      schema: asn1.result.issuer\n    });\n    this.serialNumber = asn1.result.serialNumber; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.issuer.toSchema(), this.serialNumber]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      issuer: this.issuer.toJSON(),\n      serialNumber: this.serialNumber.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = IssuerAndSerialNumber;\n//# sourceMappingURL=IssuerAndSerialNumber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/IssuerAndSerialNumber.js\n// module id = ./node_modules/pkijs/build/IssuerAndSerialNumber.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _GeneralName = _interopRequireDefault(require(\"./GeneralName.js\"));\n\nvar _RelativeDistinguishedNames = _interopRequireDefault(require(\"./RelativeDistinguishedNames.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass IssuingDistributionPoint {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for IssuingDistributionPoint class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    if (\"distributionPoint\" in parameters)\n      /**\r\n       * @type {Array.<GeneralName>|RelativeDistinguishedNames}\r\n       * @desc distributionPoint\r\n       */\n      this.distributionPoint = (0, _pvutils.getParametersValue)(parameters, \"distributionPoint\", IssuingDistributionPoint.defaultValues(\"distributionPoint\"));\n    /**\r\n     * @type {boolean}\r\n     * @desc onlyContainsUserCerts\r\n     */\n\n    this.onlyContainsUserCerts = (0, _pvutils.getParametersValue)(parameters, \"onlyContainsUserCerts\", IssuingDistributionPoint.defaultValues(\"onlyContainsUserCerts\"));\n    /**\r\n     * @type {boolean}\r\n     * @desc onlyContainsCACerts\r\n     */\n\n    this.onlyContainsCACerts = (0, _pvutils.getParametersValue)(parameters, \"onlyContainsCACerts\", IssuingDistributionPoint.defaultValues(\"onlyContainsCACerts\"));\n    if (\"onlySomeReasons\" in parameters)\n      /**\r\n       * @type {number}\r\n       * @desc onlySomeReasons\r\n       */\n      this.onlySomeReasons = (0, _pvutils.getParametersValue)(parameters, \"onlySomeReasons\", IssuingDistributionPoint.defaultValues(\"onlySomeReasons\"));\n    /**\r\n     * @type {boolean}\r\n     * @desc indirectCRL\r\n     */\n\n    this.indirectCRL = (0, _pvutils.getParametersValue)(parameters, \"indirectCRL\", IssuingDistributionPoint.defaultValues(\"indirectCRL\"));\n    /**\r\n     * @type {boolean}\r\n     * @desc onlyContainsAttributeCerts\r\n     */\n\n    this.onlyContainsAttributeCerts = (0, _pvutils.getParametersValue)(parameters, \"onlyContainsAttributeCerts\", IssuingDistributionPoint.defaultValues(\"onlyContainsAttributeCerts\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"distributionPoint\":\n        return [];\n\n      case \"onlyContainsUserCerts\":\n        return false;\n\n      case \"onlyContainsCACerts\":\n        return false;\n\n      case \"onlySomeReasons\":\n        return 0;\n\n      case \"indirectCRL\":\n        return false;\n\n      case \"onlyContainsAttributeCerts\":\n        return false;\n\n      default:\n        throw new Error(`Invalid member name for IssuingDistributionPoint class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * IssuingDistributionPoint ::= SEQUENCE {\r\n   *    distributionPoint          [0] DistributionPointName OPTIONAL,\r\n   *    onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE,\r\n   *    onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE,\r\n   *    onlySomeReasons            [3] ReasonFlags OPTIONAL,\r\n   *    indirectCRL                [4] BOOLEAN DEFAULT FALSE,\r\n   *    onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }\r\n   *\r\n   * ReasonFlags ::= BIT STRING {\r\n   *    unused                  (0),\r\n   *    keyCompromise           (1),\r\n   *    cACompromise            (2),\r\n   *    affiliationChanged      (3),\r\n   *    superseded              (4),\r\n   *    cessationOfOperation    (5),\r\n   *    certificateHold         (6),\r\n   *    privilegeWithdrawn      (7),\r\n   *    aACompromise            (8) }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [distributionPoint]\r\n     * @property {string} [distributionPointNames]\r\n     * @property {string} [onlyContainsUserCerts]\r\n     * @property {string} [onlyContainsCACerts]\r\n     * @property {string} [onlySomeReasons]\r\n     * @property {string} [indirectCRL]\r\n     * @property {string} [onlyContainsAttributeCerts]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Choice({\n          value: [new asn1js.Constructed({\n            name: names.distributionPoint || \"\",\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 0 // [0]\n\n            },\n            value: [new asn1js.Repeated({\n              name: names.distributionPointNames || \"\",\n              value: _GeneralName.default.schema()\n            })]\n          }), new asn1js.Constructed({\n            name: names.distributionPoint || \"\",\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 1 // [1]\n\n            },\n            value: _RelativeDistinguishedNames.default.schema().valueBlock.value\n          })]\n        })]\n      }), new asn1js.Primitive({\n        name: names.onlyContainsUserCerts || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        }\n      }), // IMPLICIT boolean value\n      new asn1js.Primitive({\n        name: names.onlyContainsCACerts || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        }\n      }), // IMPLICIT boolean value\n      new asn1js.Primitive({\n        name: names.onlySomeReasons || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 3 // [3]\n\n        }\n      }), // IMPLICIT bitstring value\n      new asn1js.Primitive({\n        name: names.indirectCRL || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 4 // [4]\n\n        }\n      }), // IMPLICIT boolean value\n      new asn1js.Primitive({\n        name: names.onlyContainsAttributeCerts || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 5 // [5]\n\n        }\n      }) // IMPLICIT boolean value\n      ]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"distributionPoint\", \"distributionPointNames\", \"onlyContainsUserCerts\", \"onlyContainsCACerts\", \"onlySomeReasons\", \"indirectCRL\", \"onlyContainsAttributeCerts\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, IssuingDistributionPoint.schema({\n      names: {\n        distributionPoint: \"distributionPoint\",\n        distributionPointNames: \"distributionPointNames\",\n        onlyContainsUserCerts: \"onlyContainsUserCerts\",\n        onlyContainsCACerts: \"onlyContainsCACerts\",\n        onlySomeReasons: \"onlySomeReasons\",\n        indirectCRL: \"indirectCRL\",\n        onlyContainsAttributeCerts: \"onlyContainsAttributeCerts\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for IssuingDistributionPoint\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"distributionPoint\" in asn1.result) {\n      switch (true) {\n        case asn1.result.distributionPoint.idBlock.tagNumber === 0:\n          // GENERAL_NAMES variant\n          this.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new _GeneralName.default({\n            schema: element\n          }));\n          break;\n\n        case asn1.result.distributionPoint.idBlock.tagNumber === 1:\n          // RDN variant\n          {\n            this.distributionPoint = new _RelativeDistinguishedNames.default({\n              schema: new asn1js.Sequence({\n                value: asn1.result.distributionPoint.valueBlock.value\n              })\n            });\n          }\n          break;\n\n        default:\n          throw new Error(\"Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}\");\n      }\n    }\n\n    if (\"onlyContainsUserCerts\" in asn1.result) {\n      const view = new Uint8Array(asn1.result.onlyContainsUserCerts.valueBlock.valueHex);\n      this.onlyContainsUserCerts = view[0] !== 0x00;\n    }\n\n    if (\"onlyContainsCACerts\" in asn1.result) {\n      const view = new Uint8Array(asn1.result.onlyContainsCACerts.valueBlock.valueHex);\n      this.onlyContainsCACerts = view[0] !== 0x00;\n    }\n\n    if (\"onlySomeReasons\" in asn1.result) {\n      const view = new Uint8Array(asn1.result.onlySomeReasons.valueBlock.valueHex);\n      this.onlySomeReasons = view[0];\n    }\n\n    if (\"indirectCRL\" in asn1.result) {\n      const view = new Uint8Array(asn1.result.indirectCRL.valueBlock.valueHex);\n      this.indirectCRL = view[0] !== 0x00;\n    }\n\n    if (\"onlyContainsAttributeCerts\" in asn1.result) {\n      const view = new Uint8Array(asn1.result.onlyContainsAttributeCerts.valueBlock.valueHex);\n      this.onlyContainsAttributeCerts = view[0] !== 0x00;\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    if (\"distributionPoint\" in this) {\n      let value;\n\n      if (this.distributionPoint instanceof Array) {\n        value = new asn1js.Constructed({\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: Array.from(this.distributionPoint, element => element.toSchema())\n        });\n      } else {\n        value = this.distributionPoint.toSchema();\n        value.idBlock.tagClass = 3; // CONTEXT - SPECIFIC\n\n        value.idBlock.tagNumber = 1; // [1]\n      }\n\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [value]\n      }));\n    }\n\n    if (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsUserCerts\")) {\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        valueHex: new Uint8Array([0xFF]).buffer\n      }));\n    }\n\n    if (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsCACerts\")) {\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        valueHex: new Uint8Array([0xFF]).buffer\n      }));\n    }\n\n    if (\"onlySomeReasons\" in this) {\n      const buffer = new ArrayBuffer(1);\n      const view = new Uint8Array(buffer);\n      view[0] = this.onlySomeReasons;\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 3 // [3]\n\n        },\n        valueHex: buffer\n      }));\n    }\n\n    if (this.indirectCRL !== IssuingDistributionPoint.defaultValues(\"indirectCRL\")) {\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 4 // [4]\n\n        },\n        valueHex: new Uint8Array([0xFF]).buffer\n      }));\n    }\n\n    if (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsAttributeCerts\")) {\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 5 // [5]\n\n        },\n        valueHex: new Uint8Array([0xFF]).buffer\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {};\n\n    if (\"distributionPoint\" in this) {\n      if (this.distributionPoint instanceof Array) object.distributionPoint = Array.from(this.distributionPoint, element => element.toJSON());else object.distributionPoint = this.distributionPoint.toJSON();\n    }\n\n    if (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsUserCerts\")) object.onlyContainsUserCerts = this.onlyContainsUserCerts;\n    if (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsCACerts\")) object.onlyContainsCACerts = this.onlyContainsCACerts;\n    if (\"onlySomeReasons\" in this) object.onlySomeReasons = this.onlySomeReasons;\n    if (this.indirectCRL !== IssuingDistributionPoint.defaultValues(\"indirectCRL\")) object.indirectCRL = this.indirectCRL;\n    if (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsAttributeCerts\")) object.onlyContainsAttributeCerts = this.onlyContainsAttributeCerts;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = IssuingDistributionPoint;\n//# sourceMappingURL=IssuingDistributionPoint.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/IssuingDistributionPoint.js\n// module id = ./node_modules/pkijs/build/IssuingDistributionPoint.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _OtherKeyAttribute = _interopRequireDefault(require(\"./OtherKeyAttribute.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass KEKIdentifier {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for KEKIdentifier class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {OctetString}\r\n     * @desc keyIdentifier\r\n     */\n    this.keyIdentifier = (0, _pvutils.getParametersValue)(parameters, \"keyIdentifier\", KEKIdentifier.defaultValues(\"keyIdentifier\"));\n    if (\"date\" in parameters)\n      /**\r\n       * @type {GeneralizedTime}\r\n       * @desc date\r\n       */\n      this.date = (0, _pvutils.getParametersValue)(parameters, \"date\", KEKIdentifier.defaultValues(\"date\"));\n    if (\"other\" in parameters)\n      /**\r\n       * @type {OtherKeyAttribute}\r\n       * @desc other\r\n       */\n      this.other = (0, _pvutils.getParametersValue)(parameters, \"other\", KEKIdentifier.defaultValues(\"other\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"keyIdentifier\":\n        return new asn1js.OctetString();\n\n      case \"date\":\n        return new asn1js.GeneralizedTime();\n\n      case \"other\":\n        return new _OtherKeyAttribute.default();\n\n      default:\n        throw new Error(`Invalid member name for KEKIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"keyIdentifier\":\n        return memberValue.isEqual(KEKIdentifier.defaultValues(\"keyIdentifier\"));\n\n      case \"date\":\n        // noinspection OverlyComplexBooleanExpressionJS\n        return memberValue.year === 0 && memberValue.month === 0 && memberValue.day === 0 && memberValue.hour === 0 && memberValue.minute === 0 && memberValue.second === 0 && memberValue.millisecond === 0;\n\n      case \"other\":\n        return memberValue.compareWithDefault(\"keyAttrId\", memberValue.keyAttrId) && \"keyAttr\" in memberValue === false;\n\n      default:\n        throw new Error(`Invalid member name for KEKIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * KEKIdentifier ::= SEQUENCE {\r\n   *    keyIdentifier OCTET STRING,\r\n   *    date GeneralizedTime OPTIONAL,\r\n   *    other OtherKeyAttribute OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [keyIdentifier]\r\n     * @property {string} [date]\r\n     * @property {string} [other]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.OctetString({\n        name: names.keyIdentifier || \"\"\n      }), new asn1js.GeneralizedTime({\n        optional: true,\n        name: names.date || \"\"\n      }), _OtherKeyAttribute.default.schema(names.other || {})]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"keyIdentifier\", \"date\", \"other\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, KEKIdentifier.schema({\n      names: {\n        keyIdentifier: \"keyIdentifier\",\n        date: \"date\",\n        other: {\n          names: {\n            blockName: \"other\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for KEKIdentifier\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.keyIdentifier = asn1.result.keyIdentifier;\n    if (\"date\" in asn1.result) this.date = asn1.result.date;\n    if (\"other\" in asn1.result) this.other = new _OtherKeyAttribute.default({\n      schema: asn1.result.other\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(this.keyIdentifier);\n    if (\"date\" in this) outputArray.push(this.date);\n    if (\"other\" in this) outputArray.push(this.other.toSchema()); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      keyIdentifier: this.keyIdentifier.toJSON()\n    };\n    if (\"date\" in this) _object.date = this.date;\n    if (\"other\" in this) _object.other = this.other.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = KEKIdentifier;\n//# sourceMappingURL=KEKIdentifier.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/KEKIdentifier.js\n// module id = ./node_modules/pkijs/build/KEKIdentifier.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _KEKIdentifier = _interopRequireDefault(require(\"./KEKIdentifier.js\"));\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass KEKRecipientInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for KEKRecipientInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", KEKRecipientInfo.defaultValues(\"version\"));\n    /**\r\n     * @type {KEKIdentifier}\r\n     * @desc kekid\r\n     */\n\n    this.kekid = (0, _pvutils.getParametersValue)(parameters, \"kekid\", KEKRecipientInfo.defaultValues(\"kekid\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc keyEncryptionAlgorithm\r\n     */\n\n    this.keyEncryptionAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"keyEncryptionAlgorithm\", KEKRecipientInfo.defaultValues(\"keyEncryptionAlgorithm\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc encryptedKey\r\n     */\n\n    this.encryptedKey = (0, _pvutils.getParametersValue)(parameters, \"encryptedKey\", KEKRecipientInfo.defaultValues(\"encryptedKey\"));\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc preDefinedKEK KEK using to encrypt CEK\r\n     */\n\n    this.preDefinedKEK = (0, _pvutils.getParametersValue)(parameters, \"preDefinedKEK\", KEKRecipientInfo.defaultValues(\"preDefinedKEK\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"kekid\":\n        return new _KEKIdentifier.default();\n\n      case \"keyEncryptionAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"encryptedKey\":\n        return new asn1js.OctetString();\n\n      case \"preDefinedKEK\":\n        return new ArrayBuffer(0);\n\n      default:\n        throw new Error(`Invalid member name for KEKRecipientInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"KEKRecipientInfo\":\n        return memberValue === KEKRecipientInfo.defaultValues(\"version\");\n\n      case \"kekid\":\n        return memberValue.compareWithDefault(\"keyIdentifier\", memberValue.keyIdentifier) && \"date\" in memberValue === false && \"other\" in memberValue === false;\n\n      case \"keyEncryptionAlgorithm\":\n        return memberValue.algorithmId === \"\" && \"algorithmParams\" in memberValue === false;\n\n      case \"encryptedKey\":\n        return memberValue.isEqual(KEKRecipientInfo.defaultValues(\"encryptedKey\"));\n\n      case \"preDefinedKEK\":\n        return memberValue.byteLength === 0;\n\n      default:\n        throw new Error(`Invalid member name for KEKRecipientInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * KEKRecipientInfo ::= SEQUENCE {\r\n   *    version CMSVersion,  -- always set to 4\r\n   *    kekid KEKIdentifier,\r\n   *    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,\r\n   *    encryptedKey EncryptedKey }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [kekid]\r\n     * @property {string} [keyEncryptionAlgorithm]\r\n     * @property {string} [encryptedKey]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), _KEKIdentifier.default.schema(names.kekid || {}), _AlgorithmIdentifier.default.schema(names.keyEncryptionAlgorithm || {}), new asn1js.OctetString({\n        name: names.encryptedKey || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"kekid\", \"keyEncryptionAlgorithm\", \"encryptedKey\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, KEKRecipientInfo.schema({\n      names: {\n        version: \"version\",\n        kekid: {\n          names: {\n            blockName: \"kekid\"\n          }\n        },\n        keyEncryptionAlgorithm: {\n          names: {\n            blockName: \"keyEncryptionAlgorithm\"\n          }\n        },\n        encryptedKey: \"encryptedKey\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for KEKRecipientInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n    this.kekid = new _KEKIdentifier.default({\n      schema: asn1.result.kekid\n    });\n    this.keyEncryptionAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.keyEncryptionAlgorithm\n    });\n    this.encryptedKey = asn1.result.encryptedKey; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.Integer({\n        value: this.version\n      }), this.kekid.toSchema(), this.keyEncryptionAlgorithm.toSchema(), this.encryptedKey]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      version: this.version,\n      kekid: this.kekid.toJSON(),\n      keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),\n      encryptedKey: this.encryptedKey.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = KEKRecipientInfo;\n//# sourceMappingURL=KEKRecipientInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/KEKRecipientInfo.js\n// module id = ./node_modules/pkijs/build/KEKRecipientInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _IssuerAndSerialNumber = _interopRequireDefault(require(\"./IssuerAndSerialNumber.js\"));\n\nvar _RecipientKeyIdentifier = _interopRequireDefault(require(\"./RecipientKeyIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass KeyAgreeRecipientIdentifier {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for KeyAgreeRecipientIdentifier class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc variant\r\n     */\n    this.variant = (0, _pvutils.getParametersValue)(parameters, \"variant\", KeyAgreeRecipientIdentifier.defaultValues(\"variant\"));\n    /**\r\n     * @type {*}\r\n     * @desc values\r\n     */\n\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", KeyAgreeRecipientIdentifier.defaultValues(\"value\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"variant\":\n        return -1;\n\n      case \"value\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for KeyAgreeRecipientIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"variant\":\n        return memberValue === -1;\n\n      case \"value\":\n        return Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for KeyAgreeRecipientIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * KeyAgreeRecipientIdentifier ::= CHOICE {\r\n   *    issuerAndSerialNumber IssuerAndSerialNumber,\r\n   *    rKeyId [0] IMPLICIT RecipientKeyIdentifier }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [issuerAndSerialNumber]\r\n     * @property {string} [rKeyId]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Choice({\n      value: [_IssuerAndSerialNumber.default.schema(names.issuerAndSerialNumber || {\n        names: {\n          blockName: names.blockName || \"\"\n        }\n      }), new asn1js.Constructed({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: _RecipientKeyIdentifier.default.schema(names.rKeyId || {\n          names: {\n            blockName: names.blockName || \"\"\n          }\n        }).valueBlock.value\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"blockName\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, KeyAgreeRecipientIdentifier.schema({\n      names: {\n        blockName: \"blockName\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for KeyAgreeRecipientIdentifier\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (asn1.result.blockName.idBlock.tagClass === 1) {\n      this.variant = 1;\n      this.value = new _IssuerAndSerialNumber.default({\n        schema: asn1.result.blockName\n      });\n    } else {\n      this.variant = 2;\n      this.value = new _RecipientKeyIdentifier.default({\n        schema: new asn1js.Sequence({\n          value: asn1.result.blockName.valueBlock.value\n        })\n      });\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    switch (this.variant) {\n      case 1:\n        return this.value.toSchema();\n\n      case 2:\n        return new asn1js.Constructed({\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: this.value.toSchema().valueBlock.value\n        });\n\n      default:\n        return new asn1js.Any();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      variant: this.variant\n    };\n    if (this.variant === 1 || this.variant === 2) _object.value = this.value.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = KeyAgreeRecipientIdentifier;\n//# sourceMappingURL=KeyAgreeRecipientIdentifier.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/KeyAgreeRecipientIdentifier.js\n// module id = ./node_modules/pkijs/build/KeyAgreeRecipientIdentifier.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _OriginatorIdentifierOrKey = _interopRequireDefault(require(\"./OriginatorIdentifierOrKey.js\"));\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _RecipientEncryptedKeys = _interopRequireDefault(require(\"./RecipientEncryptedKeys.js\"));\n\nvar _Certificate = _interopRequireDefault(require(\"./Certificate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass KeyAgreeRecipientInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for KeyAgreeRecipientInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", KeyAgreeRecipientInfo.defaultValues(\"version\"));\n    /**\r\n     * @type {OriginatorIdentifierOrKey}\r\n     * @desc originator\r\n     */\n\n    this.originator = (0, _pvutils.getParametersValue)(parameters, \"originator\", KeyAgreeRecipientInfo.defaultValues(\"originator\"));\n    if (\"ukm\" in parameters)\n      /**\r\n       * @type {OctetString}\r\n       * @desc ukm\r\n       */\n      this.ukm = (0, _pvutils.getParametersValue)(parameters, \"ukm\", KeyAgreeRecipientInfo.defaultValues(\"ukm\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc keyEncryptionAlgorithm\r\n     */\n\n    this.keyEncryptionAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"keyEncryptionAlgorithm\", KeyAgreeRecipientInfo.defaultValues(\"keyEncryptionAlgorithm\"));\n    /**\r\n     * @type {RecipientEncryptedKeys}\r\n     * @desc recipientEncryptedKeys\r\n     */\n\n    this.recipientEncryptedKeys = (0, _pvutils.getParametersValue)(parameters, \"recipientEncryptedKeys\", KeyAgreeRecipientInfo.defaultValues(\"recipientEncryptedKeys\"));\n    /**\r\n     * @type {Certificate}\r\n     * @desc recipientCertificate For some reasons we need to store recipient's certificate here\r\n     */\n\n    this.recipientCertificate = (0, _pvutils.getParametersValue)(parameters, \"recipientCertificate\", KeyAgreeRecipientInfo.defaultValues(\"recipientCertificate\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"originator\":\n        return new _OriginatorIdentifierOrKey.default();\n\n      case \"ukm\":\n        return new asn1js.OctetString();\n\n      case \"keyEncryptionAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"recipientEncryptedKeys\":\n        return new _RecipientEncryptedKeys.default();\n\n      case \"recipientCertificate\":\n        return new _Certificate.default();\n\n      default:\n        throw new Error(`Invalid member name for KeyAgreeRecipientInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n        return memberValue === 0;\n\n      case \"originator\":\n        return memberValue.variant === -1 && \"value\" in memberValue === false;\n\n      case \"ukm\":\n        return memberValue.isEqual(KeyAgreeRecipientInfo.defaultValues(\"ukm\"));\n\n      case \"keyEncryptionAlgorithm\":\n        return memberValue.algorithmId === \"\" && \"algorithmParams\" in memberValue === false;\n\n      case \"recipientEncryptedKeys\":\n        return memberValue.encryptedKeys.length === 0;\n\n      case \"recipientCertificate\":\n        return false;\n      // For now leave it as is\n\n      default:\n        throw new Error(`Invalid member name for KeyAgreeRecipientInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * KeyAgreeRecipientInfo ::= SEQUENCE {\r\n   *    version CMSVersion,  -- always set to 3\r\n   *    originator [0] EXPLICIT OriginatorIdentifierOrKey,\r\n   *    ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,\r\n   *    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,\r\n   *    recipientEncryptedKeys RecipientEncryptedKeys }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [originator]\r\n     * @property {string} [ukm]\r\n     * @property {string} [keyEncryptionAlgorithm]\r\n     * @property {string} [recipientEncryptedKeys]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [_OriginatorIdentifierOrKey.default.schema(names.originator || {})]\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [new asn1js.OctetString({\n          name: names.ukm || \"\"\n        })]\n      }), _AlgorithmIdentifier.default.schema(names.keyEncryptionAlgorithm || {}), _RecipientEncryptedKeys.default.schema(names.recipientEncryptedKeys || {})]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"originator\", \"ukm\", \"keyEncryptionAlgorithm\", \"recipientEncryptedKeys\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, KeyAgreeRecipientInfo.schema({\n      names: {\n        version: \"version\",\n        originator: {\n          names: {\n            blockName: \"originator\"\n          }\n        },\n        ukm: \"ukm\",\n        keyEncryptionAlgorithm: {\n          names: {\n            blockName: \"keyEncryptionAlgorithm\"\n          }\n        },\n        recipientEncryptedKeys: {\n          names: {\n            blockName: \"recipientEncryptedKeys\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for KeyAgreeRecipientInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n    this.originator = new _OriginatorIdentifierOrKey.default({\n      schema: asn1.result.originator\n    });\n    if (\"ukm\" in asn1.result) this.ukm = asn1.result.ukm;\n    this.keyEncryptionAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.keyEncryptionAlgorithm\n    });\n    this.recipientEncryptedKeys = new _RecipientEncryptedKeys.default({\n      schema: asn1.result.recipientEncryptedKeys\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for final sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.Integer({\n      value: this.version\n    }));\n    outputArray.push(new asn1js.Constructed({\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 0 // [0]\n\n      },\n      value: [this.originator.toSchema()]\n    }));\n\n    if (\"ukm\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [this.ukm]\n      }));\n    }\n\n    outputArray.push(this.keyEncryptionAlgorithm.toSchema());\n    outputArray.push(this.recipientEncryptedKeys.toSchema()); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      version: this.version,\n      originator: this.originator.toJSON()\n    };\n    if (\"ukm\" in this) _object.ukm = this.ukm.toJSON();\n    _object.keyEncryptionAlgorithm = this.keyEncryptionAlgorithm.toJSON();\n    _object.recipientEncryptedKeys = this.recipientEncryptedKeys.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = KeyAgreeRecipientInfo;\n//# sourceMappingURL=KeyAgreeRecipientInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/KeyAgreeRecipientInfo.js\n// module id = ./node_modules/pkijs/build/KeyAgreeRecipientInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _Certificate = _interopRequireDefault(require(\"./Certificate.js\"));\n\nvar _RecipientIdentifier = _interopRequireDefault(require(\"./RecipientIdentifier.js\"));\n\nvar _IssuerAndSerialNumber = _interopRequireDefault(require(\"./IssuerAndSerialNumber.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass KeyTransRecipientInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for KeyTransRecipientInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", KeyTransRecipientInfo.defaultValues(\"version\"));\n    /**\r\n     * @type {RecipientIdentifier}\r\n     * @desc rid\r\n     */\n\n    this.rid = (0, _pvutils.getParametersValue)(parameters, \"rid\", KeyTransRecipientInfo.defaultValues(\"rid\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc keyEncryptionAlgorithm\r\n     */\n\n    this.keyEncryptionAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"keyEncryptionAlgorithm\", KeyTransRecipientInfo.defaultValues(\"keyEncryptionAlgorithm\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc encryptedKey\r\n     */\n\n    this.encryptedKey = (0, _pvutils.getParametersValue)(parameters, \"encryptedKey\", KeyTransRecipientInfo.defaultValues(\"encryptedKey\"));\n    /**\r\n     * @type {Certificate}\r\n     * @desc recipientCertificate For some reasons we need to store recipient's certificate here\r\n     */\n\n    this.recipientCertificate = (0, _pvutils.getParametersValue)(parameters, \"recipientCertificate\", KeyTransRecipientInfo.defaultValues(\"recipientCertificate\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return -1;\n\n      case \"rid\":\n        return {};\n\n      case \"keyEncryptionAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"encryptedKey\":\n        return new asn1js.OctetString();\n\n      case \"recipientCertificate\":\n        return new _Certificate.default();\n\n      default:\n        throw new Error(`Invalid member name for KeyTransRecipientInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n        return memberValue === KeyTransRecipientInfo.defaultValues(\"version\");\n\n      case \"rid\":\n        return Object.keys(memberValue).length === 0;\n\n      case \"keyEncryptionAlgorithm\":\n      case \"encryptedKey\":\n        return memberValue.isEqual(KeyTransRecipientInfo.defaultValues(memberName));\n\n      case \"recipientCertificate\":\n        return false;\n      // For now we do not need to compare any values with the \"recipientCertificate\"\n\n      default:\n        throw new Error(`Invalid member name for KeyTransRecipientInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * KeyTransRecipientInfo ::= SEQUENCE {\r\n   *    version CMSVersion,  -- always set to 0 or 2\r\n   *    rid RecipientIdentifier,\r\n   *    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,\r\n   *    encryptedKey EncryptedKey }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [rid]\r\n     * @property {string} [keyEncryptionAlgorithm]\r\n     * @property {string} [encryptedKey]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), _RecipientIdentifier.default.schema(names.rid || {}), _AlgorithmIdentifier.default.schema(names.keyEncryptionAlgorithm || {}), new asn1js.OctetString({\n        name: names.encryptedKey || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"rid\", \"keyEncryptionAlgorithm\", \"encryptedKey\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, KeyTransRecipientInfo.schema({\n      names: {\n        version: \"version\",\n        rid: {\n          names: {\n            blockName: \"rid\"\n          }\n        },\n        keyEncryptionAlgorithm: {\n          names: {\n            blockName: \"keyEncryptionAlgorithm\"\n          }\n        },\n        encryptedKey: \"encryptedKey\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for KeyTransRecipientInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n    if (asn1.result.rid.idBlock.tagClass === 3) this.rid = new asn1js.OctetString({\n      valueHex: asn1.result.rid.valueBlock.valueHex\n    }); // SubjectKeyIdentifier\n    else this.rid = new _IssuerAndSerialNumber.default({\n        schema: asn1.result.rid\n      });\n    this.keyEncryptionAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.keyEncryptionAlgorithm\n    });\n    this.encryptedKey = asn1.result.encryptedKey; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence \n    const outputArray = [];\n\n    if (this.rid instanceof _IssuerAndSerialNumber.default) {\n      this.version = 0;\n      outputArray.push(new asn1js.Integer({\n        value: this.version\n      }));\n      outputArray.push(this.rid.toSchema());\n    } else {\n      this.version = 2;\n      outputArray.push(new asn1js.Integer({\n        value: this.version\n      }));\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        valueHex: this.rid.valueBlock.valueHex\n      }));\n    }\n\n    outputArray.push(this.keyEncryptionAlgorithm.toSchema());\n    outputArray.push(this.encryptedKey); //endregion \n    //region Construct and return new ASN.1 schema for this object \n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion \n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      version: this.version,\n      rid: this.rid.toJSON(),\n      keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),\n      encryptedKey: this.encryptedKey.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = KeyTransRecipientInfo;\n//# sourceMappingURL=KeyTransRecipientInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/KeyTransRecipientInfo.js\n// module id = ./node_modules/pkijs/build/KeyTransRecipientInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _DigestInfo = _interopRequireDefault(require(\"./DigestInfo.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC7292\r\n */\nclass MacData {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for MacData class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {DigestInfo}\r\n     * @desc mac\r\n     */\n    this.mac = (0, _pvutils.getParametersValue)(parameters, \"mac\", MacData.defaultValues(\"mac\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc macSalt\r\n     */\n\n    this.macSalt = (0, _pvutils.getParametersValue)(parameters, \"macSalt\", MacData.defaultValues(\"macSalt\"));\n    if (\"iterations\" in parameters)\n      /**\r\n       * @type {number}\r\n       * @desc iterations\r\n       */\n      this.iterations = (0, _pvutils.getParametersValue)(parameters, \"iterations\", MacData.defaultValues(\"iterations\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"mac\":\n        return new _DigestInfo.default();\n\n      case \"macSalt\":\n        return new asn1js.OctetString();\n\n      case \"iterations\":\n        return 1;\n\n      default:\n        throw new Error(`Invalid member name for MacData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"mac\":\n        return _DigestInfo.default.compareWithDefault(\"digestAlgorithm\", memberValue.digestAlgorithm) && _DigestInfo.default.compareWithDefault(\"digest\", memberValue.digest);\n\n      case \"macSalt\":\n        return memberValue.isEqual(MacData.defaultValues(memberName));\n\n      case \"iterations\":\n        return memberValue === MacData.defaultValues(memberName);\n\n      default:\n        throw new Error(`Invalid member name for MacData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * MacData ::= SEQUENCE {\r\n   *    mac \t\tDigestInfo,\r\n   *    macSalt       OCTET STRING,\r\n   *    iterations\tINTEGER DEFAULT 1\r\n   *    -- Note: The default is for historical reasons and its use is\r\n   *    -- deprecated. A higher value, like 1024 is recommended.\r\n   *    }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [optional]\r\n     * @property {string} [mac]\r\n     * @property {string} [macSalt]\r\n     * @property {string} [iterations]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      optional: names.optional || true,\n      value: [_DigestInfo.default.schema(names.mac || {\n        names: {\n          blockName: \"mac\"\n        }\n      }), new asn1js.OctetString({\n        name: names.macSalt || \"macSalt\"\n      }), new asn1js.Integer({\n        optional: true,\n        name: names.iterations || \"iterations\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"mac\", \"macSalt\", \"iterations\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, MacData.schema({\n      names: {\n        mac: {\n          names: {\n            blockName: \"mac\"\n          }\n        },\n        macSalt: \"macSalt\",\n        iterations: \"iterations\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for MacData\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.mac = new _DigestInfo.default({\n      schema: asn1.result.mac\n    });\n    this.macSalt = asn1.result.macSalt;\n    if (\"iterations\" in asn1.result) this.iterations = asn1.result.iterations.valueBlock.valueDec; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    const outputArray = [this.mac.toSchema(), this.macSalt];\n    if (\"iterations\" in this) outputArray.push(new asn1js.Integer({\n      value: this.iterations\n    }));\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const output = {\n      mac: this.mac.toJSON(),\n      macSalt: this.macSalt.toJSON()\n    };\n    if (\"iterations\" in this) output.iterations = this.iterations.toJSON();\n    return output;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = MacData;\n//# sourceMappingURL=MacData.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/MacData.js\n// module id = ./node_modules/pkijs/build/MacData.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC3161\r\n */\nclass MessageImprint {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for MessageImprint class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc hashAlgorithm\r\n     */\n    this.hashAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"hashAlgorithm\", MessageImprint.defaultValues(\"hashAlgorithm\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc hashedMessage\r\n     */\n\n    this.hashedMessage = (0, _pvutils.getParametersValue)(parameters, \"hashedMessage\", MessageImprint.defaultValues(\"hashedMessage\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"hashAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"hashedMessage\":\n        return new asn1js.OctetString();\n\n      default:\n        throw new Error(`Invalid member name for MessageImprint class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"hashAlgorithm\":\n        return memberValue.algorithmId === \"\" && \"algorithmParams\" in memberValue === false;\n\n      case \"hashedMessage\":\n        return memberValue.isEqual(MessageImprint.defaultValues(memberName)) === 0;\n\n      default:\n        throw new Error(`Invalid member name for MessageImprint class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * MessageImprint ::= SEQUENCE  {\r\n   *    hashAlgorithm                AlgorithmIdentifier,\r\n   *    hashedMessage                OCTET STRING  }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [hashAlgorithm]\r\n     * @property {string} [hashedMessage]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_AlgorithmIdentifier.default.schema(names.hashAlgorithm || {}), new asn1js.OctetString({\n        name: names.hashedMessage || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"hashAlgorithm\", \"hashedMessage\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, MessageImprint.schema({\n      names: {\n        hashAlgorithm: {\n          names: {\n            blockName: \"hashAlgorithm\"\n          }\n        },\n        hashedMessage: \"hashedMessage\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for MessageImprint\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.hashAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.hashAlgorithm\n    });\n    this.hashedMessage = asn1.result.hashedMessage; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.hashAlgorithm.toSchema(), this.hashedMessage]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      hashAlgorithm: this.hashAlgorithm.toJSON(),\n      hashedMessage: this.hashedMessage.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = MessageImprint;\n//# sourceMappingURL=MessageImprint.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/MessageImprint.js\n// module id = ./node_modules/pkijs/build/MessageImprint.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _GeneralSubtree = _interopRequireDefault(require(\"./GeneralSubtree.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass NameConstraints {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for NameConstraints class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    if (\"permittedSubtrees\" in parameters)\n      /**\r\n       * @type {Array.<GeneralSubtree>}\r\n       * @desc permittedSubtrees\r\n       */\n      this.permittedSubtrees = (0, _pvutils.getParametersValue)(parameters, \"permittedSubtrees\", NameConstraints.defaultValues(\"permittedSubtrees\"));\n    if (\"excludedSubtrees\" in parameters)\n      /**\r\n       * @type {Array.<GeneralSubtree>}\r\n       * @desc excludedSubtrees\r\n       */\n      this.excludedSubtrees = (0, _pvutils.getParametersValue)(parameters, \"excludedSubtrees\", NameConstraints.defaultValues(\"excludedSubtrees\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"permittedSubtrees\":\n        return [];\n\n      case \"excludedSubtrees\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for NameConstraints class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * NameConstraints ::= SEQUENCE {\r\n   *    permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,\r\n   *    excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [permittedSubtrees]\r\n     * @property {string} [excludedSubtrees]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Repeated({\n          name: names.permittedSubtrees || \"\",\n          value: _GeneralSubtree.default.schema()\n        })]\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [new asn1js.Repeated({\n          name: names.excludedSubtrees || \"\",\n          value: _GeneralSubtree.default.schema()\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"permittedSubtrees\", \"excludedSubtrees\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, NameConstraints.schema({\n      names: {\n        permittedSubtrees: \"permittedSubtrees\",\n        excludedSubtrees: \"excludedSubtrees\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for NameConstraints\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"permittedSubtrees\" in asn1.result) this.permittedSubtrees = Array.from(asn1.result.permittedSubtrees, element => new _GeneralSubtree.default({\n      schema: element\n    }));\n    if (\"excludedSubtrees\" in asn1.result) this.excludedSubtrees = Array.from(asn1.result.excludedSubtrees, element => new _GeneralSubtree.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    if (\"permittedSubtrees\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: Array.from(this.permittedSubtrees, element => element.toSchema())\n      }));\n    }\n\n    if (\"excludedSubtrees\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: Array.from(this.excludedSubtrees, element => element.toSchema())\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {};\n    if (\"permittedSubtrees\" in this) object.permittedSubtrees = Array.from(this.permittedSubtrees, element => element.toJSON());\n    if (\"excludedSubtrees\" in this) object.excludedSubtrees = Array.from(this.excludedSubtrees, element => element.toJSON());\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = NameConstraints;\n//# sourceMappingURL=NameConstraints.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/NameConstraints.js\n// module id = ./node_modules/pkijs/build/NameConstraints.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _IssuerAndSerialNumber = _interopRequireDefault(require(\"./IssuerAndSerialNumber.js\"));\n\nvar _OriginatorPublicKey = _interopRequireDefault(require(\"./OriginatorPublicKey.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass OriginatorIdentifierOrKey {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for OriginatorIdentifierOrKey class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc variant\r\n     */\n    this.variant = (0, _pvutils.getParametersValue)(parameters, \"variant\", OriginatorIdentifierOrKey.defaultValues(\"variant\"));\n    if (\"value\" in parameters)\n      /**\r\n       * @type {IssuerAndSerialNumber|OctetString|OriginatorPublicKey}\r\n       * @desc value\r\n       */\n      this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", OriginatorIdentifierOrKey.defaultValues(\"value\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"variant\":\n        return -1;\n\n      case \"value\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for OriginatorIdentifierOrKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"variant\":\n        return memberValue === -1;\n\n      case \"value\":\n        return Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for OriginatorIdentifierOrKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * OriginatorIdentifierOrKey ::= CHOICE {\r\n   *    issuerAndSerialNumber IssuerAndSerialNumber,\r\n   *    subjectKeyIdentifier [0] SubjectKeyIdentifier,\r\n   *    originatorKey [1] OriginatorPublicKey }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Choice({\n      value: [_IssuerAndSerialNumber.default.schema({\n        names: {\n          blockName: names.blockName || \"\"\n        }\n      }), new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        name: names.blockName || \"\"\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        name: names.blockName || \"\",\n        value: _OriginatorPublicKey.default.schema().valueBlock.value\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"blockName\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, OriginatorIdentifierOrKey.schema({\n      names: {\n        blockName: \"blockName\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for OriginatorIdentifierOrKey\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (asn1.result.blockName.idBlock.tagClass === 1) {\n      this.variant = 1;\n      this.value = new _IssuerAndSerialNumber.default({\n        schema: asn1.result.blockName\n      });\n    } else {\n      if (asn1.result.blockName.idBlock.tagNumber === 0) {\n        //region Create \"OCTETSTRING\" from \"ASN1_PRIMITIVE\"\n        asn1.result.blockName.idBlock.tagClass = 1; // UNIVERSAL\n\n        asn1.result.blockName.idBlock.tagNumber = 4; // OCTETSTRING\n        //endregion\n\n        this.variant = 2;\n        this.value = asn1.result.blockName;\n      } else {\n        this.variant = 3;\n        this.value = new _OriginatorPublicKey.default({\n          schema: new asn1js.Sequence({\n            value: asn1.result.blockName.valueBlock.value\n          })\n        });\n      }\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    switch (this.variant) {\n      case 1:\n        return this.value.toSchema();\n\n      case 2:\n        this.value.idBlock.tagClass = 3; // CONTEXT-SPECIFIC\n\n        this.value.idBlock.tagNumber = 0; // [0]\n\n        return this.value;\n\n      case 3:\n        {\n          const _schema = this.value.toSchema();\n\n          _schema.idBlock.tagClass = 3; // CONTEXT-SPECIFIC\n\n          _schema.idBlock.tagNumber = 1; // [1]\n\n          return _schema;\n        }\n\n      default:\n        return new asn1js.Any();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      variant: this.variant\n    };\n    if (this.variant === 1 || this.variant === 2 || this.variant === 3) _object.value = this.value.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = OriginatorIdentifierOrKey;\n//# sourceMappingURL=OriginatorIdentifierOrKey.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/OriginatorIdentifierOrKey.js\n// module id = ./node_modules/pkijs/build/OriginatorIdentifierOrKey.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _CertificateSet = _interopRequireDefault(require(\"./CertificateSet.js\"));\n\nvar _RevocationInfoChoices = _interopRequireDefault(require(\"./RevocationInfoChoices.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass OriginatorInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for OriginatorInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    if (\"certs\" in parameters)\n      /**\r\n       * @type {CertificateSet}\r\n       * @desc certs\r\n       */\n      this.certs = (0, _pvutils.getParametersValue)(parameters, \"certs\", OriginatorInfo.defaultValues(\"certs\"));\n    if (\"crls\" in parameters)\n      /**\r\n       * @type {RevocationInfoChoices}\r\n       * @desc crls\r\n       */\n      this.crls = (0, _pvutils.getParametersValue)(parameters, \"crls\", OriginatorInfo.defaultValues(\"crls\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"certs\":\n        return new _CertificateSet.default();\n\n      case \"crls\":\n        return new _RevocationInfoChoices.default();\n\n      default:\n        throw new Error(`Invalid member name for OriginatorInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"certs\":\n        return memberValue.certificates.length === 0;\n\n      case \"crls\":\n        return memberValue.crls.length === 0 && memberValue.otherRevocationInfos.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for OriginatorInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * OriginatorInfo ::= SEQUENCE {\r\n   *    certs [0] IMPLICIT CertificateSet OPTIONAL,\r\n   *    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [certs]\r\n     * @property {string} [crls]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Constructed({\n        name: names.certs || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: _CertificateSet.default.schema().valueBlock.value\n      }), new asn1js.Constructed({\n        name: names.crls || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: _RevocationInfoChoices.default.schema().valueBlock.value\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"certs\", \"crls\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, OriginatorInfo.schema({\n      names: {\n        certs: \"certs\",\n        crls: \"crls\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for OriginatorInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"certs\" in asn1.result) {\n      this.certs = new _CertificateSet.default({\n        schema: new asn1js.Set({\n          value: asn1.result.certs.valueBlock.value\n        })\n      });\n    }\n\n    if (\"crls\" in asn1.result) {\n      this.crls = new _RevocationInfoChoices.default({\n        schema: new asn1js.Set({\n          value: asn1.result.crls.valueBlock.value\n        })\n      });\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    const sequenceValue = [];\n\n    if (\"certs\" in this) {\n      sequenceValue.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: this.certs.toSchema().valueBlock.value\n      }));\n    }\n\n    if (\"crls\" in this) {\n      sequenceValue.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: this.crls.toSchema().valueBlock.value\n      }));\n    } //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: sequenceValue\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {};\n    if (\"certs\" in this) object.certs = this.certs.toJSON();\n    if (\"crls\" in this) object.crls = this.crls.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = OriginatorInfo;\n//# sourceMappingURL=OriginatorInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/OriginatorInfo.js\n// module id = ./node_modules/pkijs/build/OriginatorInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass OriginatorPublicKey {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for OriginatorPublicKey class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc algorithm\r\n     */\n    this.algorithm = (0, _pvutils.getParametersValue)(parameters, \"algorithm\", OriginatorPublicKey.defaultValues(\"algorithm\"));\n    /**\r\n     * @type {BitString}\r\n     * @desc publicKey\r\n     */\n\n    this.publicKey = (0, _pvutils.getParametersValue)(parameters, \"publicKey\", OriginatorPublicKey.defaultValues(\"publicKey\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"algorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"publicKey\":\n        return new asn1js.BitString();\n\n      default:\n        throw new Error(`Invalid member name for OriginatorPublicKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"algorithm\":\n      case \"publicKey\":\n        return memberValue.isEqual(OriginatorPublicKey.defaultValues(memberName));\n\n      default:\n        throw new Error(`Invalid member name for OriginatorPublicKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * OriginatorPublicKey ::= SEQUENCE {\r\n   *    algorithm AlgorithmIdentifier,\r\n   *    publicKey BIT STRING }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [algorithm]\r\n     * @property {string} [publicKey]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_AlgorithmIdentifier.default.schema(names.algorithm || {}), new asn1js.BitString({\n        name: names.publicKey || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"algorithm\", \"publicKey\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, OriginatorPublicKey.schema({\n      names: {\n        algorithm: {\n          names: {\n            blockName: \"algorithm\"\n          }\n        },\n        publicKey: \"publicKey\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for OriginatorPublicKey\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.algorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.algorithm\n    });\n    this.publicKey = asn1.result.publicKey; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.algorithm.toSchema(), this.publicKey]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      algorithm: this.algorithm.toJSON(),\n      publicKey: this.publicKey.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = OriginatorPublicKey;\n//# sourceMappingURL=OriginatorPublicKey.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/OriginatorPublicKey.js\n// module id = ./node_modules/pkijs/build/OriginatorPublicKey.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass OtherCertificateFormat {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for OtherCertificateFormat class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc otherCertFormat\r\n     */\n    this.otherCertFormat = (0, _pvutils.getParametersValue)(parameters, \"otherCertFormat\", OtherCertificateFormat.defaultValues(\"otherCertFormat\"));\n    /**\r\n     * @type {Any}\r\n     * @desc otherCert\r\n     */\n\n    this.otherCert = (0, _pvutils.getParametersValue)(parameters, \"otherCert\", OtherCertificateFormat.defaultValues(\"otherCert\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"otherCertFormat\":\n        return \"\";\n\n      case \"otherCert\":\n        return new asn1js.Any();\n\n      default:\n        throw new Error(`Invalid member name for OtherCertificateFormat class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * OtherCertificateFormat ::= SEQUENCE {\r\n   *    otherCertFormat OBJECT IDENTIFIER,\r\n   *    otherCert ANY DEFINED BY otherCertFormat }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [otherCertFormat]\r\n     * @property {string} [otherCert]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.otherCertFormat || \"otherCertFormat\"\n      }), new asn1js.Any({\n        name: names.otherCert || \"otherCert\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"otherCertFormat\", \"otherCert\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, OtherCertificateFormat.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for OtherCertificateFormat\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.otherCertFormat = asn1.result.otherCertFormat.valueBlock.toString();\n    this.otherCert = asn1.result.otherCert; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.otherCertFormat\n      }), this.otherCert]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      otherCertFormat: this.otherCertFormat\n    };\n    if (!(this.otherCert instanceof asn1js.Any)) object.otherCert = this.otherCert.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = OtherCertificateFormat;\n//# sourceMappingURL=OtherCertificateFormat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/OtherCertificateFormat.js\n// module id = ./node_modules/pkijs/build/OtherCertificateFormat.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass OtherKeyAttribute {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for OtherKeyAttribute class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc keyAttrId\r\n     */\n    this.keyAttrId = (0, _pvutils.getParametersValue)(parameters, \"keyAttrId\", OtherKeyAttribute.defaultValues(\"keyAttrId\"));\n    if (\"keyAttr\" in parameters)\n      /**\r\n       * @type {*}\r\n       * @desc keyAttr\r\n       */\n      this.keyAttr = (0, _pvutils.getParametersValue)(parameters, \"keyAttr\", OtherKeyAttribute.defaultValues(\"keyAttr\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"keyAttrId\":\n        return \"\";\n\n      case \"keyAttr\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for OtherKeyAttribute class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"keyAttrId\":\n        return memberValue === \"\";\n\n      case \"keyAttr\":\n        return Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for OtherKeyAttribute class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * OtherKeyAttribute ::= SEQUENCE {\r\n   *    keyAttrId OBJECT IDENTIFIER,\r\n   *    keyAttr ANY DEFINED BY keyAttrId OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [optional]\r\n     * @property {string} [keyAttrId]\r\n     * @property {string} [keyAttr]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      optional: names.optional || true,\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.keyAttrId || \"\"\n      }), new asn1js.Any({\n        optional: true,\n        name: names.keyAttr || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"keyAttrId\", \"keyAttr\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, OtherKeyAttribute.schema({\n      names: {\n        keyAttrId: \"keyAttrId\",\n        keyAttr: \"keyAttr\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for OtherKeyAttribute\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.keyAttrId = asn1.result.keyAttrId.valueBlock.toString();\n    if (\"keyAttr\" in asn1.result) this.keyAttr = asn1.result.keyAttr; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.ObjectIdentifier({\n      value: this.keyAttrId\n    }));\n    if (\"keyAttr\" in this) outputArray.push(this.keyAttr); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      keyAttrId: this.keyAttrId\n    };\n    if (\"keyAttr\" in this) _object.keyAttr = this.keyAttr.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = OtherKeyAttribute;\n//# sourceMappingURL=OtherKeyAttribute.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/OtherKeyAttribute.js\n// module id = ./node_modules/pkijs/build/OtherKeyAttribute.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC3447\r\n */\nclass OtherPrimeInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for OtherPrimeInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Integer}\r\n     * @desc prime\r\n     */\n    this.prime = (0, _pvutils.getParametersValue)(parameters, \"prime\", OtherPrimeInfo.defaultValues(\"prime\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc exponent\r\n     */\n\n    this.exponent = (0, _pvutils.getParametersValue)(parameters, \"exponent\", OtherPrimeInfo.defaultValues(\"exponent\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc coefficient\r\n     */\n\n    this.coefficient = (0, _pvutils.getParametersValue)(parameters, \"coefficient\", OtherPrimeInfo.defaultValues(\"coefficient\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n    //region If input argument array contains \"json\" for this object\n\n    if (\"json\" in parameters) this.fromJSON(parameters.json); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"prime\":\n        return new asn1js.Integer();\n\n      case \"exponent\":\n        return new asn1js.Integer();\n\n      case \"coefficient\":\n        return new asn1js.Integer();\n\n      default:\n        throw new Error(`Invalid member name for OtherPrimeInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * OtherPrimeInfo ::= Sequence {\r\n   *    prime             Integer,  -- ri\r\n   *    exponent          Integer,  -- di\r\n   *    coefficient       Integer   -- ti\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} prime\r\n     * @property {string} exponent\r\n     * @property {string} coefficient\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.prime || \"\"\n      }), new asn1js.Integer({\n        name: names.exponent || \"\"\n      }), new asn1js.Integer({\n        name: names.coefficient || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"prime\", \"exponent\", \"coefficient\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, OtherPrimeInfo.schema({\n      names: {\n        prime: \"prime\",\n        exponent: \"exponent\",\n        coefficient: \"coefficient\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for OtherPrimeInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.prime = asn1.result.prime.convertFromDER();\n    this.exponent = asn1.result.exponent.convertFromDER();\n    this.coefficient = asn1.result.coefficient.convertFromDER(); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.prime.convertToDER(), this.exponent.convertToDER(), this.coefficient.convertToDER()]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      r: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.prime.valueBlock.valueHex), true, true),\n      d: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.exponent.valueBlock.valueHex), true, true),\n      t: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.coefficient.valueBlock.valueHex), true, true)\n    };\n  } //**********************************************************************************\n\n  /**\r\n   * Convert JSON value into current object\r\n   * @param {Object} json\r\n   */\n\n\n  fromJSON(json) {\n    if (\"r\" in json) this.prime = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.r, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"r\\\"\");\n    if (\"d\" in json) this.exponent = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.d, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"d\\\"\");\n    if (\"t\" in json) this.coefficient = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.t, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"t\\\"\");\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = OtherPrimeInfo;\n//# sourceMappingURL=OtherPrimeInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/OtherPrimeInfo.js\n// module id = ./node_modules/pkijs/build/OtherPrimeInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass OtherRecipientInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for OtherRecipientInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc oriType\r\n     */\n    this.oriType = (0, _pvutils.getParametersValue)(parameters, \"oriType\", OtherRecipientInfo.defaultValues(\"oriType\"));\n    /**\r\n     * @type {*}\r\n     * @desc oriValue\r\n     */\n\n    this.oriValue = (0, _pvutils.getParametersValue)(parameters, \"oriValue\", OtherRecipientInfo.defaultValues(\"oriValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"oriType\":\n        return \"\";\n\n      case \"oriValue\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for OtherRecipientInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"oriType\":\n        return memberValue === \"\";\n\n      case \"oriValue\":\n        return Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for OtherRecipientInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * OtherRecipientInfo ::= SEQUENCE {\r\n   *    oriType OBJECT IDENTIFIER,\r\n   *    oriValue ANY DEFINED BY oriType }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [oriType]\r\n     * @property {string} [oriValue]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.oriType || \"\"\n      }), new asn1js.Any({\n        name: names.oriValue || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"oriType\", \"oriValue\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, OtherRecipientInfo.schema({\n      names: {\n        oriType: \"oriType\",\n        oriValue: \"oriValue\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for OtherRecipientInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.oriType = asn1.result.oriType.valueBlock.toString();\n    this.oriValue = asn1.result.oriValue; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.oriType\n      }), this.oriValue]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      oriType: this.oriType\n    };\n    if (OtherRecipientInfo.compareWithDefault(\"oriValue\", this.oriValue) === false) _object.oriValue = this.oriValue.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = OtherRecipientInfo;\n//# sourceMappingURL=OtherRecipientInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/OtherRecipientInfo.js\n// module id = ./node_modules/pkijs/build/OtherRecipientInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass OtherRevocationInfoFormat {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for OtherRevocationInfoFormat class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc otherRevInfoFormat\r\n     */\n    this.otherRevInfoFormat = (0, _pvutils.getParametersValue)(parameters, \"otherRevInfoFormat\", OtherRevocationInfoFormat.defaultValues(\"otherRevInfoFormat\"));\n    /**\r\n     * @type {Any}\r\n     * @desc otherRevInfo\r\n     */\n\n    this.otherRevInfo = (0, _pvutils.getParametersValue)(parameters, \"otherRevInfo\", OtherRevocationInfoFormat.defaultValues(\"otherRevInfo\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"otherRevInfoFormat\":\n        return \"\";\n\n      case \"otherRevInfo\":\n        return new asn1js.Any();\n\n      default:\n        throw new Error(`Invalid member name for OtherRevocationInfoFormat class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * OtherCertificateFormat ::= SEQUENCE {\r\n   *    otherRevInfoFormat OBJECT IDENTIFIER,\r\n   *    otherRevInfo ANY DEFINED BY otherCertFormat }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [otherRevInfoFormat]\r\n     * @property {string} [otherRevInfo]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.otherRevInfoFormat || \"otherRevInfoFormat\"\n      }), new asn1js.Any({\n        name: names.otherRevInfo || \"otherRevInfo\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"otherRevInfoFormat\", \"otherRevInfo\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, OtherRevocationInfoFormat.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for OtherRevocationInfoFormat\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.otherRevInfoFormat = asn1.result.otherRevInfoFormat.valueBlock.toString();\n    this.otherRevInfo = asn1.result.otherRevInfo; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.otherRevInfoFormat\n      }), this.otherRevInfo]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      otherRevInfoFormat: this.otherRevInfoFormat\n    };\n    if (!(this.otherRevInfo instanceof asn1js.Any)) object.otherRevInfo = this.otherRevInfo.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = OtherRevocationInfoFormat;\n//# sourceMappingURL=OtherRevocationInfoFormat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/OtherRevocationInfoFormat.js\n// module id = ./node_modules/pkijs/build/OtherRevocationInfoFormat.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC2898\r\n */\nclass PBES2Params {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PBES2Params class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc keyDerivationFunc\r\n     */\n    this.keyDerivationFunc = (0, _pvutils.getParametersValue)(parameters, \"keyDerivationFunc\", PBES2Params.defaultValues(\"keyDerivationFunc\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc encryptionScheme\r\n     */\n\n    this.encryptionScheme = (0, _pvutils.getParametersValue)(parameters, \"encryptionScheme\", PBES2Params.defaultValues(\"encryptionScheme\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"keyDerivationFunc\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"encryptionScheme\":\n        return new _AlgorithmIdentifier.default();\n\n      default:\n        throw new Error(`Invalid member name for PBES2Params class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PBES2-params ::= SEQUENCE {\r\n   *    keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},\r\n   *    encryptionScheme AlgorithmIdentifier {{PBES2-Encs}} }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [keyDerivationFunc]\r\n     * @property {string} [encryptionScheme]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_AlgorithmIdentifier.default.schema(names.keyDerivationFunc || {}), _AlgorithmIdentifier.default.schema(names.encryptionScheme || {})]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"keyDerivationFunc\", \"encryptionScheme\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PBES2Params.schema({\n      names: {\n        keyDerivationFunc: {\n          names: {\n            blockName: \"keyDerivationFunc\"\n          }\n        },\n        encryptionScheme: {\n          names: {\n            blockName: \"encryptionScheme\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PBES2Params\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.keyDerivationFunc = new _AlgorithmIdentifier.default({\n      schema: asn1.result.keyDerivationFunc\n    });\n    this.encryptionScheme = new _AlgorithmIdentifier.default({\n      schema: asn1.result.encryptionScheme\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.keyDerivationFunc.toSchema(), this.encryptionScheme.toSchema()]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      keyDerivationFunc: this.keyDerivationFunc.toJSON(),\n      encryptionScheme: this.encryptionScheme.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PBES2Params;\n//# sourceMappingURL=PBES2Params.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PBES2Params.js\n// module id = ./node_modules/pkijs/build/PBES2Params.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC2898\r\n */\nclass PBKDF2Params {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PBKDF2Params class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Object}\r\n     * @desc salt\r\n     */\n    this.salt = (0, _pvutils.getParametersValue)(parameters, \"salt\", PBKDF2Params.defaultValues(\"salt\"));\n    /**\r\n     * @type {number}\r\n     * @desc iterationCount\r\n     */\n\n    this.iterationCount = (0, _pvutils.getParametersValue)(parameters, \"iterationCount\", PBKDF2Params.defaultValues(\"iterationCount\"));\n    if (\"keyLength\" in parameters)\n      /**\r\n       * @type {number}\r\n       * @desc keyLength\r\n       */\n      this.keyLength = (0, _pvutils.getParametersValue)(parameters, \"keyLength\", PBKDF2Params.defaultValues(\"keyLength\"));\n    if (\"prf\" in parameters)\n      /**\r\n       * @type {AlgorithmIdentifier}\r\n       * @desc prf\r\n       */\n      this.prf = (0, _pvutils.getParametersValue)(parameters, \"prf\", PBKDF2Params.defaultValues(\"prf\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"salt\":\n        return {};\n\n      case \"iterationCount\":\n        return -1;\n\n      case \"keyLength\":\n        return 0;\n\n      case \"prf\":\n        return new _AlgorithmIdentifier.default({\n          algorithmId: \"1.3.14.3.2.26\",\n          // SHA-1\n          algorithmParams: new asn1js.Null()\n        });\n\n      default:\n        throw new Error(`Invalid member name for PBKDF2Params class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PBKDF2-params ::= SEQUENCE {\r\n   *    salt CHOICE {\r\n   *        specified OCTET STRING,\r\n   *        otherSource AlgorithmIdentifier },\r\n   *  iterationCount INTEGER (1..MAX),\r\n   *  keyLength INTEGER (1..MAX) OPTIONAL,\r\n   *  prf AlgorithmIdentifier\r\n   *    DEFAULT { algorithm hMAC-SHA1, parameters NULL } }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [saltPrimitive]\r\n     * @property {string} [saltConstructed]\r\n     * @property {string} [iterationCount]\r\n     * @property {string} [keyLength]\r\n     * @property {string} [prf]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Choice({\n        value: [new asn1js.OctetString({\n          name: names.saltPrimitive || \"\"\n        }), _AlgorithmIdentifier.default.schema(names.saltConstructed || {})]\n      }), new asn1js.Integer({\n        name: names.iterationCount || \"\"\n      }), new asn1js.Integer({\n        name: names.keyLength || \"\",\n        optional: true\n      }), _AlgorithmIdentifier.default.schema(names.prf || {\n        names: {\n          optional: true\n        }\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"salt\", \"iterationCount\", \"keyLength\", \"prf\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PBKDF2Params.schema({\n      names: {\n        saltPrimitive: \"salt\",\n        saltConstructed: {\n          names: {\n            blockName: \"salt\"\n          }\n        },\n        iterationCount: \"iterationCount\",\n        keyLength: \"keyLength\",\n        prf: {\n          names: {\n            blockName: \"prf\",\n            optional: true\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PBKDF2Params\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.salt = asn1.result.salt;\n    this.iterationCount = asn1.result.iterationCount.valueBlock.valueDec;\n    if (\"keyLength\" in asn1.result) this.keyLength = asn1.result.keyLength.valueBlock.valueDec;\n    if (\"prf\" in asn1.result) this.prf = new _AlgorithmIdentifier.default({\n      schema: asn1.result.prf\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence \n    const outputArray = [];\n    outputArray.push(this.salt);\n    outputArray.push(new asn1js.Integer({\n      value: this.iterationCount\n    }));\n\n    if (\"keyLength\" in this) {\n      if (PBKDF2Params.defaultValues(\"keyLength\") !== this.keyLength) outputArray.push(new asn1js.Integer({\n        value: this.keyLength\n      }));\n    }\n\n    if (\"prf\" in this) {\n      if (PBKDF2Params.defaultValues(\"prf\").isEqual(this.prf) === false) outputArray.push(this.prf.toSchema());\n    } //endregion \n    //region Construct and return new ASN.1 schema for this object \n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion \n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      salt: this.salt.toJSON(),\n      iterationCount: this.iterationCount\n    };\n\n    if (\"keyLength\" in this) {\n      if (PBKDF2Params.defaultValues(\"keyLength\") !== this.keyLength) _object.keyLength = this.keyLength;\n    }\n\n    if (\"prf\" in this) {\n      if (PBKDF2Params.defaultValues(\"prf\").isEqual(this.prf) === false) _object.prf = this.prf.toJSON();\n    }\n\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PBKDF2Params;\n//# sourceMappingURL=PBKDF2Params.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PBKDF2Params.js\n// module id = ./node_modules/pkijs/build/PBKDF2Params.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _ContentInfo = _interopRequireDefault(require(\"./ContentInfo.js\"));\n\nvar _MacData = _interopRequireDefault(require(\"./MacData.js\"));\n\nvar _DigestInfo = _interopRequireDefault(require(\"./DigestInfo.js\"));\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _SignedData = _interopRequireDefault(require(\"./SignedData.js\"));\n\nvar _EncapsulatedContentInfo = _interopRequireDefault(require(\"./EncapsulatedContentInfo.js\"));\n\nvar _Attribute = _interopRequireDefault(require(\"./Attribute.js\"));\n\nvar _SignerInfo = _interopRequireDefault(require(\"./SignerInfo.js\"));\n\nvar _IssuerAndSerialNumber = _interopRequireDefault(require(\"./IssuerAndSerialNumber.js\"));\n\nvar _SignedAndUnsignedAttributes = _interopRequireDefault(require(\"./SignedAndUnsignedAttributes.js\"));\n\nvar _AuthenticatedSafe = _interopRequireDefault(require(\"./AuthenticatedSafe.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC7292\r\n */\nclass PFX {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PFX class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", PFX.defaultValues(\"version\"));\n    /**\r\n     * @type {ContentInfo}\r\n     * @desc authSafe\r\n     */\n\n    this.authSafe = (0, _pvutils.getParametersValue)(parameters, \"authSafe\", PFX.defaultValues(\"authSafe\"));\n    if (\"macData\" in parameters)\n      /**\r\n       * @type {MacData}\r\n       * @desc macData\r\n       */\n      this.macData = (0, _pvutils.getParametersValue)(parameters, \"macData\", PFX.defaultValues(\"macData\"));\n    if (\"parsedValue\" in parameters)\n      /**\r\n       * @type {*}\r\n       * @desc parsedValue\r\n       */\n      this.parsedValue = (0, _pvutils.getParametersValue)(parameters, \"parsedValue\", PFX.defaultValues(\"parsedValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 3;\n\n      case \"authSafe\":\n        return new _ContentInfo.default();\n\n      case \"macData\":\n        return new _MacData.default();\n\n      case \"parsedValue\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for PFX class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n        return memberValue === PFX.defaultValues(memberName);\n\n      case \"authSafe\":\n        return _ContentInfo.default.compareWithDefault(\"contentType\", memberValue.contentType) && _ContentInfo.default.compareWithDefault(\"content\", memberValue.content);\n\n      case \"macData\":\n        return _MacData.default.compareWithDefault(\"mac\", memberValue.mac) && _MacData.default.compareWithDefault(\"macSalt\", memberValue.macSalt) && _MacData.default.compareWithDefault(\"iterations\", memberValue.iterations);\n\n      case \"parsedValue\":\n        return memberValue instanceof Object && Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for PFX class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PFX ::= SEQUENCE {\r\n   *    version\t\tINTEGER {v3(3)}(v3,...),\r\n   *    authSafe\tContentInfo,\r\n   *    macData    \tMacData OPTIONAL\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [authSafe]\r\n     * @property {string} [macData]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"version\"\n      }), _ContentInfo.default.schema(names.authSafe || {\n        names: {\n          blockName: \"authSafe\"\n        }\n      }), _MacData.default.schema(names.macData || {\n        names: {\n          blockName: \"macData\",\n          optional: true\n        }\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"authSafe\", \"macData\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PFX.schema({\n      names: {\n        version: \"version\",\n        authSafe: {\n          names: {\n            blockName: \"authSafe\"\n          }\n        },\n        macData: {\n          names: {\n            blockName: \"macData\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PFX\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n    this.authSafe = new _ContentInfo.default({\n      schema: asn1.result.authSafe\n    });\n    if (\"macData\" in asn1.result) this.macData = new _MacData.default({\n      schema: asn1.result.macData\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    const outputArray = [new asn1js.Integer({\n      value: this.version\n    }), this.authSafe.toSchema()];\n    if (\"macData\" in this) outputArray.push(this.macData.toSchema());\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const output = {\n      version: this.version,\n      authSafe: this.authSafe.toJSON()\n    };\n    if (\"macData\" in this) output.macData = this.macData.toJSON();\n    return output;\n  } //**********************************************************************************\n\n  /**\r\n   * Making ContentInfo from \"parsedValue\" object\r\n   * @param {Object} parameters Parameters, specific to each \"integrity mode\"\r\n   */\n\n\n  makeInternalValues(parameters = {}) {\n    //region Check mandatory parameter\n    if (parameters instanceof Object === false) return Promise.reject(\"The \\\"parameters\\\" must has \\\"Object\\\" type\");\n    if (\"parsedValue\" in this === false) return Promise.reject(\"Please call \\\"parseValues\\\" function first in order to make \\\"parsedValue\\\" data\");\n    if (\"integrityMode\" in this.parsedValue === false) return Promise.reject(\"Absent mandatory parameter \\\"integrityMode\\\" inside \\\"parsedValue\\\"\"); //endregion\n    //region Initial variables\n\n    let sequence = Promise.resolve(); //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Makes values for each particular integrity mode\n    //region Check that we do have neccessary fields in \"parsedValue\" object\n\n    if (\"authenticatedSafe\" in this.parsedValue === false) return Promise.reject(\"Absent mandatory parameter \\\"authenticatedSafe\\\" in \\\"parsedValue\\\"\"); //endregion\n\n    switch (this.parsedValue.integrityMode) {\n      //region HMAC-based integrity\n      case 0:\n        {\n          //region Check additional mandatory parameters\n          if (\"iterations\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"iterations\\\"\");\n          if (\"pbkdf2HashAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"pbkdf2HashAlgorithm\\\"\");\n          if (\"hmacHashAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"hmacHashAlgorithm\\\"\");\n          if (\"password\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\"\"); //endregion\n          //region Initial variables\n\n          const saltBuffer = new ArrayBuffer(64);\n          const saltView = new Uint8Array(saltBuffer);\n          (0, _common.getRandomValues)(saltView);\n          const data = this.parsedValue.authenticatedSafe.toSchema().toBER(false);\n          this.authSafe = new _ContentInfo.default({\n            contentType: \"1.2.840.113549.1.7.1\",\n            content: new asn1js.OctetString({\n              valueHex: data\n            })\n          }); //endregion\n          //region Call current crypto engine for making HMAC-based data stamp\n\n          const engine = (0, _common.getEngine)();\n          if (\"stampDataWithPassword\" in engine.subtle === false) return Promise.reject(`No support for \"stampDataWithPassword\" in current engine \"${engine.name}\"`);\n          sequence = sequence.then(() => engine.subtle.stampDataWithPassword({\n            password: parameters.password,\n            hashAlgorithm: parameters.hmacHashAlgorithm,\n            salt: saltBuffer,\n            iterationCount: parameters.iterations,\n            contentToStamp: data\n          })); //endregion\n          //region Make \"MacData\" values\n\n          sequence = sequence.then(result => {\n            this.macData = new _MacData.default({\n              mac: new _DigestInfo.default({\n                digestAlgorithm: new _AlgorithmIdentifier.default({\n                  algorithmId: (0, _common.getOIDByAlgorithm)({\n                    name: parameters.hmacHashAlgorithm\n                  })\n                }),\n                digest: new asn1js.OctetString({\n                  valueHex: result\n                })\n              }),\n              macSalt: new asn1js.OctetString({\n                valueHex: saltBuffer\n              }),\n              iterations: parameters.iterations\n            });\n          }, error => Promise.reject(error)); //endregion\n          //endregion\n        }\n        break;\n      //endregion\n      //region publicKey-based integrity\n\n      case 1:\n        {\n          //region Check additional mandatory parameters\n          if (\"signingCertificate\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"signingCertificate\\\"\");\n          if (\"privateKey\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"privateKey\\\"\");\n          if (\"hashAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"hashAlgorithm\\\"\"); //endregion\n          //region Making data to be signed\n          // NOTE: all internal data for \"authenticatedSafe\" must be already prepared.\n          // Thus user must call \"makeValues\" for all internal \"SafeContent\" value with appropriate parameters.\n          // Or user can choose to use values from initial parsing of existing PKCS#12 data.\n\n          const toBeSigned = this.parsedValue.authenticatedSafe.toSchema().toBER(false); //endregion\n          //region Initial variables\n\n          const cmsSigned = new _SignedData.default({\n            version: 1,\n            encapContentInfo: new _EncapsulatedContentInfo.default({\n              eContentType: \"1.2.840.113549.1.7.1\",\n              // \"data\" content type\n              eContent: new asn1js.OctetString({\n                valueHex: toBeSigned\n              })\n            }),\n            certificates: [parameters.signingCertificate]\n          }); //endregion\n          //region Making additional attributes for CMS Signed Data\n          //region Create a message digest\n\n          sequence = sequence.then(() => crypto.digest({\n            name: parameters.hashAlgorithm\n          }, new Uint8Array(toBeSigned))); //endregion\n          //region Combine all signed extensions\n\n          sequence = sequence.then(result => {\n            //region Initial variables\n            const signedAttr = []; //endregion\n            //region contentType\n\n            signedAttr.push(new _Attribute.default({\n              type: \"1.2.840.113549.1.9.3\",\n              values: [new asn1js.ObjectIdentifier({\n                value: \"1.2.840.113549.1.7.1\"\n              })]\n            })); //endregion\n            //region signingTime\n\n            signedAttr.push(new _Attribute.default({\n              type: \"1.2.840.113549.1.9.5\",\n              values: [new asn1js.UTCTime({\n                valueDate: new Date()\n              })]\n            })); //endregion\n            //region messageDigest\n\n            signedAttr.push(new _Attribute.default({\n              type: \"1.2.840.113549.1.9.4\",\n              values: [new asn1js.OctetString({\n                valueHex: result\n              })]\n            })); //endregion\n            //region Making final value for \"SignerInfo\" type\n\n            cmsSigned.signerInfos.push(new _SignerInfo.default({\n              version: 1,\n              sid: new _IssuerAndSerialNumber.default({\n                issuer: parameters.signingCertificate.issuer,\n                serialNumber: parameters.signingCertificate.serialNumber\n              }),\n              signedAttrs: new _SignedAndUnsignedAttributes.default({\n                type: 0,\n                attributes: signedAttr\n              })\n            })); //endregion\n          }, error => Promise.reject(`Error during making digest for message: ${error}`)); //endregion\n          //endregion\n          //region Signing CMS Signed Data\n\n          sequence = sequence.then(() => cmsSigned.sign(parameters.privateKey, 0, parameters.hashAlgorithm)); //endregion\n          //region Making final CMS_CONTENT_INFO type\n\n          sequence = sequence.then(() => {\n            this.authSafe = new _ContentInfo.default({\n              contentType: \"1.2.840.113549.1.7.2\",\n              content: cmsSigned.toSchema(true)\n            });\n          }, error => Promise.reject(`Error during making signature: ${error}`)); //endregion\n        }\n        break;\n      //endregion\n      //region default\n\n      default:\n        return Promise.reject(`Parameter \"integrityMode\" has unknown value: ${parameters.integrityMode}`);\n      //endregion\n    } //endregion\n\n\n    return sequence;\n  } //**********************************************************************************\n\n\n  parseInternalValues(parameters) {\n    //region Check input data from \"parameters\" \n    if (parameters instanceof Object === false) return Promise.reject(\"The \\\"parameters\\\" must has \\\"Object\\\" type\");\n    if (\"checkIntegrity\" in parameters === false) parameters.checkIntegrity = true; //endregion \n    //region Initial variables \n\n    let sequence = Promise.resolve(); //endregion \n    //region Get a \"crypto\" extension \n\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion \n    //region Create value for \"this.parsedValue.authenticatedSafe\" and check integrity \n\n    this.parsedValue = {};\n\n    switch (this.authSafe.contentType) {\n      //region data \n      case \"1.2.840.113549.1.7.1\":\n        {\n          //region Check additional mandatory parameters\n          if (\"password\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\"\"); //endregion\n          //region Integrity based on HMAC\n\n          this.parsedValue.integrityMode = 0; //endregion\n          //region Check that we do have OCTETSTRING as \"content\"\n\n          if (this.authSafe.content instanceof asn1js.OctetString === false) return Promise.reject(\"Wrong type of \\\"this.authSafe.content\\\"\"); //endregion\n          //region Check we have \"constructive encoding\" for AuthSafe content\n\n          let authSafeContent = new ArrayBuffer(0);\n\n          if (this.authSafe.content.valueBlock.isConstructed) {\n            var _iterator = _createForOfIteratorHelper(this.authSafe.content.valueBlock.value),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                const contentValue = _step.value;\n                authSafeContent = (0, _pvutils.utilConcatBuf)(authSafeContent, contentValue.valueBlock.valueHex);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          } else authSafeContent = this.authSafe.content.valueBlock.valueHex; //endregion\n          //region Parse internal ASN.1 data\n\n\n          const asn1 = asn1js.fromBER(authSafeContent);\n          if (asn1.offset === -1) return Promise.reject(\"Error during parsing of ASN.1 data inside \\\"this.authSafe.content\\\"\"); //endregion\n          //region Set \"authenticatedSafe\" value\n\n          this.parsedValue.authenticatedSafe = new _AuthenticatedSafe.default({\n            schema: asn1.result\n          }); //endregion\n          //region Check integrity\n\n          if (parameters.checkIntegrity) {\n            //region Check that \"MacData\" exists\n            if (\"macData\" in this === false) return Promise.reject(\"Absent \\\"macData\\\" value, can not check PKCS#12 data integrity\"); //endregion\n            //region Initial variables\n\n            const hashAlgorithm = (0, _common.getAlgorithmByOID)(this.macData.mac.digestAlgorithm.algorithmId);\n            if (\"name\" in hashAlgorithm === false) return Promise.reject(`Unsupported digest algorithm: ${this.macData.mac.digestAlgorithm.algorithmId}`); //endregion\n            //region Call current crypto engine for verifying HMAC-based data stamp\n\n            const engine = (0, _common.getEngine)();\n            sequence = sequence.then(() => engine.subtle.verifyDataStampedWithPassword({\n              password: parameters.password,\n              hashAlgorithm: hashAlgorithm.name,\n              salt: this.macData.macSalt.valueBlock.valueHex,\n              iterationCount: this.macData.iterations,\n              contentToVerify: authSafeContent,\n              signatureToVerify: this.macData.mac.digest.valueBlock.valueHex\n            })); //endregion\n            //region Verify HMAC signature\n\n            sequence = sequence.then(result => {\n              if (result === false) return Promise.reject(\"Integrity for the PKCS#12 data is broken!\");\n              return Promise.resolve();\n            }, error => Promise.reject(error)); //endregion\n          } //endregion\n\n        }\n        break;\n      //endregion \n      //region signedData \n\n      case \"1.2.840.113549.1.7.2\":\n        {\n          //region Integrity based on signature using public key\n          this.parsedValue.integrityMode = 1; //endregion\n          //region Parse CMS Signed Data\n\n          const cmsSigned = new _SignedData.default({\n            schema: this.authSafe.content\n          }); //endregion\n          //region Check that we do have OCTETSTRING as \"content\"\n\n          if (\"eContent\" in cmsSigned.encapContentInfo === false) return Promise.reject(\"Absent of attached data in \\\"cmsSigned.encapContentInfo\\\"\");\n          if (cmsSigned.encapContentInfo.eContent instanceof asn1js.OctetString === false) return Promise.reject(\"Wrong type of \\\"cmsSigned.encapContentInfo.eContent\\\"\"); //endregion\n          //region Create correct data block for verification\n\n          let data = new ArrayBuffer(0);\n          if (cmsSigned.encapContentInfo.eContent.idBlock.isConstructed === false) data = cmsSigned.encapContentInfo.eContent.valueBlock.valueHex;else {\n            for (let i = 0; i < cmsSigned.encapContentInfo.eContent.valueBlock.value.length; i++) data = (0, _pvutils.utilConcatBuf)(data, cmsSigned.encapContentInfo.eContent.valueBlock.value[i].valueBlock.valueHex);\n          } //endregion\n          //region Parse internal ASN.1 data\n\n          const asn1 = asn1js.fromBER(data);\n          if (asn1.offset === -1) return Promise.reject(\"Error during parsing of ASN.1 data inside \\\"this.authSafe.content\\\"\"); //endregion\n          //region Set \"authenticatedSafe\" value\n\n          this.parsedValue.authenticatedSafe = new _AuthenticatedSafe.default({\n            schema: asn1.result\n          }); //endregion\n          //region Check integrity\n\n          sequence = sequence.then(() => cmsSigned.verify({\n            signer: 0,\n            checkChain: false\n          })).then(result => {\n            if (result === false) return Promise.reject(\"Integrity for the PKCS#12 data is broken!\");\n            return Promise.resolve();\n          }, error => Promise.reject(`Error during integrity verification: ${error}`)); //endregion\n        }\n        break;\n      //endregion   \n      //region default \n\n      default:\n        return Promise.reject(`Incorrect value for \"this.authSafe.contentType\": ${this.authSafe.contentType}`);\n      //endregion \n    } //endregion \n    //region Return result of the function \n\n\n    return sequence.then(() => this, error => Promise.reject(`Error during parsing: ${error}`)); //endregion   \n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PFX;\n//# sourceMappingURL=PFX.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PFX.js\n// module id = ./node_modules/pkijs/build/PFX.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _EncryptedData = _interopRequireDefault(require(\"./EncryptedData.js\"));\n\nvar _EncryptedContentInfo = _interopRequireDefault(require(\"./EncryptedContentInfo.js\"));\n\nvar _PrivateKeyInfo = _interopRequireDefault(require(\"./PrivateKeyInfo.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC7292\r\n */\nclass PKCS8ShroudedKeyBag {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PKCS8ShroudedKeyBag class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc encryptionAlgorithm\r\n     */\n    this.encryptionAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"encryptionAlgorithm\", PKCS8ShroudedKeyBag.defaultValues(\"encryptionAlgorithm\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc encryptedData\r\n     */\n\n    this.encryptedData = (0, _pvutils.getParametersValue)(parameters, \"encryptedData\", PKCS8ShroudedKeyBag.defaultValues(\"encryptedData\"));\n    if (\"parsedValue\" in parameters)\n      /**\r\n       * @type {*}\r\n       * @desc parsedValue\r\n       */\n      this.parsedValue = (0, _pvutils.getParametersValue)(parameters, \"parsedValue\", PKCS8ShroudedKeyBag.defaultValues(\"parsedValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"encryptionAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"encryptedData\":\n        return new asn1js.OctetString();\n\n      case \"parsedValue\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for PKCS8ShroudedKeyBag class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"encryptionAlgorithm\":\n        return _AlgorithmIdentifier.default.compareWithDefault(\"algorithmId\", memberValue.algorithmId) && \"algorithmParams\" in memberValue === false;\n\n      case \"encryptedData\":\n        return memberValue.isEqual(PKCS8ShroudedKeyBag.defaultValues(memberName));\n\n      case \"parsedValue\":\n        return memberValue instanceof Object && Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for PKCS8ShroudedKeyBag class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PKCS8ShroudedKeyBag ::= EncryptedPrivateKeyInfo\r\n   *\r\n   * EncryptedPrivateKeyInfo ::= SEQUENCE {\r\n   *    encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},\r\n   *    encryptedData EncryptedData\r\n   * }\r\n   *\r\n   * EncryptedData ::= OCTET STRING\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [encryptionAlgorithm]\r\n     * @property {string} [encryptedData]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_AlgorithmIdentifier.default.schema(names.encryptionAlgorithm || {\n        names: {\n          blockName: \"encryptionAlgorithm\"\n        }\n      }), new asn1js.Choice({\n        value: [new asn1js.OctetString({\n          name: names.encryptedData || \"encryptedData\"\n        }), new asn1js.OctetString({\n          idBlock: {\n            isConstructed: true\n          },\n          name: names.encryptedData || \"encryptedData\"\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"encryptionAlgorithm\", \"encryptedData\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PKCS8ShroudedKeyBag.schema({\n      names: {\n        encryptionAlgorithm: {\n          names: {\n            blockName: \"encryptionAlgorithm\"\n          }\n        },\n        encryptedData: \"encryptedData\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PKCS8ShroudedKeyBag\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.encryptionAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.encryptionAlgorithm\n    });\n    this.encryptedData = asn1.result.encryptedData; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.encryptionAlgorithm.toSchema(), this.encryptedData]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      encryptionAlgorithm: this.encryptionAlgorithm.toJSON(),\n      encryptedData: this.encryptedData.toJSON()\n    };\n  } //**********************************************************************************\n\n\n  parseInternalValues(parameters) {\n    //region Initial variables \n    let sequence = Promise.resolve();\n    const cmsEncrypted = new _EncryptedData.default({\n      encryptedContentInfo: new _EncryptedContentInfo.default({\n        contentEncryptionAlgorithm: this.encryptionAlgorithm,\n        encryptedContent: this.encryptedData\n      })\n    }); //endregion \n    //region Decrypt internal data \n\n    sequence = sequence.then(() => cmsEncrypted.decrypt(parameters), error => Promise.reject(error)); //endregion \n    //region Initialize \"parsedValue\" with decrypted PKCS#8 private key \n\n    sequence = sequence.then(\n    /**\r\n     * @param {ArrayBuffer} result\r\n     */\n    result => {\n      const asn1 = asn1js.fromBER(result);\n      if (asn1.offset === -1) return Promise.reject(\"Error during parsing ASN.1 data\");\n      this.parsedValue = new _PrivateKeyInfo.default({\n        schema: asn1.result\n      });\n      return Promise.resolve();\n    }, error => Promise.reject(error)); //endregion \n\n    return sequence;\n  } //**********************************************************************************\n\n\n  makeInternalValues(parameters) {\n    //region Check that we do have \"parsedValue\" \n    if (\"parsedValue\" in this === false) return Promise.reject(\"Please initialize \\\"parsedValue\\\" first\"); //endregion \n    //region Initial variables \n\n    let sequence = Promise.resolve();\n    const cmsEncrypted = new _EncryptedData.default(); //endregion \n    //region Encrypt internal data \n\n    sequence = sequence.then(() => {\n      parameters.contentToEncrypt = this.parsedValue.toSchema().toBER(false);\n      return cmsEncrypted.encrypt(parameters);\n    }, error => Promise.reject(error)); //endregion \n    //region Initialize internal values \n\n    sequence = sequence.then(() => {\n      this.encryptionAlgorithm = cmsEncrypted.encryptedContentInfo.contentEncryptionAlgorithm;\n      this.encryptedData = cmsEncrypted.encryptedContentInfo.encryptedContent;\n    }); //endregion \n\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PKCS8ShroudedKeyBag;\n//# sourceMappingURL=PKCS8ShroudedKeyBag.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PKCS8ShroudedKeyBag.js\n// module id = ./node_modules/pkijs/build/PKCS8ShroudedKeyBag.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass PasswordRecipientinfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PasswordRecipientinfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", PasswordRecipientinfo.defaultValues(\"version\"));\n    if (\"keyDerivationAlgorithm\" in parameters)\n      /**\r\n       * @type {AlgorithmIdentifier}\r\n       * @desc keyDerivationAlgorithm\r\n       */\n      this.keyDerivationAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"keyDerivationAlgorithm\", PasswordRecipientinfo.defaultValues(\"keyDerivationAlgorithm\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc keyEncryptionAlgorithm\r\n     */\n\n    this.keyEncryptionAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"keyEncryptionAlgorithm\", PasswordRecipientinfo.defaultValues(\"keyEncryptionAlgorithm\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc encryptedKey\r\n     */\n\n    this.encryptedKey = (0, _pvutils.getParametersValue)(parameters, \"encryptedKey\", PasswordRecipientinfo.defaultValues(\"encryptedKey\"));\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc password Password to derive key from\r\n     */\n\n    this.password = (0, _pvutils.getParametersValue)(parameters, \"password\", PasswordRecipientinfo.defaultValues(\"password\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return -1;\n\n      case \"keyDerivationAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"keyEncryptionAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"encryptedKey\":\n        return new asn1js.OctetString();\n\n      case \"password\":\n        return new ArrayBuffer(0);\n\n      default:\n        throw new Error(`Invalid member name for PasswordRecipientinfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n        return memberValue === -1;\n\n      case \"keyDerivationAlgorithm\":\n      case \"keyEncryptionAlgorithm\":\n        return memberValue.algorithmId === \"\" && \"algorithmParams\" in memberValue === false;\n\n      case \"encryptedKey\":\n        return memberValue.isEqual(PasswordRecipientinfo.defaultValues(\"encryptedKey\"));\n\n      case \"password\":\n        return memberValue.byteLength === 0;\n\n      default:\n        throw new Error(`Invalid member name for PasswordRecipientinfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PasswordRecipientInfo ::= SEQUENCE {\r\n   *    version CMSVersion,   -- Always set to 0\r\n   *    keyDerivationAlgorithm [0] KeyDerivationAlgorithmIdentifier OPTIONAL,\r\n   *    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,\r\n   *    encryptedKey EncryptedKey }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [keyDerivationAlgorithm]\r\n     * @property {string} [keyEncryptionAlgorithm]\r\n     * @property {string} [encryptedKey]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), new asn1js.Constructed({\n        name: names.keyDerivationAlgorithm || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: _AlgorithmIdentifier.default.schema().valueBlock.value\n      }), _AlgorithmIdentifier.default.schema(names.keyEncryptionAlgorithm || {}), new asn1js.OctetString({\n        name: names.encryptedKey || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"keyDerivationAlgorithm\", \"keyEncryptionAlgorithm\", \"encryptedKey\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PasswordRecipientinfo.schema({\n      names: {\n        version: \"version\",\n        keyDerivationAlgorithm: \"keyDerivationAlgorithm\",\n        keyEncryptionAlgorithm: {\n          names: {\n            blockName: \"keyEncryptionAlgorithm\"\n          }\n        },\n        encryptedKey: \"encryptedKey\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PasswordRecipientinfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n\n    if (\"keyDerivationAlgorithm\" in asn1.result) {\n      this.keyDerivationAlgorithm = new _AlgorithmIdentifier.default({\n        schema: new asn1js.Sequence({\n          value: asn1.result.keyDerivationAlgorithm.valueBlock.value\n        })\n      });\n    }\n\n    this.keyEncryptionAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.keyEncryptionAlgorithm\n    });\n    this.encryptedKey = asn1.result.encryptedKey; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create output array for sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.Integer({\n      value: this.version\n    }));\n\n    if (\"keyDerivationAlgorithm\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: this.keyDerivationAlgorithm.toSchema().valueBlock.value\n      }));\n    }\n\n    outputArray.push(this.keyEncryptionAlgorithm.toSchema());\n    outputArray.push(this.encryptedKey); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      version: this.version,\n      keyDerivationAlgorithm: this.keyDerivationAlgorithm.toJSON(),\n      keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),\n      encryptedKey: this.encryptedKey.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PasswordRecipientinfo;\n//# sourceMappingURL=PasswordRecipientinfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PasswordRecipientinfo.js\n// module id = ./node_modules/pkijs/build/PasswordRecipientinfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass PolicyConstraints {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PolicyConstraints class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    if (\"requireExplicitPolicy\" in parameters)\n      /**\r\n       * @type {number}\r\n       * @desc requireExplicitPolicy\r\n       */\n      this.requireExplicitPolicy = (0, _pvutils.getParametersValue)(parameters, \"requireExplicitPolicy\", PolicyConstraints.defaultValues(\"requireExplicitPolicy\"));\n    if (\"inhibitPolicyMapping\" in parameters)\n      /**\r\n       * @type {number}\r\n       * @desc Value of the TIME class\r\n       */\n      this.inhibitPolicyMapping = (0, _pvutils.getParametersValue)(parameters, \"inhibitPolicyMapping\", PolicyConstraints.defaultValues(\"inhibitPolicyMapping\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"requireExplicitPolicy\":\n        return 0;\n\n      case \"inhibitPolicyMapping\":\n        return 0;\n\n      default:\n        throw new Error(`Invalid member name for PolicyConstraints class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PolicyConstraints ::= SEQUENCE {\r\n   *    requireExplicitPolicy           [0] SkipCerts OPTIONAL,\r\n   *    inhibitPolicyMapping            [1] SkipCerts OPTIONAL }\r\n   *\r\n   * SkipCerts ::= INTEGER (0..MAX)\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [requireExplicitPolicy]\r\n     * @property {string} [inhibitPolicyMapping]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Primitive({\n        name: names.requireExplicitPolicy || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        }\n      }), // IMPLICIT integer value\n      new asn1js.Primitive({\n        name: names.inhibitPolicyMapping || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        }\n      }) // IMPLICIT integer value\n      ]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"requireExplicitPolicy\", \"inhibitPolicyMapping\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PolicyConstraints.schema({\n      names: {\n        requireExplicitPolicy: \"requireExplicitPolicy\",\n        inhibitPolicyMapping: \"inhibitPolicyMapping\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PolicyConstraints\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"requireExplicitPolicy\" in asn1.result) {\n      const field1 = asn1.result.requireExplicitPolicy;\n      field1.idBlock.tagClass = 1; // UNIVERSAL\n\n      field1.idBlock.tagNumber = 2; // INTEGER\n\n      const ber1 = field1.toBER(false);\n      const int1 = asn1js.fromBER(ber1);\n      this.requireExplicitPolicy = int1.result.valueBlock.valueDec;\n    }\n\n    if (\"inhibitPolicyMapping\" in asn1.result) {\n      const field2 = asn1.result.inhibitPolicyMapping;\n      field2.idBlock.tagClass = 1; // UNIVERSAL\n\n      field2.idBlock.tagNumber = 2; // INTEGER\n\n      const ber2 = field2.toBER(false);\n      const int2 = asn1js.fromBER(ber2);\n      this.inhibitPolicyMapping = int2.result.valueBlock.valueDec;\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create correct values for output sequence\n    const outputArray = [];\n\n    if (\"requireExplicitPolicy\" in this) {\n      const int1 = new asn1js.Integer({\n        value: this.requireExplicitPolicy\n      });\n      int1.idBlock.tagClass = 3; // CONTEXT-SPECIFIC\n\n      int1.idBlock.tagNumber = 0; // [0]\n\n      outputArray.push(int1);\n    }\n\n    if (\"inhibitPolicyMapping\" in this) {\n      const int2 = new asn1js.Integer({\n        value: this.inhibitPolicyMapping\n      });\n      int2.idBlock.tagClass = 3; // CONTEXT-SPECIFIC\n\n      int2.idBlock.tagNumber = 1; // [1]\n\n      outputArray.push(int2);\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {};\n    if (\"requireExplicitPolicy\" in this) object.requireExplicitPolicy = this.requireExplicitPolicy;\n    if (\"inhibitPolicyMapping\" in this) object.inhibitPolicyMapping = this.inhibitPolicyMapping;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PolicyConstraints;\n//# sourceMappingURL=PolicyConstraints.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PolicyConstraints.js\n// module id = ./node_modules/pkijs/build/PolicyConstraints.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _PolicyQualifierInfo = _interopRequireDefault(require(\"./PolicyQualifierInfo.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass PolicyInformation {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PolicyInformation class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc policyIdentifier\r\n     */\n    this.policyIdentifier = (0, _pvutils.getParametersValue)(parameters, \"policyIdentifier\", PolicyInformation.defaultValues(\"policyIdentifier\"));\n    if (\"policyQualifiers\" in parameters)\n      /**\r\n       * @type {Array.<PolicyQualifierInfo>}\r\n       * @desc Value of the TIME class\r\n       */\n      this.policyQualifiers = (0, _pvutils.getParametersValue)(parameters, \"policyQualifiers\", PolicyInformation.defaultValues(\"policyQualifiers\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"policyIdentifier\":\n        return \"\";\n\n      case \"policyQualifiers\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for PolicyInformation class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PolicyInformation ::= SEQUENCE {\r\n   *    policyIdentifier   CertPolicyId,\r\n   *    policyQualifiers   SEQUENCE SIZE (1..MAX) OF\r\n   *    PolicyQualifierInfo OPTIONAL }\r\n   *\r\n   * CertPolicyId ::= OBJECT IDENTIFIER\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [policyIdentifier]\r\n     * @property {string} [policyQualifiers]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.policyIdentifier || \"\"\n      }), new asn1js.Sequence({\n        optional: true,\n        value: [new asn1js.Repeated({\n          name: names.policyQualifiers || \"\",\n          value: _PolicyQualifierInfo.default.schema()\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"policyIdentifier\", \"policyQualifiers\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PolicyInformation.schema({\n      names: {\n        policyIdentifier: \"policyIdentifier\",\n        policyQualifiers: \"policyQualifiers\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PolicyInformation\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.policyIdentifier = asn1.result.policyIdentifier.valueBlock.toString();\n    if (\"policyQualifiers\" in asn1.result) this.policyQualifiers = Array.from(asn1.result.policyQualifiers, element => new _PolicyQualifierInfo.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.ObjectIdentifier({\n      value: this.policyIdentifier\n    }));\n\n    if (\"policyQualifiers\" in this) {\n      outputArray.push(new asn1js.Sequence({\n        value: Array.from(this.policyQualifiers, element => element.toSchema())\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      policyIdentifier: this.policyIdentifier\n    };\n    if (\"policyQualifiers\" in this) object.policyQualifiers = Array.from(this.policyQualifiers, element => element.toJSON());\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PolicyInformation;\n//# sourceMappingURL=PolicyInformation.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PolicyInformation.js\n// module id = ./node_modules/pkijs/build/PolicyInformation.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass PolicyMapping {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PolicyMapping class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc issuerDomainPolicy\r\n     */\n    this.issuerDomainPolicy = (0, _pvutils.getParametersValue)(parameters, \"issuerDomainPolicy\", PolicyMapping.defaultValues(\"issuerDomainPolicy\"));\n    /**\r\n     * @type {string}\r\n     * @desc subjectDomainPolicy\r\n     */\n\n    this.subjectDomainPolicy = (0, _pvutils.getParametersValue)(parameters, \"subjectDomainPolicy\", PolicyMapping.defaultValues(\"subjectDomainPolicy\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"issuerDomainPolicy\":\n        return \"\";\n\n      case \"subjectDomainPolicy\":\n        return \"\";\n\n      default:\n        throw new Error(`Invalid member name for PolicyMapping class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PolicyMapping ::= SEQUENCE {\r\n   *    issuerDomainPolicy      CertPolicyId,\r\n   *    subjectDomainPolicy     CertPolicyId }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [issuerDomainPolicy]\r\n     * @property {string} [subjectDomainPolicy]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.issuerDomainPolicy || \"\"\n      }), new asn1js.ObjectIdentifier({\n        name: names.subjectDomainPolicy || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"issuerDomainPolicy\", \"subjectDomainPolicy\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PolicyMapping.schema({\n      names: {\n        issuerDomainPolicy: \"issuerDomainPolicy\",\n        subjectDomainPolicy: \"subjectDomainPolicy\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PolicyMapping\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.issuerDomainPolicy = asn1.result.issuerDomainPolicy.valueBlock.toString();\n    this.subjectDomainPolicy = asn1.result.subjectDomainPolicy.valueBlock.toString(); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.issuerDomainPolicy\n      }), new asn1js.ObjectIdentifier({\n        value: this.subjectDomainPolicy\n      })]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      issuerDomainPolicy: this.issuerDomainPolicy,\n      subjectDomainPolicy: this.subjectDomainPolicy\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PolicyMapping;\n//# sourceMappingURL=PolicyMapping.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PolicyMapping.js\n// module id = ./node_modules/pkijs/build/PolicyMapping.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _PolicyMapping = _interopRequireDefault(require(\"./PolicyMapping.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass PolicyMappings {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PolicyMappings class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<PolicyMapping>}\r\n     * @desc mappings\r\n     */\n    this.mappings = (0, _pvutils.getParametersValue)(parameters, \"mappings\", PolicyMappings.defaultValues(\"mappings\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"mappings\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for PolicyMappings class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF PolicyMapping\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [utcTimeName] Name for \"utcTimeName\" choice\r\n     * @property {string} [generalTimeName] Name for \"generalTimeName\" choice\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.mappings || \"\",\n        value: _PolicyMapping.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"mappings\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PolicyMappings.schema({\n      names: {\n        mappings: \"mappings\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PolicyMappings\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.mappings = Array.from(asn1.result.mappings, element => new _PolicyMapping.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.mappings, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      mappings: Array.from(this.mappings, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PolicyMappings;\n//# sourceMappingURL=PolicyMappings.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PolicyMappings.js\n// module id = ./node_modules/pkijs/build/PolicyMappings.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass PolicyQualifierInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PolicyQualifierInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc policyQualifierId\r\n     */\n    this.policyQualifierId = (0, _pvutils.getParametersValue)(parameters, \"policyQualifierId\", PolicyQualifierInfo.defaultValues(\"policyQualifierId\"));\n    /**\r\n     * @type {Object}\r\n     * @desc qualifier\r\n     */\n\n    this.qualifier = (0, _pvutils.getParametersValue)(parameters, \"qualifier\", PolicyQualifierInfo.defaultValues(\"qualifier\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"policyQualifierId\":\n        return \"\";\n\n      case \"qualifier\":\n        return new asn1js.Any();\n\n      default:\n        throw new Error(`Invalid member name for PolicyQualifierInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PolicyQualifierInfo ::= SEQUENCE {\r\n   *    policyQualifierId  PolicyQualifierId,\r\n   *    qualifier          ANY DEFINED BY policyQualifierId }\r\n   *\r\n   * id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }\r\n   * id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }\r\n   * id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }\r\n   *\r\n   * PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [policyQualifierId]\r\n     * @property {string} [qualifier]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.policyQualifierId || \"\"\n      }), new asn1js.Any({\n        name: names.qualifier || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"policyQualifierId\", \"qualifier\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PolicyQualifierInfo.schema({\n      names: {\n        policyQualifierId: \"policyQualifierId\",\n        qualifier: \"qualifier\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PolicyQualifierInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.policyQualifierId = asn1.result.policyQualifierId.valueBlock.toString();\n    this.qualifier = asn1.result.qualifier; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.policyQualifierId\n      }), this.qualifier]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      policyQualifierId: this.policyQualifierId,\n      qualifier: this.qualifier.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PolicyQualifierInfo;\n//# sourceMappingURL=PolicyQualifierInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PolicyQualifierInfo.js\n// module id = ./node_modules/pkijs/build/PolicyQualifierInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _Attribute = _interopRequireDefault(require(\"./Attribute.js\"));\n\nvar _ECPrivateKey = _interopRequireDefault(require(\"./ECPrivateKey.js\"));\n\nvar _RSAPrivateKey = _interopRequireDefault(require(\"./RSAPrivateKey.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5208\r\n */\nclass PrivateKeyInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PrivateKeyInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", PrivateKeyInfo.defaultValues(\"version\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc privateKeyAlgorithm\r\n     */\n\n    this.privateKeyAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"privateKeyAlgorithm\", PrivateKeyInfo.defaultValues(\"privateKeyAlgorithm\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc privateKey\r\n     */\n\n    this.privateKey = (0, _pvutils.getParametersValue)(parameters, \"privateKey\", PrivateKeyInfo.defaultValues(\"privateKey\"));\n    if (\"attributes\" in parameters)\n      /**\r\n       * @type {Array.<Attribute>}\r\n       * @desc attributes\r\n       */\n      this.attributes = (0, _pvutils.getParametersValue)(parameters, \"attributes\", PrivateKeyInfo.defaultValues(\"attributes\"));\n    if (\"parsedKey\" in parameters)\n      /**\r\n       * @type {ECPrivateKey|RSAPrivateKey}\r\n       * @desc Parsed public key value\r\n       */\n      this.parsedKey = (0, _pvutils.getParametersValue)(parameters, \"parsedKey\", PrivateKeyInfo.defaultValues(\"parsedKey\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n    //region If input argument array contains \"json\" for this object\n\n    if (\"json\" in parameters) this.fromJSON(parameters.json); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"privateKeyAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"privateKey\":\n        return new asn1js.OctetString();\n\n      case \"attributes\":\n        return [];\n\n      case \"parsedKey\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for PrivateKeyInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PrivateKeyInfo ::= SEQUENCE {\r\n   *    version Version,\r\n   *    privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},\r\n   *    privateKey PrivateKey,\r\n   *    attributes [0] Attributes OPTIONAL }\r\n   *\r\n   * Version ::= INTEGER {v1(0)} (v1,...)\r\n   *\r\n   * PrivateKey ::= OCTET STRING\r\n   *\r\n   * Attributes ::= SET OF Attribute\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [privateKeyAlgorithm]\r\n     * @property {string} [privateKey]\r\n     * @property {string} [attributes]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), _AlgorithmIdentifier.default.schema(names.privateKeyAlgorithm || {}), new asn1js.OctetString({\n        name: names.privateKey || \"\"\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Repeated({\n          name: names.attributes || \"\",\n          value: _Attribute.default.schema()\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"privateKeyAlgorithm\", \"privateKey\", \"attributes\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PrivateKeyInfo.schema({\n      names: {\n        version: \"version\",\n        privateKeyAlgorithm: {\n          names: {\n            blockName: \"privateKeyAlgorithm\"\n          }\n        },\n        privateKey: \"privateKey\",\n        attributes: \"attributes\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PrivateKeyInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n    this.privateKeyAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.privateKeyAlgorithm\n    });\n    this.privateKey = asn1.result.privateKey;\n    if (\"attributes\" in asn1.result) this.attributes = Array.from(asn1.result.attributes, element => new _Attribute.default({\n      schema: element\n    }));\n\n    switch (this.privateKeyAlgorithm.algorithmId) {\n      case \"1.2.840.113549.1.1.1\":\n        // RSA\n        {\n          const privateKeyASN1 = asn1js.fromBER(this.privateKey.valueBlock.valueHex);\n          if (privateKeyASN1.offset !== -1) this.parsedKey = new _RSAPrivateKey.default({\n            schema: privateKeyASN1.result\n          });\n        }\n        break;\n\n      case \"1.2.840.10045.2.1\":\n        // ECDSA\n        if (\"algorithmParams\" in this.privateKeyAlgorithm) {\n          if (this.privateKeyAlgorithm.algorithmParams instanceof asn1js.ObjectIdentifier) {\n            const privateKeyASN1 = asn1js.fromBER(this.privateKey.valueBlock.valueHex);\n\n            if (privateKeyASN1.offset !== -1) {\n              this.parsedKey = new _ECPrivateKey.default({\n                namedCurve: this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),\n                schema: privateKeyASN1.result\n              });\n            }\n          }\n        }\n\n        break;\n\n      default:\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [new asn1js.Integer({\n      value: this.version\n    }), this.privateKeyAlgorithm.toSchema(), this.privateKey];\n\n    if (\"attributes\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: Array.from(this.attributes, element => element.toSchema())\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    //region Return common value in case we do not have enough info fo making JWK\n    if (\"parsedKey\" in this === false) {\n      const object = {\n        version: this.version,\n        privateKeyAlgorithm: this.privateKeyAlgorithm.toJSON(),\n        privateKey: this.privateKey.toJSON()\n      };\n      if (\"attributes\" in this) object.attributes = Array.from(this.attributes, element => element.toJSON());\n      return object;\n    } //endregion\n    //region Making JWK\n\n\n    const jwk = {};\n\n    switch (this.privateKeyAlgorithm.algorithmId) {\n      case \"1.2.840.10045.2.1\":\n        // ECDSA\n        jwk.kty = \"EC\";\n        break;\n\n      case \"1.2.840.113549.1.1.1\":\n        // RSA\n        jwk.kty = \"RSA\";\n        break;\n\n      default:\n    }\n\n    const publicKeyJWK = this.parsedKey.toJSON();\n\n    for (var _i = 0, _Object$keys = Object.keys(publicKeyJWK); _i < _Object$keys.length; _i++) {\n      const key = _Object$keys[_i];\n      jwk[key] = publicKeyJWK[key];\n    }\n\n    return jwk; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert JSON value into current object\r\n   * @param {Object} json\r\n   */\n\n\n  fromJSON(json) {\n    if (\"kty\" in json) {\n      switch (json.kty.toUpperCase()) {\n        case \"EC\":\n          this.parsedKey = new _ECPrivateKey.default({\n            json\n          });\n          this.privateKeyAlgorithm = new _AlgorithmIdentifier.default({\n            algorithmId: \"1.2.840.10045.2.1\",\n            algorithmParams: new asn1js.ObjectIdentifier({\n              value: this.parsedKey.namedCurve\n            })\n          });\n          break;\n\n        case \"RSA\":\n          this.parsedKey = new _RSAPrivateKey.default({\n            json\n          });\n          this.privateKeyAlgorithm = new _AlgorithmIdentifier.default({\n            algorithmId: \"1.2.840.113549.1.1.1\",\n            algorithmParams: new asn1js.Null()\n          });\n          break;\n\n        default:\n          throw new Error(`Invalid value for \"kty\" parameter: ${json.kty}`);\n      }\n\n      this.privateKey = new asn1js.OctetString({\n        valueHex: this.parsedKey.toSchema().toBER(false)\n      });\n    }\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PrivateKeyInfo;\n//# sourceMappingURL=PrivateKeyInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PrivateKeyInfo.js\n// module id = ./node_modules/pkijs/build/PrivateKeyInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass PrivateKeyUsagePeriod {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PrivateKeyUsagePeriod class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    if (\"notBefore\" in parameters)\n      /**\r\n       * @type {Date}\r\n       * @desc notBefore\r\n       */\n      this.notBefore = (0, _pvutils.getParametersValue)(parameters, \"notBefore\", PrivateKeyUsagePeriod.defaultValues(\"notBefore\"));\n    if (\"notAfter\" in parameters)\n      /**\r\n       * @type {Date}\r\n       * @desc notAfter\r\n       */\n      this.notAfter = (0, _pvutils.getParametersValue)(parameters, \"notAfter\", PrivateKeyUsagePeriod.defaultValues(\"notAfter\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"notBefore\":\n        return new Date();\n\n      case \"notAfter\":\n        return new Date();\n\n      default:\n        throw new Error(`Invalid member name for PrivateKeyUsagePeriod class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * PrivateKeyUsagePeriod OID ::= 2.5.29.16\r\n   *\r\n   * PrivateKeyUsagePeriod ::= SEQUENCE {\r\n   *    notBefore       [0]     GeneralizedTime OPTIONAL,\r\n   *    notAfter        [1]     GeneralizedTime OPTIONAL }\r\n   * -- either notBefore or notAfter MUST be present\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [notBefore]\r\n     * @property {string} [notAfter]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Primitive({\n        name: names.notBefore || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        }\n      }), new asn1js.Primitive({\n        name: names.notAfter || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        }\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"notBefore\", \"notAfter\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PrivateKeyUsagePeriod.schema({\n      names: {\n        notBefore: \"notBefore\",\n        notAfter: \"notAfter\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PrivateKeyUsagePeriod\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"notBefore\" in asn1.result) {\n      const localNotBefore = new asn1js.GeneralizedTime();\n      localNotBefore.fromBuffer(asn1.result.notBefore.valueBlock.valueHex);\n      this.notBefore = localNotBefore.toDate();\n    }\n\n    if (\"notAfter\" in asn1.result) {\n      const localNotAfter = new asn1js.GeneralizedTime({\n        valueHex: asn1.result.notAfter.valueBlock.valueHex\n      });\n      localNotAfter.fromBuffer(asn1.result.notAfter.valueBlock.valueHex);\n      this.notAfter = localNotAfter.toDate();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    if (\"notBefore\" in this) {\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        valueHex: new asn1js.GeneralizedTime({\n          valueDate: this.notBefore\n        }).valueBlock.valueHex\n      }));\n    }\n\n    if (\"notAfter\" in this) {\n      outputArray.push(new asn1js.Primitive({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        valueHex: new asn1js.GeneralizedTime({\n          valueDate: this.notAfter\n        }).valueBlock.valueHex\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {};\n    if (\"notBefore\" in this) object.notBefore = this.notBefore;\n    if (\"notAfter\" in this) object.notAfter = this.notAfter;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PrivateKeyUsagePeriod;\n//# sourceMappingURL=PrivateKeyUsagePeriod.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PrivateKeyUsagePeriod.js\n// module id = ./node_modules/pkijs/build/PrivateKeyUsagePeriod.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _ECPublicKey = _interopRequireDefault(require(\"./ECPublicKey.js\"));\n\nvar _RSAPublicKey = _interopRequireDefault(require(\"./RSAPublicKey.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass PublicKeyInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for PublicKeyInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc Algorithm identifier\r\n     */\n    this.algorithm = (0, _pvutils.getParametersValue)(parameters, \"algorithm\", PublicKeyInfo.defaultValues(\"algorithm\"));\n    /**\r\n     * @type {BitString}\r\n     * @desc Subject public key value\r\n     */\n\n    this.subjectPublicKey = (0, _pvutils.getParametersValue)(parameters, \"subjectPublicKey\", PublicKeyInfo.defaultValues(\"subjectPublicKey\"));\n    if (\"parsedKey\" in parameters)\n      /**\r\n       * @type {ECPublicKey|RSAPublicKey}\r\n       * @desc Parsed public key value\r\n       */\n      this.parsedKey = (0, _pvutils.getParametersValue)(parameters, \"parsedKey\", PublicKeyInfo.defaultValues(\"parsedKey\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n    //region If input argument array contains \"json\" for this object\n\n    if (\"json\" in parameters) this.fromJSON(parameters.json); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"algorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"subjectPublicKey\":\n        return new asn1js.BitString();\n\n      default:\n        throw new Error(`Invalid member name for PublicKeyInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * SubjectPublicKeyInfo  ::=  Sequence  {\r\n   *    algorithm            AlgorithmIdentifier,\r\n   *    subjectPublicKey     BIT STRING  }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [algorithm]\r\n     * @property {string} [subjectPublicKey]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_AlgorithmIdentifier.default.schema(names.algorithm || {}), new asn1js.BitString({\n        name: names.subjectPublicKey || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"algorithm\", \"subjectPublicKey\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PublicKeyInfo.schema({\n      names: {\n        algorithm: {\n          names: {\n            blockName: \"algorithm\"\n          }\n        },\n        subjectPublicKey: \"subjectPublicKey\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PublicKeyInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.algorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.algorithm\n    });\n    this.subjectPublicKey = asn1.result.subjectPublicKey;\n\n    switch (this.algorithm.algorithmId) {\n      case \"1.2.840.10045.2.1\":\n        // ECDSA\n        if (\"algorithmParams\" in this.algorithm) {\n          if (this.algorithm.algorithmParams.constructor.blockName() === asn1js.ObjectIdentifier.blockName()) {\n            try {\n              this.parsedKey = new _ECPublicKey.default({\n                namedCurve: this.algorithm.algorithmParams.valueBlock.toString(),\n                schema: this.subjectPublicKey.valueBlock.valueHex\n              });\n            } catch (ex) {} // Could be a problems during recognision of internal public key data here. Let's ignore them.\n\n          }\n        }\n\n        break;\n\n      case \"1.2.840.113549.1.1.1\":\n        // RSA\n        {\n          const publicKeyASN1 = asn1js.fromBER(this.subjectPublicKey.valueBlock.valueHex);\n\n          if (publicKeyASN1.offset !== -1) {\n            try {\n              this.parsedKey = new _RSAPublicKey.default({\n                schema: publicKeyASN1.result\n              });\n            } catch (ex) {} // Could be a problems during recognision of internal public key data here. Let's ignore them.\n\n          }\n        }\n        break;\n\n      default:\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.algorithm.toSchema(), this.subjectPublicKey]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    //region Return common value in case we do not have enough info fo making JWK\n    if (\"parsedKey\" in this === false) {\n      return {\n        algorithm: this.algorithm.toJSON(),\n        subjectPublicKey: this.subjectPublicKey.toJSON()\n      };\n    } //endregion\n    //region Making JWK\n\n\n    const jwk = {};\n\n    switch (this.algorithm.algorithmId) {\n      case \"1.2.840.10045.2.1\":\n        // ECDSA\n        jwk.kty = \"EC\";\n        break;\n\n      case \"1.2.840.113549.1.1.1\":\n        // RSA\n        jwk.kty = \"RSA\";\n        break;\n\n      default:\n    }\n\n    const publicKeyJWK = this.parsedKey.toJSON();\n\n    for (var _i = 0, _Object$keys = Object.keys(publicKeyJWK); _i < _Object$keys.length; _i++) {\n      const key = _Object$keys[_i];\n      jwk[key] = publicKeyJWK[key];\n    }\n\n    return jwk; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert JSON value into current object\r\n   * @param {Object} json\r\n   */\n\n\n  fromJSON(json) {\n    if (\"kty\" in json) {\n      switch (json.kty.toUpperCase()) {\n        case \"EC\":\n          this.parsedKey = new _ECPublicKey.default({\n            json\n          });\n          this.algorithm = new _AlgorithmIdentifier.default({\n            algorithmId: \"1.2.840.10045.2.1\",\n            algorithmParams: new asn1js.ObjectIdentifier({\n              value: this.parsedKey.namedCurve\n            })\n          });\n          break;\n\n        case \"RSA\":\n          this.parsedKey = new _RSAPublicKey.default({\n            json\n          });\n          this.algorithm = new _AlgorithmIdentifier.default({\n            algorithmId: \"1.2.840.113549.1.1.1\",\n            algorithmParams: new asn1js.Null()\n          });\n          break;\n\n        default:\n          throw new Error(`Invalid value for \"kty\" parameter: ${json.kty}`);\n      }\n\n      this.subjectPublicKey = new asn1js.BitString({\n        valueHex: this.parsedKey.toSchema().toBER(false)\n      });\n    }\n  } //**********************************************************************************\n\n\n  importKey(publicKey) {\n    //region Initial variables\n    let sequence = Promise.resolve();\n\n    const _this = this; //endregion\n    //region Initial check\n\n\n    if (typeof publicKey === \"undefined\") return Promise.reject(\"Need to provide publicKey input parameter\"); //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Export public key\n\n    sequence = sequence.then(() => crypto.exportKey(\"spki\", publicKey)); //endregion\n    //region Initialize internal variables by parsing exported value\n\n    sequence = sequence.then(\n    /**\r\n     * @param {ArrayBuffer} exportedKey\r\n     */\n    exportedKey => {\n      const asn1 = asn1js.fromBER(exportedKey);\n\n      try {\n        _this.fromSchema(asn1.result);\n      } catch (exception) {\n        return Promise.reject(\"Error during initializing object from schema\");\n      }\n\n      return undefined;\n    }, error => Promise.reject(`Error during exporting public key: ${error}`)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = PublicKeyInfo;\n//# sourceMappingURL=PublicKeyInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/PublicKeyInfo.js\n// module id = ./node_modules/pkijs/build/PublicKeyInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.QCStatement = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC3739\r\n */\nclass QCStatement {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for QCStatement class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     */\n    this.id = (0, _pvutils.getParametersValue)(parameters, \"id\", QCStatement.defaultValues(\"id\"));\n\n    if (\"type\" in parameters) {\n      /**\r\n       * @type {*} Any data described by \"id\"\r\n       */\n      this.type = (0, _pvutils.getParametersValue)(parameters, \"type\", QCStatement.defaultValues(\"type\"));\n    } //endregion\n    //region If input argument array contains \"schema\" for this object\n\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"id\":\n        return \"\";\n\n      case \"type\":\n        return new asn1js.Null();\n\n      default:\n        throw new Error(`Invalid member name for QCStatement class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"id\":\n        return memberValue === \"\";\n\n      case \"type\":\n        return memberValue instanceof asn1js.Null;\n\n      default:\n        throw new Error(`Invalid member name for QCStatement class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n  \t *\t QCStatement ::= SEQUENCE {\r\n   *       statementId   QC-STATEMENT.&id({SupportedStatements}),\r\n   *       statementInfo QC-STATEMENT.&Type({SupportedStatements}{@statementId}) OPTIONAL\r\n   *   }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [id]\r\n     * @property {string} [type]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.id || \"\"\n      }), new asn1js.Any({\n        name: names.type || \"\",\n        optional: true\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"id\", \"type\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, QCStatement.schema({\n      names: {\n        id: \"id\",\n        type: \"type\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for QCStatement\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.id = asn1.result.id.valueBlock.toString();\n    if (\"type\" in asn1.result) this.type = asn1.result.type; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    const value = [new asn1js.ObjectIdentifier({\n      value: this.id\n    })];\n    if (\"type\" in this) value.push(this.type); //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      id: this.id\n    };\n    if (\"type\" in this) object.type = this.type.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * Class from RFC3739\r\n */\n\n\nexports.QCStatement = QCStatement;\n\nclass QCStatements {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for QCStatements class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array<QCStatement>}\r\n     */\n    this.values = (0, _pvutils.getParametersValue)(parameters, \"values\", QCStatements.defaultValues(\"values\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"values\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for QCStatements class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"values\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for QCStatements class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * QCStatements ::= SEQUENCE OF QCStatement\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [values]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.values || \"\",\n        value: QCStatement.schema(names.value || {})\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"values\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, QCStatements.schema({\n      names: {\n        values: \"values\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for QCStatements\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.values = Array.from(asn1.result.values, element => new QCStatement({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.values, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      extensions: Array.from(this.values, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = QCStatements;\n//# sourceMappingURL=QCStatements.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/QCStatements.js\n// module id = ./node_modules/pkijs/build/QCStatements.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC3447\r\n */\nclass RSAESOAEPParams {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RSAESOAEPParams class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc hashAlgorithm\r\n     */\n    this.hashAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"hashAlgorithm\", RSAESOAEPParams.defaultValues(\"hashAlgorithm\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc maskGenAlgorithm\r\n     */\n\n    this.maskGenAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"maskGenAlgorithm\", RSAESOAEPParams.defaultValues(\"maskGenAlgorithm\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc pSourceAlgorithm\r\n     */\n\n    this.pSourceAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"pSourceAlgorithm\", RSAESOAEPParams.defaultValues(\"pSourceAlgorithm\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"hashAlgorithm\":\n        return new _AlgorithmIdentifier.default({\n          algorithmId: \"1.3.14.3.2.26\",\n          // SHA-1\n          algorithmParams: new asn1js.Null()\n        });\n\n      case \"maskGenAlgorithm\":\n        return new _AlgorithmIdentifier.default({\n          algorithmId: \"1.2.840.113549.1.1.8\",\n          // MGF1\n          algorithmParams: new _AlgorithmIdentifier.default({\n            algorithmId: \"1.3.14.3.2.26\",\n            // SHA-1\n            algorithmParams: new asn1js.Null()\n          }).toSchema()\n        });\n\n      case \"pSourceAlgorithm\":\n        return new _AlgorithmIdentifier.default({\n          algorithmId: \"1.2.840.113549.1.1.9\",\n          // id-pSpecified\n          algorithmParams: new asn1js.OctetString({\n            valueHex: new Uint8Array([0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90, 0xaf, 0xd8, 0x07, 0x09]).buffer\n          }) // SHA-1 hash of empty string\n\n        });\n\n      default:\n        throw new Error(`Invalid member name for RSAESOAEPParams class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RSAES-OAEP-params ::= SEQUENCE {\r\n   *    hashAlgorithm     [0] HashAlgorithm    DEFAULT sha1,\r\n   *    maskGenAlgorithm  [1] MaskGenAlgorithm DEFAULT mgf1SHA1,\r\n   *    pSourceAlgorithm  [2] PSourceAlgorithm DEFAULT pSpecifiedEmpty\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [hashAlgorithm]\r\n     * @property {string} [maskGenAlgorithm]\r\n     * @property {string} [pSourceAlgorithm]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        optional: true,\n        value: [_AlgorithmIdentifier.default.schema(names.hashAlgorithm || {})]\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        optional: true,\n        value: [_AlgorithmIdentifier.default.schema(names.maskGenAlgorithm || {})]\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        optional: true,\n        value: [_AlgorithmIdentifier.default.schema(names.pSourceAlgorithm || {})]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"hashAlgorithm\", \"maskGenAlgorithm\", \"pSourceAlgorithm\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RSAESOAEPParams.schema({\n      names: {\n        hashAlgorithm: {\n          names: {\n            blockName: \"hashAlgorithm\"\n          }\n        },\n        maskGenAlgorithm: {\n          names: {\n            blockName: \"maskGenAlgorithm\"\n          }\n        },\n        pSourceAlgorithm: {\n          names: {\n            blockName: \"pSourceAlgorithm\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RSAESOAEPParams\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"hashAlgorithm\" in asn1.result) this.hashAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.hashAlgorithm\n    });\n    if (\"maskGenAlgorithm\" in asn1.result) this.maskGenAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.maskGenAlgorithm\n    });\n    if (\"pSourceAlgorithm\" in asn1.result) this.pSourceAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.pSourceAlgorithm\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    if (!this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues(\"hashAlgorithm\"))) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [this.hashAlgorithm.toSchema()]\n      }));\n    }\n\n    if (!this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues(\"maskGenAlgorithm\"))) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [this.maskGenAlgorithm.toSchema()]\n      }));\n    }\n\n    if (!this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues(\"pSourceAlgorithm\"))) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        value: [this.pSourceAlgorithm.toSchema()]\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {};\n    if (!this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues(\"hashAlgorithm\"))) object.hashAlgorithm = this.hashAlgorithm.toJSON();\n    if (!this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues(\"maskGenAlgorithm\"))) object.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();\n    if (!this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues(\"pSourceAlgorithm\"))) object.pSourceAlgorithm = this.pSourceAlgorithm.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RSAESOAEPParams;\n//# sourceMappingURL=RSAESOAEPParams.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RSAESOAEPParams.js\n// module id = ./node_modules/pkijs/build/RSAESOAEPParams.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _OtherPrimeInfo = _interopRequireDefault(require(\"./OtherPrimeInfo.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC3447\r\n */\nclass RSAPrivateKey {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RSAPrivateKey class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", RSAPrivateKey.defaultValues(\"version\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc modulus\r\n     */\n\n    this.modulus = (0, _pvutils.getParametersValue)(parameters, \"modulus\", RSAPrivateKey.defaultValues(\"modulus\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc publicExponent\r\n     */\n\n    this.publicExponent = (0, _pvutils.getParametersValue)(parameters, \"publicExponent\", RSAPrivateKey.defaultValues(\"publicExponent\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc privateExponent\r\n     */\n\n    this.privateExponent = (0, _pvutils.getParametersValue)(parameters, \"privateExponent\", RSAPrivateKey.defaultValues(\"privateExponent\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc prime1\r\n     */\n\n    this.prime1 = (0, _pvutils.getParametersValue)(parameters, \"prime1\", RSAPrivateKey.defaultValues(\"prime1\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc prime2\r\n     */\n\n    this.prime2 = (0, _pvutils.getParametersValue)(parameters, \"prime2\", RSAPrivateKey.defaultValues(\"prime2\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc exponent1\r\n     */\n\n    this.exponent1 = (0, _pvutils.getParametersValue)(parameters, \"exponent1\", RSAPrivateKey.defaultValues(\"exponent1\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc exponent2\r\n     */\n\n    this.exponent2 = (0, _pvutils.getParametersValue)(parameters, \"exponent2\", RSAPrivateKey.defaultValues(\"exponent2\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc coefficient\r\n     */\n\n    this.coefficient = (0, _pvutils.getParametersValue)(parameters, \"coefficient\", RSAPrivateKey.defaultValues(\"coefficient\"));\n    if (\"otherPrimeInfos\" in parameters)\n      /**\r\n       * @type {Array.<OtherPrimeInfo>}\r\n       * @desc otherPrimeInfos\r\n       */\n      this.otherPrimeInfos = (0, _pvutils.getParametersValue)(parameters, \"otherPrimeInfos\", RSAPrivateKey.defaultValues(\"otherPrimeInfos\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n    //region If input argument array contains \"json\" for this object\n\n    if (\"json\" in parameters) this.fromJSON(parameters.json); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"modulus\":\n        return new asn1js.Integer();\n\n      case \"publicExponent\":\n        return new asn1js.Integer();\n\n      case \"privateExponent\":\n        return new asn1js.Integer();\n\n      case \"prime1\":\n        return new asn1js.Integer();\n\n      case \"prime2\":\n        return new asn1js.Integer();\n\n      case \"exponent1\":\n        return new asn1js.Integer();\n\n      case \"exponent2\":\n        return new asn1js.Integer();\n\n      case \"coefficient\":\n        return new asn1js.Integer();\n\n      case \"otherPrimeInfos\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for RSAPrivateKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RSAPrivateKey ::= Sequence {\r\n   *    version           Version,\r\n   *    modulus           Integer,  -- n\r\n   *    publicExponent    Integer,  -- e\r\n   *    privateExponent   Integer,  -- d\r\n   *    prime1            Integer,  -- p\r\n   *    prime2            Integer,  -- q\r\n   *    exponent1         Integer,  -- d mod (p-1)\r\n   *    exponent2         Integer,  -- d mod (q-1)\r\n   *    coefficient       Integer,  -- (inverse of q) mod p\r\n   *    otherPrimeInfos   OtherPrimeInfos OPTIONAL\r\n   * }\r\n   *\r\n   * OtherPrimeInfos ::= Sequence SIZE(1..MAX) OF OtherPrimeInfo\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [modulus]\r\n     * @property {string} [publicExponent]\r\n     * @property {string} [privateExponent]\r\n     * @property {string} [prime1]\r\n     * @property {string} [prime2]\r\n     * @property {string} [exponent1]\r\n     * @property {string} [exponent2]\r\n     * @property {string} [coefficient]\r\n     * @property {string} [otherPrimeInfosName]\r\n     * @property {Object} [otherPrimeInfo]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), new asn1js.Integer({\n        name: names.modulus || \"\"\n      }), new asn1js.Integer({\n        name: names.publicExponent || \"\"\n      }), new asn1js.Integer({\n        name: names.privateExponent || \"\"\n      }), new asn1js.Integer({\n        name: names.prime1 || \"\"\n      }), new asn1js.Integer({\n        name: names.prime2 || \"\"\n      }), new asn1js.Integer({\n        name: names.exponent1 || \"\"\n      }), new asn1js.Integer({\n        name: names.exponent2 || \"\"\n      }), new asn1js.Integer({\n        name: names.coefficient || \"\"\n      }), new asn1js.Sequence({\n        optional: true,\n        value: [new asn1js.Repeated({\n          name: names.otherPrimeInfosName || \"\",\n          value: _OtherPrimeInfo.default.schema(names.otherPrimeInfo || {})\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"version\", \"modulus\", \"publicExponent\", \"privateExponent\", \"prime1\", \"prime2\", \"exponent1\", \"exponent2\", \"coefficient\", \"otherPrimeInfos\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RSAPrivateKey.schema({\n      names: {\n        version: \"version\",\n        modulus: \"modulus\",\n        publicExponent: \"publicExponent\",\n        privateExponent: \"privateExponent\",\n        prime1: \"prime1\",\n        prime2: \"prime2\",\n        exponent1: \"exponent1\",\n        exponent2: \"exponent2\",\n        coefficient: \"coefficient\",\n        otherPrimeInfo: {\n          names: {\n            blockName: \"otherPrimeInfos\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RSAPrivateKey\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n    this.modulus = asn1.result.modulus.convertFromDER(256);\n    this.publicExponent = asn1.result.publicExponent;\n    this.privateExponent = asn1.result.privateExponent.convertFromDER(256);\n    this.prime1 = asn1.result.prime1.convertFromDER(128);\n    this.prime2 = asn1.result.prime2.convertFromDER(128);\n    this.exponent1 = asn1.result.exponent1.convertFromDER(128);\n    this.exponent2 = asn1.result.exponent2.convertFromDER(128);\n    this.coefficient = asn1.result.coefficient.convertFromDER(128);\n    if (\"otherPrimeInfos\" in asn1.result) this.otherPrimeInfos = Array.from(asn1.result.otherPrimeInfos, element => new _OtherPrimeInfo.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.Integer({\n      value: this.version\n    }));\n    outputArray.push(this.modulus.convertToDER());\n    outputArray.push(this.publicExponent);\n    outputArray.push(this.privateExponent.convertToDER());\n    outputArray.push(this.prime1.convertToDER());\n    outputArray.push(this.prime2.convertToDER());\n    outputArray.push(this.exponent1.convertToDER());\n    outputArray.push(this.exponent2.convertToDER());\n    outputArray.push(this.coefficient.convertToDER());\n\n    if (\"otherPrimeInfos\" in this) {\n      outputArray.push(new asn1js.Sequence({\n        value: Array.from(this.otherPrimeInfos, element => element.toSchema())\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const jwk = {\n      n: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.modulus.valueBlock.valueHex), true, true, true),\n      e: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.publicExponent.valueBlock.valueHex), true, true, true),\n      d: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.privateExponent.valueBlock.valueHex), true, true, true),\n      p: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.prime1.valueBlock.valueHex), true, true, true),\n      q: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.prime2.valueBlock.valueHex), true, true, true),\n      dp: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.exponent1.valueBlock.valueHex), true, true, true),\n      dq: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.exponent2.valueBlock.valueHex), true, true, true),\n      qi: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.coefficient.valueBlock.valueHex), true, true, true)\n    };\n    if (\"otherPrimeInfos\" in this) jwk.oth = Array.from(this.otherPrimeInfos, element => element.toJSON());\n    return jwk;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert JSON value into current object\r\n   * @param {Object} json\r\n   */\n\n\n  fromJSON(json) {\n    if (\"n\" in json) this.modulus = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.n, true, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"n\\\"\");\n    if (\"e\" in json) this.publicExponent = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.e, true, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"e\\\"\");\n    if (\"d\" in json) this.privateExponent = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.d, true, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"d\\\"\");\n    if (\"p\" in json) this.prime1 = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.p, true, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"p\\\"\");\n    if (\"q\" in json) this.prime2 = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.q, true, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"q\\\"\");\n    if (\"dp\" in json) this.exponent1 = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.dp, true, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"dp\\\"\");\n    if (\"dq\" in json) this.exponent2 = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.dq, true, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"dq\\\"\");\n    if (\"qi\" in json) this.coefficient = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.qi, true, true))\n    });else throw new Error(\"Absent mandatory parameter \\\"qi\\\"\");\n    if (\"oth\" in json) this.otherPrimeInfos = Array.from(json.oth, element => new _OtherPrimeInfo.default({\n      json: element\n    }));\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RSAPrivateKey;\n//# sourceMappingURL=RSAPrivateKey.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RSAPrivateKey.js\n// module id = ./node_modules/pkijs/build/RSAPrivateKey.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC3447\r\n */\nclass RSAPublicKey {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RSAPublicKey class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   * @property {Integer} [modulus]\r\n   * @property {Integer} [publicExponent]\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Integer}\r\n     * @desc Modulus part of RSA public key\r\n     */\n    this.modulus = (0, _pvutils.getParametersValue)(parameters, \"modulus\", RSAPublicKey.defaultValues(\"modulus\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc Public exponent of RSA public key\r\n     */\n\n    this.publicExponent = (0, _pvutils.getParametersValue)(parameters, \"publicExponent\", RSAPublicKey.defaultValues(\"publicExponent\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n    //region If input argument array contains \"json\" for this object\n\n    if (\"json\" in parameters) this.fromJSON(parameters.json); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"modulus\":\n        return new asn1js.Integer();\n\n      case \"publicExponent\":\n        return new asn1js.Integer();\n\n      default:\n        throw new Error(`Invalid member name for RSAPublicKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RSAPublicKey ::= Sequence {\r\n   *    modulus           Integer,  -- n\r\n   *    publicExponent    Integer   -- e\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} utcTimeName Name for \"utcTimeName\" choice\r\n     * @property {string} generalTimeName Name for \"generalTimeName\" choice\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.modulus || \"\"\n      }), new asn1js.Integer({\n        name: names.publicExponent || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"modulus\", \"publicExponent\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RSAPublicKey.schema({\n      names: {\n        modulus: \"modulus\",\n        publicExponent: \"publicExponent\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RSAPublicKey\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.modulus = asn1.result.modulus.convertFromDER(256);\n    this.publicExponent = asn1.result.publicExponent; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.modulus.convertToDER(), this.publicExponent]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      n: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.modulus.valueBlock.valueHex), true, true, true),\n      e: (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(this.publicExponent.valueBlock.valueHex), true, true, true)\n    };\n  } //**********************************************************************************\n\n  /**\r\n   * Convert JSON value into current object\r\n   * @param {Object} json\r\n   */\n\n\n  fromJSON(json) {\n    if (\"n\" in json) {\n      const array = (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.n, true));\n      this.modulus = new asn1js.Integer({\n        valueHex: array.slice(0, Math.pow(2, (0, _pvutils.nearestPowerOf2)(array.byteLength)))\n      });\n    } else throw new Error(\"Absent mandatory parameter \\\"n\\\"\");\n\n    if (\"e\" in json) this.publicExponent = new asn1js.Integer({\n      valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(json.e, true)).slice(0, 3)\n    });else throw new Error(\"Absent mandatory parameter \\\"e\\\"\");\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RSAPublicKey;\n//# sourceMappingURL=RSAPublicKey.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RSAPublicKey.js\n// module id = ./node_modules/pkijs/build/RSAPublicKey.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC4055\r\n */\nclass RSASSAPSSParams {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RSASSAPSSParams class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc Algorithms of hashing (DEFAULT sha1)\r\n     */\n    this.hashAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"hashAlgorithm\", RSASSAPSSParams.defaultValues(\"hashAlgorithm\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc Algorithm of \"mask generaion function (MGF)\" (DEFAULT mgf1SHA1)\r\n     */\n\n    this.maskGenAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"maskGenAlgorithm\", RSASSAPSSParams.defaultValues(\"maskGenAlgorithm\"));\n    /**\r\n     * @type {number}\r\n     * @desc Salt length (DEFAULT 20)\r\n     */\n\n    this.saltLength = (0, _pvutils.getParametersValue)(parameters, \"saltLength\", RSASSAPSSParams.defaultValues(\"saltLength\"));\n    /**\r\n     * @type {number}\r\n     * @desc (DEFAULT 1)\r\n     */\n\n    this.trailerField = (0, _pvutils.getParametersValue)(parameters, \"trailerField\", RSASSAPSSParams.defaultValues(\"trailerField\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"hashAlgorithm\":\n        return new _AlgorithmIdentifier.default({\n          algorithmId: \"1.3.14.3.2.26\",\n          // SHA-1\n          algorithmParams: new asn1js.Null()\n        });\n\n      case \"maskGenAlgorithm\":\n        return new _AlgorithmIdentifier.default({\n          algorithmId: \"1.2.840.113549.1.1.8\",\n          // MGF1\n          algorithmParams: new _AlgorithmIdentifier.default({\n            algorithmId: \"1.3.14.3.2.26\",\n            // SHA-1\n            algorithmParams: new asn1js.Null()\n          }).toSchema()\n        });\n\n      case \"saltLength\":\n        return 20;\n\n      case \"trailerField\":\n        return 1;\n\n      default:\n        throw new Error(`Invalid member name for RSASSAPSSParams class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RSASSA-PSS-params  ::=  Sequence  {\r\n   *    hashAlgorithm      [0] HashAlgorithm DEFAULT sha1Identifier,\r\n   *    maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT mgf1SHA1Identifier,\r\n   *    saltLength         [2] Integer DEFAULT 20,\r\n   *    trailerField       [3] Integer DEFAULT 1  }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [hashAlgorithm]\r\n     * @property {string} [maskGenAlgorithm]\r\n     * @property {string} [saltLength]\r\n     * @property {string} [trailerField]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        optional: true,\n        value: [_AlgorithmIdentifier.default.schema(names.hashAlgorithm || {})]\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        optional: true,\n        value: [_AlgorithmIdentifier.default.schema(names.maskGenAlgorithm || {})]\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        optional: true,\n        value: [new asn1js.Integer({\n          name: names.saltLength || \"\"\n        })]\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 3 // [3]\n\n        },\n        optional: true,\n        value: [new asn1js.Integer({\n          name: names.trailerField || \"\"\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"hashAlgorithm\", \"maskGenAlgorithm\", \"saltLength\", \"trailerField\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RSASSAPSSParams.schema({\n      names: {\n        hashAlgorithm: {\n          names: {\n            blockName: \"hashAlgorithm\"\n          }\n        },\n        maskGenAlgorithm: {\n          names: {\n            blockName: \"maskGenAlgorithm\"\n          }\n        },\n        saltLength: \"saltLength\",\n        trailerField: \"trailerField\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RSASSAPSSParams\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"hashAlgorithm\" in asn1.result) this.hashAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.hashAlgorithm\n    });\n    if (\"maskGenAlgorithm\" in asn1.result) this.maskGenAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result.maskGenAlgorithm\n    });\n    if (\"saltLength\" in asn1.result) this.saltLength = asn1.result.saltLength.valueBlock.valueDec;\n    if (\"trailerField\" in asn1.result) this.trailerField = asn1.result.trailerField.valueBlock.valueDec; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    if (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(\"hashAlgorithm\"))) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [this.hashAlgorithm.toSchema()]\n      }));\n    }\n\n    if (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(\"maskGenAlgorithm\"))) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [this.maskGenAlgorithm.toSchema()]\n      }));\n    }\n\n    if (this.saltLength !== RSASSAPSSParams.defaultValues(\"saltLength\")) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        value: [new asn1js.Integer({\n          value: this.saltLength\n        })]\n      }));\n    }\n\n    if (this.trailerField !== RSASSAPSSParams.defaultValues(\"trailerField\")) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 3 // [3]\n\n        },\n        value: [new asn1js.Integer({\n          value: this.trailerField\n        })]\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {};\n    if (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(\"hashAlgorithm\"))) object.hashAlgorithm = this.hashAlgorithm.toJSON();\n    if (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(\"maskGenAlgorithm\"))) object.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();\n    if (this.saltLength !== RSASSAPSSParams.defaultValues(\"saltLength\")) object.saltLength = this.saltLength;\n    if (this.trailerField !== RSASSAPSSParams.defaultValues(\"trailerField\")) object.trailerField = this.trailerField;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RSASSAPSSParams;\n//# sourceMappingURL=RSASSAPSSParams.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RSASSAPSSParams.js\n// module id = ./node_modules/pkijs/build/RSASSAPSSParams.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _KeyAgreeRecipientIdentifier = _interopRequireDefault(require(\"./KeyAgreeRecipientIdentifier.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass RecipientEncryptedKey {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RecipientEncryptedKey class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {KeyAgreeRecipientIdentifier}\r\n     * @desc rid\r\n     */\n    this.rid = (0, _pvutils.getParametersValue)(parameters, \"rid\", RecipientEncryptedKey.defaultValues(\"rid\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc encryptedKey\r\n     */\n\n    this.encryptedKey = (0, _pvutils.getParametersValue)(parameters, \"encryptedKey\", RecipientEncryptedKey.defaultValues(\"encryptedKey\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"rid\":\n        return new _KeyAgreeRecipientIdentifier.default();\n\n      case \"encryptedKey\":\n        return new asn1js.OctetString();\n\n      default:\n        throw new Error(`Invalid member name for RecipientEncryptedKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"rid\":\n        return memberValue.variant === -1 && \"value\" in memberValue === false;\n\n      case \"encryptedKey\":\n        return memberValue.isEqual(RecipientEncryptedKey.defaultValues(\"encryptedKey\"));\n\n      default:\n        throw new Error(`Invalid member name for RecipientEncryptedKey class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RecipientEncryptedKey ::= SEQUENCE {\r\n   *    rid KeyAgreeRecipientIdentifier,\r\n   *    encryptedKey EncryptedKey }\r\n   *\r\n   * EncryptedKey ::= OCTET STRING\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [rid]\r\n     * @property {string} [encryptedKey]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_KeyAgreeRecipientIdentifier.default.schema(names.rid || {}), new asn1js.OctetString({\n        name: names.encryptedKey || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"rid\", \"encryptedKey\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RecipientEncryptedKey.schema({\n      names: {\n        rid: {\n          names: {\n            blockName: \"rid\"\n          }\n        },\n        encryptedKey: \"encryptedKey\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RecipientEncryptedKey\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.rid = new _KeyAgreeRecipientIdentifier.default({\n      schema: asn1.result.rid\n    });\n    this.encryptedKey = asn1.result.encryptedKey; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.rid.toSchema(), this.encryptedKey]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      rid: this.rid.toJSON(),\n      encryptedKey: this.encryptedKey.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RecipientEncryptedKey;\n//# sourceMappingURL=RecipientEncryptedKey.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RecipientEncryptedKey.js\n// module id = ./node_modules/pkijs/build/RecipientEncryptedKey.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _RecipientEncryptedKey = _interopRequireDefault(require(\"./RecipientEncryptedKey.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass RecipientEncryptedKeys {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RecipientEncryptedKeys class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<RecipientEncryptedKey>}\r\n     * @desc encryptedKeys\r\n     */\n    this.encryptedKeys = (0, _pvutils.getParametersValue)(parameters, \"encryptedKeys\", RecipientEncryptedKeys.defaultValues(\"encryptedKeys\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"encryptedKeys\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for RecipientEncryptedKeys class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"encryptedKeys\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for RecipientEncryptedKeys class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RecipientEncryptedKeys ::= SEQUENCE OF RecipientEncryptedKey\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [RecipientEncryptedKeys]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.RecipientEncryptedKeys || \"\",\n        value: _RecipientEncryptedKey.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"RecipientEncryptedKeys\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RecipientEncryptedKeys.schema({\n      names: {\n        RecipientEncryptedKeys: \"RecipientEncryptedKeys\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RecipientEncryptedKeys\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.encryptedKeys = Array.from(asn1.result.RecipientEncryptedKeys, element => new _RecipientEncryptedKey.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.encryptedKeys, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      encryptedKeys: Array.from(this.encryptedKeys, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RecipientEncryptedKeys;\n//# sourceMappingURL=RecipientEncryptedKeys.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RecipientEncryptedKeys.js\n// module id = ./node_modules/pkijs/build/RecipientEncryptedKeys.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _IssuerAndSerialNumber = _interopRequireDefault(require(\"./IssuerAndSerialNumber.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass RecipientIdentifier {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RecipientIdentifier class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc variant\r\n     */\n    this.variant = (0, _pvutils.getParametersValue)(parameters, \"variant\", RecipientIdentifier.defaultValues(\"variant\"));\n    if (\"value\" in parameters)\n      /**\r\n       * @type {*}\r\n       * @desc value\r\n       */\n      this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", RecipientIdentifier.defaultValues(\"value\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"variant\":\n        return -1;\n\n      case \"value\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for RecipientIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"variant\":\n        return memberValue === -1;\n\n      case \"values\":\n        return Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for RecipientIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RecipientIdentifier ::= CHOICE {\r\n   *    issuerAndSerialNumber IssuerAndSerialNumber,\r\n   *    subjectKeyIdentifier [0] SubjectKeyIdentifier }\r\n   *\r\n   * SubjectKeyIdentifier ::= OCTET STRING\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Choice({\n      value: [_IssuerAndSerialNumber.default.schema({\n        names: {\n          blockName: names.blockName || \"\"\n        }\n      }), new asn1js.Primitive({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        }\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"blockName\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RecipientIdentifier.schema({\n      names: {\n        blockName: \"blockName\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RecipientIdentifier\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (asn1.result.blockName.idBlock.tagClass === 1) {\n      this.variant = 1;\n      this.value = new _IssuerAndSerialNumber.default({\n        schema: asn1.result.blockName\n      });\n    } else {\n      this.variant = 2;\n      this.value = new asn1js.OctetString({\n        valueHex: asn1.result.blockName.valueBlock.valueHex\n      });\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    switch (this.variant) {\n      case 1:\n        return this.value.toSchema();\n\n      case 2:\n        return new asn1js.Primitive({\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          valueHex: this.value.valueBlock.valueHex\n        });\n\n      default:\n        return new asn1js.Any();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      variant: this.variant\n    };\n    if (this.variant === 1 || this.variant === 2) _object.value = this.value.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RecipientIdentifier;\n//# sourceMappingURL=RecipientIdentifier.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RecipientIdentifier.js\n// module id = ./node_modules/pkijs/build/RecipientIdentifier.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _KeyTransRecipientInfo = _interopRequireDefault(require(\"./KeyTransRecipientInfo.js\"));\n\nvar _KeyAgreeRecipientInfo = _interopRequireDefault(require(\"./KeyAgreeRecipientInfo.js\"));\n\nvar _KEKRecipientInfo = _interopRequireDefault(require(\"./KEKRecipientInfo.js\"));\n\nvar _PasswordRecipientinfo = _interopRequireDefault(require(\"./PasswordRecipientinfo.js\"));\n\nvar _OtherRecipientInfo = _interopRequireDefault(require(\"./OtherRecipientInfo.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass RecipientInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RecipientInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc variant\r\n     */\n    this.variant = (0, _pvutils.getParametersValue)(parameters, \"variant\", RecipientInfo.defaultValues(\"variant\"));\n    if (\"value\" in parameters)\n      /**\r\n       * @type {*}\r\n       * @desc value\r\n       */\n      this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", RecipientInfo.defaultValues(\"value\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"variant\":\n        return -1;\n\n      case \"value\":\n        return {};\n\n      default:\n        throw new Error(`Invalid member name for RecipientInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"variant\":\n        return memberValue === RecipientInfo.defaultValues(memberName);\n\n      case \"value\":\n        return Object.keys(memberValue).length === 0;\n\n      default:\n        throw new Error(`Invalid member name for RecipientInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RecipientInfo ::= CHOICE {\r\n   *    ktri KeyTransRecipientInfo,\r\n   *    kari [1] KeyAgreeRecipientInfo,\r\n   *    kekri [2] KEKRecipientInfo,\r\n   *    pwri [3] PasswordRecipientinfo,\r\n   *    ori [4] OtherRecipientInfo }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [type]\r\n     * @property {string} [setName]\r\n     * @property {string} [values]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Choice({\n      value: [_KeyTransRecipientInfo.default.schema({\n        names: {\n          blockName: names.blockName || \"\"\n        }\n      }), new asn1js.Constructed({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: _KeyAgreeRecipientInfo.default.schema().valueBlock.value\n      }), new asn1js.Constructed({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 2 // [2]\n\n        },\n        value: _KEKRecipientInfo.default.schema().valueBlock.value\n      }), new asn1js.Constructed({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 3 // [3]\n\n        },\n        value: _PasswordRecipientinfo.default.schema().valueBlock.value\n      }), new asn1js.Constructed({\n        name: names.blockName || \"\",\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 4 // [4]\n\n        },\n        value: _OtherRecipientInfo.default.schema().valueBlock.value\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"blockName\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RecipientInfo.schema({\n      names: {\n        blockName: \"blockName\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RecipientInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (asn1.result.blockName.idBlock.tagClass === 1) {\n      this.variant = 1;\n      this.value = new _KeyTransRecipientInfo.default({\n        schema: asn1.result.blockName\n      });\n    } else {\n      //region Create \"SEQUENCE\" from \"ASN1_CONSTRUCTED\"\n      const blockSequence = new asn1js.Sequence({\n        value: asn1.result.blockName.valueBlock.value\n      }); //endregion\n\n      switch (asn1.result.blockName.idBlock.tagNumber) {\n        case 1:\n          this.variant = 2;\n          this.value = new _KeyAgreeRecipientInfo.default({\n            schema: blockSequence\n          });\n          break;\n\n        case 2:\n          this.variant = 3;\n          this.value = new _KEKRecipientInfo.default({\n            schema: blockSequence\n          });\n          break;\n\n        case 3:\n          this.variant = 4;\n          this.value = new _PasswordRecipientinfo.default({\n            schema: blockSequence\n          });\n          break;\n\n        case 4:\n          this.variant = 5;\n          this.value = new _OtherRecipientInfo.default({\n            schema: blockSequence\n          });\n          break;\n\n        default:\n          throw new Error(\"Incorrect structure of RecipientInfo block\");\n      }\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    const _schema = this.value.toSchema();\n\n    switch (this.variant) {\n      case 1:\n        return _schema;\n\n      case 2:\n      case 3:\n      case 4:\n        //region Create \"ASN1_CONSTRUCTED\" from \"SEQUENCE\"\n        _schema.idBlock.tagClass = 3; // CONTEXT-SPECIFIC\n\n        _schema.idBlock.tagNumber = this.variant - 1; //endregion\n\n        return _schema;\n\n      default:\n        return new asn1js.Any();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      variant: this.variant\n    };\n    if (this.variant >= 1 && this.variant <= 4) _object.value = this.value.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RecipientInfo;\n//# sourceMappingURL=RecipientInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RecipientInfo.js\n// module id = ./node_modules/pkijs/build/RecipientInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _OtherKeyAttribute = _interopRequireDefault(require(\"./OtherKeyAttribute.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass RecipientKeyIdentifier {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RecipientKeyIdentifier class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {OctetString}\r\n     * @desc subjectKeyIdentifier\r\n     */\n    this.subjectKeyIdentifier = (0, _pvutils.getParametersValue)(parameters, \"subjectKeyIdentifier\", RecipientKeyIdentifier.defaultValues(\"subjectKeyIdentifier\"));\n    if (\"date\" in parameters)\n      /**\r\n       * @type {GeneralizedTime}\r\n       * @desc date\r\n       */\n      this.date = (0, _pvutils.getParametersValue)(parameters, \"date\", RecipientKeyIdentifier.defaultValues(\"date\"));\n    if (\"other\" in parameters)\n      /**\r\n       * @type {OtherKeyAttribute}\r\n       * @desc other\r\n       */\n      this.other = (0, _pvutils.getParametersValue)(parameters, \"other\", RecipientKeyIdentifier.defaultValues(\"other\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"subjectKeyIdentifier\":\n        return new asn1js.OctetString();\n\n      case \"date\":\n        return new asn1js.GeneralizedTime();\n\n      case \"other\":\n        return new _OtherKeyAttribute.default();\n\n      default:\n        throw new Error(`Invalid member name for RecipientKeyIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"subjectKeyIdentifier\":\n        return memberValue.isEqual(RecipientKeyIdentifier.defaultValues(\"subjectKeyIdentifier\"));\n\n      case \"date\":\n        // noinspection OverlyComplexBooleanExpressionJS\n        return memberValue.year === 0 && memberValue.month === 0 && memberValue.day === 0 && memberValue.hour === 0 && memberValue.minute === 0 && memberValue.second === 0 && memberValue.millisecond === 0;\n\n      case \"other\":\n        return memberValue.keyAttrId === \"\" && \"keyAttr\" in memberValue === false;\n\n      default:\n        throw new Error(`Invalid member name for RecipientKeyIdentifier class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RecipientKeyIdentifier ::= SEQUENCE {\r\n   *    subjectKeyIdentifier SubjectKeyIdentifier,\r\n   *    date GeneralizedTime OPTIONAL,\r\n   *    other OtherKeyAttribute OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [type]\r\n     * @property {string} [setName]\r\n     * @property {string} [values]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.OctetString({\n        name: names.subjectKeyIdentifier || \"\"\n      }), new asn1js.GeneralizedTime({\n        optional: true,\n        name: names.date || \"\"\n      }), _OtherKeyAttribute.default.schema(names.other || {})]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"subjectKeyIdentifier\", \"date\", \"other\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RecipientKeyIdentifier.schema({\n      names: {\n        subjectKeyIdentifier: \"subjectKeyIdentifier\",\n        date: \"date\",\n        other: {\n          names: {\n            blockName: \"other\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RecipientKeyIdentifier\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.subjectKeyIdentifier = asn1.result.subjectKeyIdentifier;\n    if (\"date\" in asn1.result) this.date = asn1.result.date;\n    if (\"other\" in asn1.result) this.other = new _OtherKeyAttribute.default({\n      schema: asn1.result.other\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(this.subjectKeyIdentifier);\n    if (\"date\" in this) outputArray.push(this.date);\n    if (\"other\" in this) outputArray.push(this.other.toSchema()); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      subjectKeyIdentifier: this.subjectKeyIdentifier.toJSON()\n    };\n    if (\"date\" in this) _object.date = this.date;\n    if (\"other\" in this) _object.other = this.other.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RecipientKeyIdentifier;\n//# sourceMappingURL=RecipientKeyIdentifier.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RecipientKeyIdentifier.js\n// module id = ./node_modules/pkijs/build/RecipientKeyIdentifier.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AttributeTypeAndValue = _interopRequireDefault(require(\"./AttributeTypeAndValue.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass RelativeDistinguishedNames {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RelativeDistinguishedNames class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   * @property {Array.<AttributeTypeAndValue>} [typesAndValues] Array of \"type and value\" objects\r\n   * @property {ArrayBuffer} [valueBeforeDecode] Value of the RDN before decoding from schema\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<AttributeTypeAndValue>}\r\n     * @desc Array of \"type and value\" objects\r\n     */\n    this.typesAndValues = (0, _pvutils.getParametersValue)(parameters, \"typesAndValues\", RelativeDistinguishedNames.defaultValues(\"typesAndValues\"));\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc Value of the RDN before decoding from schema\r\n     */\n\n    this.valueBeforeDecode = (0, _pvutils.getParametersValue)(parameters, \"valueBeforeDecode\", RelativeDistinguishedNames.defaultValues(\"valueBeforeDecode\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"typesAndValues\":\n        return [];\n\n      case \"valueBeforeDecode\":\n        return new ArrayBuffer(0);\n\n      default:\n        throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"typesAndValues\":\n        return memberValue.length === 0;\n\n      case \"valueBeforeDecode\":\n        return memberValue.byteLength === 0;\n\n      default:\n        throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RDNSequence ::= Sequence OF RelativeDistinguishedName\r\n   *\r\n   * RelativeDistinguishedName ::=\r\n   * SET SIZE (1..MAX) OF AttributeTypeAndValue\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName] Name for entire block\r\n     * @property {string} [repeatedSequence] Name for \"repeatedSequence\" block\r\n     * @property {string} [repeatedSet] Name for \"repeatedSet\" block\r\n     * @property {string} [typeAndValue] Name for \"typeAndValue\" block\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.repeatedSequence || \"\",\n        value: new asn1js.Set({\n          value: [new asn1js.Repeated({\n            name: names.repeatedSet || \"\",\n            value: _AttributeTypeAndValue.default.schema(names.typeAndValue || {})\n          })]\n        })\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"RDN\", \"typesAndValues\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RelativeDistinguishedNames.schema({\n      names: {\n        blockName: \"RDN\",\n        repeatedSet: \"typesAndValues\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RelativeDistinguishedNames\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"typesAndValues\" in asn1.result) // Could be a case when there is no \"types and values\"\n      this.typesAndValues = Array.from(asn1.result.typesAndValues, element => new _AttributeTypeAndValue.default({\n        schema: element\n      })); // noinspection JSUnresolvedVariable\n\n    this.valueBeforeDecode = asn1.result.RDN.valueBeforeDecode; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Decode stored TBS value\n    if (this.valueBeforeDecode.byteLength === 0) // No stored encoded array, create \"from scratch\"\n      {\n        return new asn1js.Sequence({\n          value: [new asn1js.Set({\n            value: Array.from(this.typesAndValues, element => element.toSchema())\n          })]\n        });\n      }\n\n    const asn1 = asn1js.fromBER(this.valueBeforeDecode); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return asn1.result; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      typesAndValues: Array.from(this.typesAndValues, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n  /**\r\n   * Compare two RDN values, or RDN with ArrayBuffer value\r\n   * @param {(RelativeDistinguishedNames|ArrayBuffer)} compareTo The value compare to current\r\n   * @returns {boolean}\r\n   */\n\n\n  isEqual(compareTo) {\n    if (compareTo instanceof RelativeDistinguishedNames) {\n      if (this.typesAndValues.length !== compareTo.typesAndValues.length) return false;\n\n      var _iterator = _createForOfIteratorHelper(this.typesAndValues.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          const _step$value = _slicedToArray(_step.value, 2),\n                index = _step$value[0],\n                typeAndValue = _step$value[1];\n\n          if (typeAndValue.isEqual(compareTo.typesAndValues[index]) === false) return false;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n\n    if (compareTo instanceof ArrayBuffer) return (0, _pvutils.isEqualBuffer)(this.valueBeforeDecode, compareTo);\n    return false;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RelativeDistinguishedNames;\n//# sourceMappingURL=RelativeDistinguishedNames.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RelativeDistinguishedNames.js\n// module id = ./node_modules/pkijs/build/RelativeDistinguishedNames.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _RelativeDistinguishedNames = _interopRequireDefault(require(\"./RelativeDistinguishedNames.js\"));\n\nvar _SingleResponse = _interopRequireDefault(require(\"./SingleResponse.js\"));\n\nvar _Extension = _interopRequireDefault(require(\"./Extension.js\"));\n\nvar _Extensions = _interopRequireDefault(require(\"./Extensions.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC6960\r\n */\nclass ResponseData {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for ResponseData class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc tbs\r\n     */\n    this.tbs = (0, _pvutils.getParametersValue)(parameters, \"tbs\", ResponseData.defaultValues(\"tbs\"));\n    /**\r\n     * @type {Object}\r\n     * @desc responderID\r\n     */\n\n    this.responderID = (0, _pvutils.getParametersValue)(parameters, \"responderID\", ResponseData.defaultValues(\"responderID\"));\n    /**\r\n     * @type {Date}\r\n     * @desc producedAt\r\n     */\n\n    this.producedAt = (0, _pvutils.getParametersValue)(parameters, \"producedAt\", ResponseData.defaultValues(\"producedAt\"));\n    /**\r\n     * @type {Array.<SingleResponse>}\r\n     * @desc responses\r\n     */\n\n    this.responses = (0, _pvutils.getParametersValue)(parameters, \"responses\", ResponseData.defaultValues(\"responses\"));\n    if (\"responseExtensions\" in parameters)\n      /**\r\n       * @type {Array.<Extension>}\r\n       * @desc responseExtensions\r\n       */\n      this.responseExtensions = (0, _pvutils.getParametersValue)(parameters, \"responseExtensions\", ResponseData.defaultValues(\"responseExtensions\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"tbs\":\n        return new ArrayBuffer(0);\n\n      case \"responderID\":\n        return {};\n\n      case \"producedAt\":\n        return new Date(0, 0, 0);\n\n      case \"responses\":\n      case \"responseExtensions\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for ResponseData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"tbs\":\n        return memberValue.byteLength === 0;\n\n      case \"responderID\":\n        return Object.keys(memberValue).length === 0;\n\n      case \"producedAt\":\n        return memberValue === ResponseData.defaultValues(memberName);\n\n      case \"responses\":\n      case \"responseExtensions\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for ResponseData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * ResponseData ::= SEQUENCE {\r\n   *    version              [0] EXPLICIT Version DEFAULT v1,\r\n   *    responderID              ResponderID,\r\n   *    producedAt               GeneralizedTime,\r\n   *    responses                SEQUENCE OF SingleResponse,\r\n   *    responseExtensions   [1] EXPLICIT Extensions OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [ResponseDataByName]\r\n     * @property {string} [ResponseDataByKey]\r\n     * @property {string} [producedAt]\r\n     * @property {string} [response]\r\n     * @property {string} [extensions]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"ResponseData\",\n      value: [new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Integer({\n          name: names.version || \"ResponseData.version\"\n        })]\n      }), new asn1js.Choice({\n        value: [new asn1js.Constructed({\n          name: names.responderID || \"ResponseData.responderID\",\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 1 // [1]\n\n          },\n          value: [_RelativeDistinguishedNames.default.schema(names.ResponseDataByName || {\n            names: {\n              blockName: \"ResponseData.byName\"\n            }\n          })]\n        }), new asn1js.Constructed({\n          name: names.responderID || \"ResponseData.responderID\",\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 2 // [2]\n\n          },\n          value: [new asn1js.OctetString({\n            name: names.ResponseDataByKey || \"ResponseData.byKey\"\n          })]\n        })]\n      }), new asn1js.GeneralizedTime({\n        name: names.producedAt || \"ResponseData.producedAt\"\n      }), new asn1js.Sequence({\n        value: [new asn1js.Repeated({\n          name: \"ResponseData.responses\",\n          value: _SingleResponse.default.schema(names.response || {})\n        })]\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [_Extensions.default.schema(names.extensions || {\n          names: {\n            blockName: \"ResponseData.responseExtensions\"\n          }\n        })]\n      }) // EXPLICIT SEQUENCE value\n      ]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"ResponseData\", \"ResponseData.version\", \"ResponseData.responderID\", \"ResponseData.producedAt\", \"ResponseData.responses\", \"ResponseData.responseExtensions\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, ResponseData.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for ResponseData\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.tbs = asn1.result.ResponseData.valueBeforeDecode;\n    if (\"ResponseData.version\" in asn1.result) this.version = asn1.result[\"ResponseData.version\"].valueBlock.valueDec;\n    if (asn1.result[\"ResponseData.responderID\"].idBlock.tagNumber === 1) this.responderID = new _RelativeDistinguishedNames.default({\n      schema: asn1.result[\"ResponseData.responderID\"].valueBlock.value[0]\n    });else this.responderID = asn1.result[\"ResponseData.responderID\"].valueBlock.value[0]; // OCTETSTRING\n\n    this.producedAt = asn1.result[\"ResponseData.producedAt\"].toDate();\n    this.responses = Array.from(asn1.result[\"ResponseData.responses\"], element => new _SingleResponse.default({\n      schema: element\n    }));\n    if (\"ResponseData.responseExtensions\" in asn1.result) this.responseExtensions = Array.from(asn1.result[\"ResponseData.responseExtensions\"].valueBlock.value, element => new _Extension.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @param {boolean} encodeFlag If param equal to false then create TBS schema via decoding stored value. In othe case create TBS schema via assembling from TBS parts.\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema(encodeFlag = false) {\n    //region Decode stored TBS value \n    let tbsSchema;\n\n    if (encodeFlag === false) {\n      if (this.tbs.length === 0) // No stored certificate TBS part\n        return ResponseData.schema();\n      tbsSchema = asn1js.fromBER(this.tbs).result;\n    } //endregion \n    //region Create TBS schema via assembling from TBS parts\n    else {\n        const outputArray = [];\n\n        if (\"version\" in this) {\n          outputArray.push(new asn1js.Constructed({\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 0 // [0]\n\n            },\n            value: [new asn1js.Integer({\n              value: this.version\n            })]\n          }));\n        }\n\n        if (this.responderID instanceof _RelativeDistinguishedNames.default) {\n          outputArray.push(new asn1js.Constructed({\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 1 // [1]\n\n            },\n            value: [this.responderID.toSchema()]\n          }));\n        } else {\n          outputArray.push(new asn1js.Constructed({\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 2 // [2]\n\n            },\n            value: [this.responderID]\n          }));\n        }\n\n        outputArray.push(new asn1js.GeneralizedTime({\n          valueDate: this.producedAt\n        }));\n        outputArray.push(new asn1js.Sequence({\n          value: Array.from(this.responses, element => element.toSchema())\n        }));\n\n        if (\"responseExtensions\" in this) {\n          outputArray.push(new asn1js.Constructed({\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 1 // [1]\n\n            },\n            value: [new asn1js.Sequence({\n              value: Array.from(this.responseExtensions, element => element.toSchema())\n            })]\n          }));\n        }\n\n        tbsSchema = new asn1js.Sequence({\n          value: outputArray\n        });\n      } //endregion \n    //region Construct and return new ASN.1 schema for this object \n\n\n    return tbsSchema; //endregion \n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {};\n    if (\"version\" in this) _object.version = this.version;\n    if (\"responderID\" in this) _object.responderID = this.responderID;\n    if (\"producedAt\" in this) _object.producedAt = this.producedAt;\n    if (\"responses\" in this) _object.responses = Array.from(this.responses, element => element.toJSON());\n    if (\"responseExtensions\" in this) _object.responseExtensions = Array.from(this.responseExtensions, element => element.toJSON());\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = ResponseData;\n//# sourceMappingURL=ResponseData.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/ResponseData.js\n// module id = ./node_modules/pkijs/build/ResponseData.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _CertificateRevocationList = _interopRequireDefault(require(\"./CertificateRevocationList.js\"));\n\nvar _OtherRevocationInfoFormat = _interopRequireDefault(require(\"./OtherRevocationInfoFormat.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass RevocationInfoChoices {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RevocationInfoChoices class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<CertificateRevocationList>}\r\n     * @desc crls\r\n     */\n    this.crls = (0, _pvutils.getParametersValue)(parameters, \"crls\", RevocationInfoChoices.defaultValues(\"crls\"));\n    /**\r\n     * @type {Array.<OtherRevocationInfoFormat>}\r\n     * @desc otherRevocationInfos\r\n     */\n\n    this.otherRevocationInfos = (0, _pvutils.getParametersValue)(parameters, \"otherRevocationInfos\", RevocationInfoChoices.defaultValues(\"otherRevocationInfos\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"crls\":\n        return [];\n\n      case \"otherRevocationInfos\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for RevocationInfoChoices class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * RevocationInfoChoices ::= SET OF RevocationInfoChoice\r\n   *\r\n   * RevocationInfoChoice ::= CHOICE {\r\n   *    crl CertificateList,\r\n   *    other [1] IMPLICIT OtherRevocationInfoFormat }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [crls]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Set({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.crls || \"\",\n        value: new asn1js.Choice({\n          value: [_CertificateRevocationList.default.schema(), new asn1js.Constructed({\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 1 // [1]\n\n            },\n            value: [new asn1js.ObjectIdentifier(), new asn1js.Any()]\n          })]\n        })\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"crls\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RevocationInfoChoices.schema({\n      names: {\n        crls: \"crls\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RevocationInfoChoices\"); //endregion\n    //region Get internal properties from parsed schema\n\n    var _iterator = _createForOfIteratorHelper(asn1.result.crls),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const element = _step.value;\n        if (element.idBlock.tagClass === 1) this.crls.push(new _CertificateRevocationList.default({\n          schema: element\n        }));else this.otherRevocationInfos.push(new _OtherRevocationInfoFormat.default({\n          schema: element\n        }));\n      } //endregion\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output set\n    const outputArray = [];\n    outputArray.push(...Array.from(this.crls, element => element.toSchema()));\n    outputArray.push(...Array.from(this.otherRevocationInfos, element => {\n      const schema = element.toSchema();\n      schema.idBlock.tagClass = 3;\n      schema.idBlock.tagNumber = 1;\n      return schema;\n    })); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Set({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      crls: Array.from(this.crls, element => element.toJSON()),\n      otherRevocationInfos: Array.from(this.otherRevocationInfos, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RevocationInfoChoices;\n//# sourceMappingURL=RevocationInfoChoices.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RevocationInfoChoices.js\n// module id = ./node_modules/pkijs/build/RevocationInfoChoices.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _Time = _interopRequireDefault(require(\"./Time.js\"));\n\nvar _Extensions = _interopRequireDefault(require(\"./Extensions.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass RevokedCertificate {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for RevokedCertificate class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Integer}\r\n     * @desc userCertificate\r\n     */\n    this.userCertificate = (0, _pvutils.getParametersValue)(parameters, \"userCertificate\", RevokedCertificate.defaultValues(\"userCertificate\"));\n    /**\r\n     * @type {Time}\r\n     * @desc revocationDate\r\n     */\n\n    this.revocationDate = (0, _pvutils.getParametersValue)(parameters, \"revocationDate\", RevokedCertificate.defaultValues(\"revocationDate\"));\n    if (\"crlEntryExtensions\" in parameters)\n      /**\r\n       * @type {Extensions}\r\n       * @desc crlEntryExtensions\r\n       */\n      this.crlEntryExtensions = (0, _pvutils.getParametersValue)(parameters, \"crlEntryExtensions\", RevokedCertificate.defaultValues(\"crlEntryExtensions\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"userCertificate\":\n        return new asn1js.Integer();\n\n      case \"revocationDate\":\n        return new _Time.default();\n\n      case \"crlEntryExtensions\":\n        return new _Extensions.default();\n\n      default:\n        throw new Error(`Invalid member name for RevokedCertificate class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * revokedCertificates     SEQUENCE OF SEQUENCE  {\r\n      *        userCertificate         CertificateSerialNumber,\r\n      *        revocationDate          Time,\r\n      *        crlEntryExtensions      Extensions OPTIONAL\r\n      *                                 -- if present, version MUST be v2\r\n      *                             }  OPTIONAL,\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [userCertificate]\r\n     * @property {string} [revocationDate]\r\n     * @property {string} [crlEntryExtensions]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.userCertificate || \"userCertificate\"\n      }), _Time.default.schema({\n        names: {\n          utcTimeName: names.revocationDate || \"revocationDate\",\n          generalTimeName: names.revocationDate || \"revocationDate\"\n        }\n      }), _Extensions.default.schema({\n        names: {\n          blockName: names.crlEntryExtensions || \"crlEntryExtensions\"\n        }\n      }, true)]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"userCertificate\", \"revocationDate\", \"crlEntryExtensions\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, RevokedCertificate.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RevokedCertificate\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.userCertificate = asn1.result.userCertificate;\n    this.revocationDate = new _Time.default({\n      schema: asn1.result.revocationDate\n    });\n    if (\"crlEntryExtensions\" in asn1.result) this.crlEntryExtensions = new _Extensions.default({\n      schema: asn1.result.crlEntryExtensions\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [this.userCertificate, this.revocationDate.toSchema()];\n    if (\"crlEntryExtensions\" in this) outputArray.push(this.crlEntryExtensions.toSchema()); //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const object = {\n      userCertificate: this.userCertificate.toJSON(),\n      revocationDate: this.revocationDate.toJSON\n    };\n    if (\"crlEntryExtensions\" in this) object.crlEntryExtensions = this.crlEntryExtensions.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = RevokedCertificate;\n//# sourceMappingURL=RevokedCertificate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/RevokedCertificate.js\n// module id = ./node_modules/pkijs/build/RevokedCertificate.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _Attribute = _interopRequireDefault(require(\"./Attribute.js\"));\n\nvar _PrivateKeyInfo = _interopRequireDefault(require(\"./PrivateKeyInfo.js\"));\n\nvar _PKCS8ShroudedKeyBag = _interopRequireDefault(require(\"./PKCS8ShroudedKeyBag.js\"));\n\nvar _CertBag = _interopRequireDefault(require(\"./CertBag.js\"));\n\nvar _CRLBag = _interopRequireDefault(require(\"./CRLBag.js\"));\n\nvar _SecretBag = _interopRequireDefault(require(\"./SecretBag.js\"));\n\nvar _SafeContents = _interopRequireDefault(require(\"./SafeContents.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC7292\r\n */\nclass SafeBag {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for SafeBag class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc bagId\r\n     */\n    this.bagId = (0, _pvutils.getParametersValue)(parameters, \"bagId\", SafeBag.defaultValues(\"bagId\"));\n    /**\r\n     * @type {*}\r\n     * @desc bagValue\r\n     */\n\n    this.bagValue = (0, _pvutils.getParametersValue)(parameters, \"bagValue\", SafeBag.defaultValues(\"bagValue\"));\n    if (\"bagAttributes\" in parameters)\n      /**\r\n       * @type {Array.<Attribute>}\r\n       * @desc bagAttributes\r\n       */\n      this.bagAttributes = (0, _pvutils.getParametersValue)(parameters, \"bagAttributes\", SafeBag.defaultValues(\"bagAttributes\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"bagId\":\n        return \"\";\n\n      case \"bagValue\":\n        return new asn1js.Any();\n\n      case \"bagAttributes\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for SafeBag class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"bagId\":\n        return memberValue === \"\";\n\n      case \"bagValue\":\n        return memberValue instanceof asn1js.Any;\n\n      case \"bagAttributes\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for SafeBag class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * SafeBag ::= SEQUENCE {\r\n   *    bagId\t      \tBAG-TYPE.&id ({PKCS12BagSet}),\r\n   *    bagValue      [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\r\n   *    bagAttributes SET OF PKCS12Attribute OPTIONAL\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [bagId]\r\n     * @property {string} [bagValue]\r\n     * @property {string} [bagAttributes]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.bagId || \"bagId\"\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Any({\n          name: names.bagValue || \"bagValue\"\n        })] // EXPLICIT ANY value\n\n      }), new asn1js.Set({\n        optional: true,\n        value: [new asn1js.Repeated({\n          name: names.bagAttributes || \"bagAttributes\",\n          value: _Attribute.default.schema()\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"bagId\", \"bagValue\", \"bagAttributes\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, SafeBag.schema({\n      names: {\n        bagId: \"bagId\",\n        bagValue: \"bagValue\",\n        bagAttributes: \"bagAttributes\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for SafeBag\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.bagId = asn1.result.bagId.valueBlock.toString();\n\n    switch (this.bagId) {\n      case \"1.2.840.113549.1.12.10.1.1\":\n        // keyBag\n        this.bagValue = new _PrivateKeyInfo.default({\n          schema: asn1.result.bagValue\n        });\n        break;\n\n      case \"1.2.840.113549.1.12.10.1.2\":\n        // pkcs8ShroudedKeyBag\n        this.bagValue = new _PKCS8ShroudedKeyBag.default({\n          schema: asn1.result.bagValue\n        });\n        break;\n\n      case \"1.2.840.113549.1.12.10.1.3\":\n        // certBag\n        this.bagValue = new _CertBag.default({\n          schema: asn1.result.bagValue\n        });\n        break;\n\n      case \"1.2.840.113549.1.12.10.1.4\":\n        // crlBag\n        this.bagValue = new _CRLBag.default({\n          schema: asn1.result.bagValue\n        });\n        break;\n\n      case \"1.2.840.113549.1.12.10.1.5\":\n        // secretBag\n        this.bagValue = new _SecretBag.default({\n          schema: asn1.result.bagValue\n        });\n        break;\n\n      case \"1.2.840.113549.1.12.10.1.6\":\n        // safeContentsBag\n        this.bagValue = new _SafeContents.default({\n          schema: asn1.result.bagValue\n        });\n        break;\n\n      default:\n        throw new Error(`Invalid \"bagId\" for SafeBag: ${this.bagId}`);\n    }\n\n    if (\"bagAttributes\" in asn1.result) this.bagAttributes = Array.from(asn1.result.bagAttributes, element => new _Attribute.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    const outputArray = [new asn1js.ObjectIdentifier({\n      value: this.bagId\n    }), new asn1js.Constructed({\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: 0 // [0]\n\n      },\n      value: [this.bagValue.toSchema()]\n    })];\n\n    if (\"bagAttributes\" in this) {\n      outputArray.push(new asn1js.Set({\n        value: Array.from(this.bagAttributes, element => element.toSchema())\n      }));\n    }\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const output = {\n      bagId: this.bagId,\n      bagValue: this.bagValue.toJSON()\n    };\n    if (\"bagAttributes\" in this) output.bagAttributes = Array.from(this.bagAttributes, element => element.toJSON());\n    return output;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = SafeBag;\n//# sourceMappingURL=SafeBag.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/SafeBag.js\n// module id = ./node_modules/pkijs/build/SafeBag.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _SafeBag = _interopRequireDefault(require(\"./SafeBag.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC7292\r\n */\nclass SafeContents {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for SafeContents class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<SafeBag>}\r\n     * @desc safeBags\r\n     */\n    this.safeBags = (0, _pvutils.getParametersValue)(parameters, \"safeBags\", SafeContents.defaultValues(\"safeBags\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"safeBags\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for SafeContents class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"safeBags\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for SafeContents class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * SafeContents ::= SEQUENCE OF SafeBag\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [safeBags]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.safeBags || \"\",\n        value: _SafeBag.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"safeBags\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, SafeContents.schema({\n      names: {\n        safeBags: \"safeBags\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for SafeContents\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.safeBags = Array.from(asn1.result.safeBags, element => new _SafeBag.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.safeBags, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      safeBags: Array.from(this.safeBags, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = SafeContents;\n//# sourceMappingURL=SafeContents.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/SafeContents.js\n// module id = ./node_modules/pkijs/build/SafeContents.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC7292\r\n */\nclass SecretBag {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for SecretBag class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc secretTypeId\r\n     */\n    this.secretTypeId = (0, _pvutils.getParametersValue)(parameters, \"secretTypeId\", SecretBag.defaultValues(\"secretTypeId\"));\n    /**\r\n     * @type {*}\r\n     * @desc secretValue\r\n     */\n\n    this.secretValue = (0, _pvutils.getParametersValue)(parameters, \"secretValue\", SecretBag.defaultValues(\"secretValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"secretTypeId\":\n        return \"\";\n\n      case \"secretValue\":\n        return new asn1js.Any();\n\n      default:\n        throw new Error(`Invalid member name for SecretBag class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"secretTypeId\":\n        return memberValue === \"\";\n\n      case \"secretValue\":\n        return memberValue instanceof asn1js.Any;\n\n      default:\n        throw new Error(`Invalid member name for SecretBag class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * SecretBag ::= SEQUENCE {\r\n   *    secretTypeId BAG-TYPE.&id ({SecretTypes}),\r\n   *    secretValue  [0] EXPLICIT BAG-TYPE.&Type ({SecretTypes}{@secretTypeId})\r\n   * }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [id]\r\n     * @property {string} [value]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.ObjectIdentifier({\n        name: names.id || \"id\"\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.Any({\n          name: names.value || \"value\"\n        })] // EXPLICIT ANY value\n\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"secretTypeId\", \"secretValue\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, SecretBag.schema({\n      names: {\n        id: \"secretTypeId\",\n        value: \"secretValue\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for SecretBag\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.secretTypeId = asn1.result.secretTypeId.valueBlock.toString();\n    this.secretValue = asn1.result.secretValue; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [new asn1js.ObjectIdentifier({\n        value: this.secretTypeId\n      }), new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [this.secretValue.toSchema()]\n      })]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      secretTypeId: this.secretTypeId,\n      secretValue: this.secretValue.toJSON()\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = SecretBag;\n//# sourceMappingURL=SecretBag.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/SecretBag.js\n// module id = ./node_modules/pkijs/build/SecretBag.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _Attribute = _interopRequireDefault(require(\"./Attribute.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass SignedAndUnsignedAttributes {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for SignedAndUnsignedAttributes class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc type\r\n     */\n    this.type = (0, _pvutils.getParametersValue)(parameters, \"type\", SignedAndUnsignedAttributes.defaultValues(\"type\"));\n    /**\r\n     * @type {Array}\r\n     * @desc attributes\r\n     */\n\n    this.attributes = (0, _pvutils.getParametersValue)(parameters, \"attributes\", SignedAndUnsignedAttributes.defaultValues(\"attributes\"));\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc encodedValue Need to have it in order to successfully process with signature verification\r\n     */\n\n    this.encodedValue = (0, _pvutils.getParametersValue)(parameters, \"encodedValue\", SignedAndUnsignedAttributes.defaultValues(\"encodedValue\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"type\":\n        return -1;\n\n      case \"attributes\":\n        return [];\n\n      case \"encodedValue\":\n        return new ArrayBuffer(0);\n\n      default:\n        throw new Error(`Invalid member name for SignedAndUnsignedAttributes class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"type\":\n        return memberValue === SignedAndUnsignedAttributes.defaultValues(\"type\");\n\n      case \"attributes\":\n        return memberValue.length === 0;\n\n      case \"encodedValue\":\n        return memberValue.byteLength === 0;\n\n      default:\n        throw new Error(`Invalid member name for SignedAndUnsignedAttributes class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * SignedAttributes ::= SET SIZE (1..MAX) OF Attribute\r\n   *\r\n   * UnsignedAttributes ::= SET SIZE (1..MAX) OF Attribute\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {number} [tagNumber]\r\n     * @property {string} [attributes]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Constructed({\n      name: names.blockName || \"\",\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: names.tagNumber // \"SignedAttributes\" = 0, \"UnsignedAttributes\" = 1\n\n      },\n      value: [new asn1js.Repeated({\n        name: names.attributes || \"\",\n        value: _Attribute.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"attributes\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, SignedAndUnsignedAttributes.schema({\n      names: {\n        tagNumber: this.type,\n        attributes: \"attributes\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for SignedAndUnsignedAttributes\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.type = asn1.result.idBlock.tagNumber;\n    this.encodedValue = asn1.result.valueBeforeDecode; //region Change type from \"[0]\" to \"SET\" accordingly to standard\n\n    const encodedView = new Uint8Array(this.encodedValue);\n    encodedView[0] = 0x31; //endregion\n\n    if (\"attributes\" in asn1.result === false) {\n      if (this.type === 0) throw new Error(\"Wrong structure of SignedUnsignedAttributes\");else return; // Not so important in case of \"UnsignedAttributes\"\n    }\n\n    this.attributes = Array.from(asn1.result.attributes, element => new _Attribute.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    if (SignedAndUnsignedAttributes.compareWithDefault(\"type\", this.type) || SignedAndUnsignedAttributes.compareWithDefault(\"attributes\", this.attributes)) throw new Error(\"Incorrectly initialized \\\"SignedAndUnsignedAttributes\\\" class\"); //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Constructed({\n      optional: true,\n      idBlock: {\n        tagClass: 3,\n        // CONTEXT-SPECIFIC\n        tagNumber: this.type // \"SignedAttributes\" = 0, \"UnsignedAttributes\" = 1\n\n      },\n      value: Array.from(this.attributes, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    if (SignedAndUnsignedAttributes.compareWithDefault(\"type\", this.type) || SignedAndUnsignedAttributes.compareWithDefault(\"attributes\", this.attributes)) throw new Error(\"Incorrectly initialized \\\"SignedAndUnsignedAttributes\\\" class\");\n    return {\n      type: this.type,\n      attributes: Array.from(this.attributes, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = SignedAndUnsignedAttributes;\n//# sourceMappingURL=SignedAndUnsignedAttributes.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/SignedAndUnsignedAttributes.js\n// module id = ./node_modules/pkijs/build/SignedAndUnsignedAttributes.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifySCTsForCertificate = verifySCTsForCertificate;\nexports.default = exports.SignedCertificateTimestamp = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _bytestreamjs = require(\"bytestreamjs\");\n\nvar _common = require(\"./common.js\");\n\nvar _PublicKeyInfo = _interopRequireDefault(require(\"./PublicKeyInfo.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n//**************************************************************************************\nclass SignedCertificateTimestamp {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for SignedCertificateTimestamp class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", SignedCertificateTimestamp.defaultValues(\"version\"));\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc logID\r\n     */\n\n    this.logID = (0, _pvutils.getParametersValue)(parameters, \"logID\", SignedCertificateTimestamp.defaultValues(\"logID\"));\n    /**\r\n     * @type {Date}\r\n     * @desc timestamp\r\n     */\n\n    this.timestamp = (0, _pvutils.getParametersValue)(parameters, \"timestamp\", SignedCertificateTimestamp.defaultValues(\"timestamp\"));\n    /**\r\n     * @type {ArrayBuffer}\r\n     * @desc extensions\r\n     */\n\n    this.extensions = (0, _pvutils.getParametersValue)(parameters, \"extensions\", SignedCertificateTimestamp.defaultValues(\"extensions\"));\n    /**\r\n     * @type {string}\r\n     * @desc hashAlgorithm\r\n     */\n\n    this.hashAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"hashAlgorithm\", SignedCertificateTimestamp.defaultValues(\"hashAlgorithm\"));\n    /**\r\n     * @type {string}\r\n     * @desc signatureAlgorithm\r\n     */\n\n    this.signatureAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"signatureAlgorithm\", SignedCertificateTimestamp.defaultValues(\"signatureAlgorithm\"));\n    /**\r\n     * @type {Object}\r\n     * @desc signature\r\n     */\n\n    this.signature = (0, _pvutils.getParametersValue)(parameters, \"signature\", SignedCertificateTimestamp.defaultValues(\"signature\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n    //region If input argument array contains \"stream\"\n\n    if (\"stream\" in parameters) this.fromStream(parameters.stream); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"logID\":\n      case \"extensions\":\n        return new ArrayBuffer(0);\n\n      case \"timestamp\":\n        return new Date(0);\n\n      case \"hashAlgorithm\":\n      case \"signatureAlgorithm\":\n        return \"\";\n\n      case \"signature\":\n        return new asn1js.Any();\n\n      default:\n        throw new Error(`Invalid member name for SignedCertificateTimestamp class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    if (schema instanceof asn1js.RawData === false) throw new Error(\"Object's schema was not verified against input data for SignedCertificateTimestamp\");\n    const seqStream = new _bytestreamjs.SeqStream({\n      stream: new _bytestreamjs.ByteStream({\n        buffer: schema.data\n      })\n    });\n    this.fromStream(seqStream);\n  } //**********************************************************************************\n\n  /**\r\n   * Convert SeqStream data into current class\r\n   * @param {!SeqStream} stream\r\n   */\n\n\n  fromStream(stream) {\n    const blockLength = stream.getUint16();\n    this.version = stream.getBlock(1)[0];\n\n    if (this.version === 0) {\n      this.logID = new Uint8Array(stream.getBlock(32)).buffer.slice(0);\n      this.timestamp = new Date((0, _pvutils.utilFromBase)(new Uint8Array(stream.getBlock(8)), 8)); //region Extensions\n\n      const extensionsLength = stream.getUint16();\n      this.extensions = new Uint8Array(stream.getBlock(extensionsLength)).buffer.slice(0); //endregion\n      //region Hash algorithm\n\n      switch (stream.getBlock(1)[0]) {\n        case 0:\n          this.hashAlgorithm = \"none\";\n          break;\n\n        case 1:\n          this.hashAlgorithm = \"md5\";\n          break;\n\n        case 2:\n          this.hashAlgorithm = \"sha1\";\n          break;\n\n        case 3:\n          this.hashAlgorithm = \"sha224\";\n          break;\n\n        case 4:\n          this.hashAlgorithm = \"sha256\";\n          break;\n\n        case 5:\n          this.hashAlgorithm = \"sha384\";\n          break;\n\n        case 6:\n          this.hashAlgorithm = \"sha512\";\n          break;\n\n        default:\n          throw new Error(\"Object's stream was not correct for SignedCertificateTimestamp\");\n      } //endregion\n      //region Signature algorithm\n\n\n      switch (stream.getBlock(1)[0]) {\n        case 0:\n          this.signatureAlgorithm = \"anonymous\";\n          break;\n\n        case 1:\n          this.signatureAlgorithm = \"rsa\";\n          break;\n\n        case 2:\n          this.signatureAlgorithm = \"dsa\";\n          break;\n\n        case 3:\n          this.signatureAlgorithm = \"ecdsa\";\n          break;\n\n        default:\n          throw new Error(\"Object's stream was not correct for SignedCertificateTimestamp\");\n      } //endregion\n      //region Signature\n\n\n      const signatureLength = stream.getUint16();\n      const signatureData = new Uint8Array(stream.getBlock(signatureLength)).buffer.slice(0);\n      const asn1 = asn1js.fromBER(signatureData);\n      if (asn1.offset === -1) throw new Error(\"Object's stream was not correct for SignedCertificateTimestamp\");\n      this.signature = asn1.result; //endregion\n\n      if (blockLength !== 47 + extensionsLength + signatureLength) throw new Error(\"Object's stream was not correct for SignedCertificateTimestamp\");\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    const stream = this.toStream();\n    return new asn1js.RawData({\n      data: stream.stream.buffer\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to SeqStream data\r\n   * @returns {SeqStream} SeqStream object\r\n   */\n\n\n  toStream() {\n    const stream = new _bytestreamjs.SeqStream();\n    stream.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecode.byteLength);\n    stream.appendChar(this.version);\n    stream.appendView(new Uint8Array(this.logID));\n    const timeBuffer = new ArrayBuffer(8);\n    const timeView = new Uint8Array(timeBuffer);\n    const baseArray = (0, _pvutils.utilToBase)(this.timestamp.valueOf(), 8);\n    timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);\n    stream.appendView(timeView);\n    stream.appendUint16(this.extensions.byteLength);\n    if (this.extensions.byteLength) stream.appendView(new Uint8Array(this.extensions));\n\n    let _hashAlgorithm;\n\n    switch (this.hashAlgorithm.toLowerCase()) {\n      case \"none\":\n        _hashAlgorithm = 0;\n        break;\n\n      case \"md5\":\n        _hashAlgorithm = 1;\n        break;\n\n      case \"sha1\":\n        _hashAlgorithm = 2;\n        break;\n\n      case \"sha224\":\n        _hashAlgorithm = 3;\n        break;\n\n      case \"sha256\":\n        _hashAlgorithm = 4;\n        break;\n\n      case \"sha384\":\n        _hashAlgorithm = 5;\n        break;\n\n      case \"sha512\":\n        _hashAlgorithm = 6;\n        break;\n\n      default:\n        throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`);\n    }\n\n    stream.appendChar(_hashAlgorithm);\n\n    let _signatureAlgorithm;\n\n    switch (this.signatureAlgorithm.toLowerCase()) {\n      case \"anonymous\":\n        _signatureAlgorithm = 0;\n        break;\n\n      case \"rsa\":\n        _signatureAlgorithm = 1;\n        break;\n\n      case \"dsa\":\n        _signatureAlgorithm = 2;\n        break;\n\n      case \"ecdsa\":\n        _signatureAlgorithm = 3;\n        break;\n\n      default:\n        throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`);\n    }\n\n    stream.appendChar(_signatureAlgorithm);\n\n    const _signature = this.signature.toBER(false);\n\n    stream.appendUint16(_signature.byteLength);\n    stream.appendView(new Uint8Array(_signature));\n    return stream;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      version: this.version,\n      logID: (0, _pvutils.bufferToHexCodes)(this.logID),\n      timestamp: this.timestamp,\n      extensions: (0, _pvutils.bufferToHexCodes)(this.extensions),\n      hashAlgorithm: this.hashAlgorithm,\n      signatureAlgorithm: this.signatureAlgorithm,\n      signature: this.signature.toJSON()\n    };\n  } //**********************************************************************************\n\n  /**\r\n   * Verify SignedCertificateTimestamp for specific input data\r\n   * @param {Object[]} logs Array of objects with information about each CT Log (like here: https://ct.grahamedgecombe.com/logs.json)\r\n   * @param {String} logs.log_id Identifier of the CT Log encoded in BASE-64 format\r\n   * @param {String} logs.key Public key of the CT Log encoded in BASE-64 format\r\n   * @param {ArrayBuffer} data Data to verify signature against. Could be encoded Certificate or encoded PreCert\r\n   * @param {Number} [dataType=0] Type = 0 (data is encoded Certificate), type = 1 (data is encoded PreCert)\r\n   * @return {Promise<void>}\r\n   */\n\n\n  verify(logs, data, dataType = 0) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      //region Initial variables\n      let logId = (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(_this.logID));\n      let publicKeyBase64 = null;\n      let publicKeyInfo;\n      let stream = new _bytestreamjs.SeqStream(); //endregion\n      //region Found and init public key\n\n      var _iterator = _createForOfIteratorHelper(logs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          const log = _step.value;\n\n          if (log.log_id === logId) {\n            publicKeyBase64 = log.key;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (publicKeyBase64 === null) throw new Error(`Public key not found for CT with logId: ${logId}`);\n      const asn1 = asn1js.fromBER((0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(publicKeyBase64)));\n      if (asn1.offset === -1) throw new Error(`Incorrect key value for CT Log with logId: ${logId}`);\n      publicKeyInfo = new _PublicKeyInfo.default({\n        schema: asn1.result\n      }); //endregion\n      //region Initialize signed data block\n\n      stream.appendChar(0x00); // sct_version\n\n      stream.appendChar(0x00); // signature_type = certificate_timestamp\n\n      const timeBuffer = new ArrayBuffer(8);\n      const timeView = new Uint8Array(timeBuffer);\n      const baseArray = (0, _pvutils.utilToBase)(_this.timestamp.valueOf(), 8);\n      timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);\n      stream.appendView(timeView);\n      stream.appendUint16(dataType);\n      if (dataType === 0) stream.appendUint24(data.byteLength);\n      stream.appendView(new Uint8Array(data));\n      stream.appendUint16(_this.extensions.byteLength);\n      if (_this.extensions.byteLength !== 0) stream.appendView(new Uint8Array(_this.extensions)); //endregion\n      //region Perform verification\n\n      return (0, _common.getEngine)().subtle.verifyWithPublicKey(stream._stream._buffer.slice(0, stream._length), {\n        valueBlock: {\n          valueHex: _this.signature.toBER(false)\n        }\n      }, publicKeyInfo, {\n        algorithmId: \"\"\n      }, \"SHA-256\"); //endregion\n    })();\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * Class from RFC6962\r\n */\n\n\nexports.SignedCertificateTimestamp = SignedCertificateTimestamp;\n\nclass SignedCertificateTimestampList {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for SignedCertificateTimestampList class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<SignedCertificateTimestamp>}\r\n     * @desc timestamps\r\n     */\n    this.timestamps = (0, _pvutils.getParametersValue)(parameters, \"timestamps\", SignedCertificateTimestampList.defaultValues(\"timestamps\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"timestamps\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"timestamps\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * SignedCertificateTimestampList ::= OCTET STRING\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [optional]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    if (\"optional\" in names === false) names.optional = false;\n    return new asn1js.OctetString({\n      name: names.blockName || \"SignedCertificateTimestampList\",\n      optional: names.optional\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Check the schema is valid\n    if (schema instanceof asn1js.OctetString === false) throw new Error(\"Object's schema was not verified against input data for SignedCertificateTimestampList\"); //endregion\n    //region Get internal properties from parsed schema\n\n    const seqStream = new _bytestreamjs.SeqStream({\n      stream: new _bytestreamjs.ByteStream({\n        buffer: schema.valueBlock.valueHex\n      })\n    });\n    let dataLength = seqStream.getUint16();\n    if (dataLength !== seqStream.length) throw new Error(\"Object's schema was not verified against input data for SignedCertificateTimestampList\");\n\n    while (seqStream.length) this.timestamps.push(new SignedCertificateTimestamp({\n      stream: seqStream\n    })); //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Initial variables\n    const stream = new _bytestreamjs.SeqStream();\n    let overallLength = 0;\n    const timestampsData = []; //endregion\n    //region Get overall length\n\n    var _iterator2 = _createForOfIteratorHelper(this.timestamps),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        const timestamp = _step2.value;\n        const timestampStream = timestamp.toStream();\n        timestampsData.push(timestampStream);\n        overallLength += timestampStream.stream.buffer.byteLength;\n      } //endregion\n\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    stream.appendUint16(overallLength); //region Set data from all timestamps\n\n    for (var _i = 0, _timestampsData = timestampsData; _i < _timestampsData.length; _i++) {\n      const timestamp = _timestampsData[_i];\n      stream.appendView(timestamp.stream.view);\n    } //endregion\n\n\n    return new asn1js.OctetString({\n      valueHex: stream.stream.buffer.slice(0)\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      timestamps: Array.from(this.timestamps, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * Verify SignedCertificateTimestamp for specific certificate content\r\n * @param {Certificate} certificate Certificate for which verification would be performed\r\n * @param {Certificate} issuerCertificate Certificate of the issuer of target certificate\r\n * @param {Object[]} logs Array of objects with information about each CT Log (like here: https://ct.grahamedgecombe.com/logs.json)\r\n * @param {String} logs.log_id Identifier of the CT Log encoded in BASE-64 format\r\n * @param {String} logs.key Public key of the CT Log encoded in BASE-64 format\r\n * @param {Number} [index=-1] Index of SignedCertificateTimestamp inside SignedCertificateTimestampList (for -1 would verify all)\r\n * @return {Array} Array of verification results\r\n */\n\n\nexports.default = SignedCertificateTimestampList;\n\nfunction verifySCTsForCertificate(_x, _x2, _x3) {\n  return _verifySCTsForCertificate.apply(this, arguments);\n} //**********************************************************************************\n\n\nfunction _verifySCTsForCertificate() {\n  _verifySCTsForCertificate = _asyncToGenerator(function* (certificate, issuerCertificate, logs, index = -1) {\n    //region Initial variables\n    let parsedValue = null;\n    let tbs;\n    let issuerId;\n    const stream = new _bytestreamjs.SeqStream();\n    let preCert; //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Remove certificate extension\n\n    for (let i = 0; i < certificate.extensions.length; i++) {\n      switch (certificate.extensions[i].extnID) {\n        case \"1.3.6.1.4.1.11129.2.4.2\":\n          {\n            parsedValue = certificate.extensions[i].parsedValue;\n            if (parsedValue.timestamps.length === 0) throw new Error(\"Nothing to verify in the certificate\");\n            certificate.extensions.splice(i, 1);\n          }\n          break;\n\n        default:\n      }\n    } //endregion\n    //region Check we do have what to verify\n\n\n    if (parsedValue === null) throw new Error(\"No SignedCertificateTimestampList extension in the specified certificate\"); //endregion\n    //region Prepare modifier TBS value\n\n    tbs = certificate.encodeTBS().toBER(false); //endregion\n    //region Initialize \"issuer_key_hash\" value\n\n    issuerId = yield crypto.digest({\n      name: \"SHA-256\"\n    }, new Uint8Array(issuerCertificate.subjectPublicKeyInfo.toSchema().toBER(false))); //endregion\n    //region Make final \"PreCert\" value\n\n    stream.appendView(new Uint8Array(issuerId));\n    stream.appendUint24(tbs.byteLength);\n    stream.appendView(new Uint8Array(tbs));\n    preCert = stream._stream._buffer.slice(0, stream._length); //endregion\n    //region Call verification function for specified index\n\n    if (index === -1) {\n      const verifyArray = [];\n\n      var _iterator3 = _createForOfIteratorHelper(parsedValue.timestamps),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          const timestamp = _step3.value;\n          const verifyResult = yield timestamp.verify(logs, preCert, 1);\n          verifyArray.push(verifyResult);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return verifyArray;\n    }\n\n    if (index >= parsedValue.timestamps.length) index = parsedValue.timestamps.length - 1;\n    return [yield parsedValue.timestamps[index].verify(logs, preCert, 1)]; //endregion\n  });\n  return _verifySCTsForCertificate.apply(this, arguments);\n}\n//# sourceMappingURL=SignedCertificateTimestampList.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/SignedCertificateTimestampList.js\n// module id = ./node_modules/pkijs/build/SignedCertificateTimestampList.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _EncapsulatedContentInfo = _interopRequireDefault(require(\"./EncapsulatedContentInfo.js\"));\n\nvar _Certificate = _interopRequireDefault(require(\"./Certificate.js\"));\n\nvar _CertificateRevocationList = _interopRequireDefault(require(\"./CertificateRevocationList.js\"));\n\nvar _OtherRevocationInfoFormat = _interopRequireDefault(require(\"./OtherRevocationInfoFormat.js\"));\n\nvar _SignerInfo = _interopRequireDefault(require(\"./SignerInfo.js\"));\n\nvar _CertificateSet = _interopRequireDefault(require(\"./CertificateSet.js\"));\n\nvar _RevocationInfoChoices = _interopRequireDefault(require(\"./RevocationInfoChoices.js\"));\n\nvar _IssuerAndSerialNumber = _interopRequireDefault(require(\"./IssuerAndSerialNumber.js\"));\n\nvar _TSTInfo = _interopRequireDefault(require(\"./TSTInfo.js\"));\n\nvar _CertificateChainValidationEngine = _interopRequireDefault(require(\"./CertificateChainValidationEngine.js\"));\n\nvar _BasicOCSPResponse = _interopRequireDefault(require(\"./BasicOCSPResponse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass SignedData {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for SignedData class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", SignedData.defaultValues(\"version\"));\n    /**\r\n     * @type {Array.<AlgorithmIdentifier>}\r\n     * @desc digestAlgorithms\r\n     */\n\n    this.digestAlgorithms = (0, _pvutils.getParametersValue)(parameters, \"digestAlgorithms\", SignedData.defaultValues(\"digestAlgorithms\"));\n    /**\r\n     * @type {EncapsulatedContentInfo}\r\n     * @desc encapContentInfo\r\n     */\n\n    this.encapContentInfo = (0, _pvutils.getParametersValue)(parameters, \"encapContentInfo\", SignedData.defaultValues(\"encapContentInfo\"));\n    if (\"certificates\" in parameters)\n      /**\r\n       * @type {Array.<Certificate|OtherCertificateFormat>}\r\n       * @desc certificates\r\n       */\n      this.certificates = (0, _pvutils.getParametersValue)(parameters, \"certificates\", SignedData.defaultValues(\"certificates\"));\n    if (\"crls\" in parameters)\n      /**\r\n       * @type {Array.<CertificateRevocationList|OtherRevocationInfoFormat>}\r\n       * @desc crls\r\n       */\n      this.crls = (0, _pvutils.getParametersValue)(parameters, \"crls\", SignedData.defaultValues(\"crls\"));\n    if (\"ocsps\" in parameters)\n      /**\r\n       * @type {Array.<BasicOCSPResponse>}\r\n       * @desc crls\r\n       */\n      this.ocsps = (0, _pvutils.getParametersValue)(parameters, \"ocsps\", SignedData.defaultValues(\"ocsps\"));\n    /**\r\n     * @type {Array.<SignerInfo>}\r\n     * @desc signerInfos\r\n     */\n\n    this.signerInfos = (0, _pvutils.getParametersValue)(parameters, \"signerInfos\", SignedData.defaultValues(\"signerInfos\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"digestAlgorithms\":\n        return [];\n\n      case \"encapContentInfo\":\n        return new _EncapsulatedContentInfo.default();\n\n      case \"certificates\":\n        return [];\n\n      case \"crls\":\n        return [];\n\n      case \"ocsps\":\n        return [];\n\n      case \"signerInfos\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for SignedData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n        return memberValue === SignedData.defaultValues(\"version\");\n\n      case \"encapContentInfo\":\n        return new _EncapsulatedContentInfo.default();\n\n      case \"digestAlgorithms\":\n      case \"certificates\":\n      case \"crls\":\n      case \"ocsps\":\n      case \"signerInfos\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for SignedData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * SignedData ::= SEQUENCE {\r\n   *    version CMSVersion,\r\n   *    digestAlgorithms DigestAlgorithmIdentifiers,\r\n   *    encapContentInfo EncapsulatedContentInfo,\r\n   *    certificates [0] IMPLICIT CertificateSet OPTIONAL,\r\n   *    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,\r\n   *    signerInfos SignerInfos }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [optional]\r\n     * @property {string} [digestAlgorithms]\r\n     * @property {string} [encapContentInfo]\r\n     * @property {string} [certificates]\r\n     * @property {string} [crls]\r\n     * @property {string} [signerInfos]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    if (\"optional\" in names === false) names.optional = false;\n    return new asn1js.Sequence({\n      name: names.blockName || \"SignedData\",\n      optional: names.optional,\n      value: [new asn1js.Integer({\n        name: names.version || \"SignedData.version\"\n      }), new asn1js.Set({\n        value: [new asn1js.Repeated({\n          name: names.digestAlgorithms || \"SignedData.digestAlgorithms\",\n          value: _AlgorithmIdentifier.default.schema()\n        })]\n      }), _EncapsulatedContentInfo.default.schema(names.encapContentInfo || {\n        names: {\n          blockName: \"SignedData.encapContentInfo\"\n        }\n      }), new asn1js.Constructed({\n        name: names.certificates || \"SignedData.certificates\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: _CertificateSet.default.schema().valueBlock.value\n      }), // IMPLICIT CertificateSet\n      new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: _RevocationInfoChoices.default.schema(names.crls || {\n          names: {\n            crls: \"SignedData.crls\"\n          }\n        }).valueBlock.value\n      }), // IMPLICIT RevocationInfoChoices\n      new asn1js.Set({\n        value: [new asn1js.Repeated({\n          name: names.signerInfos || \"SignedData.signerInfos\",\n          value: _SignerInfo.default.schema()\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"SignedData.version\", \"SignedData.digestAlgorithms\", \"SignedData.encapContentInfo\", \"SignedData.certificates\", \"SignedData.crls\", \"SignedData.signerInfos\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, SignedData.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for SignedData\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result[\"SignedData.version\"].valueBlock.valueDec;\n    if (\"SignedData.digestAlgorithms\" in asn1.result) // Could be empty SET of digest algorithms\n      this.digestAlgorithms = Array.from(asn1.result[\"SignedData.digestAlgorithms\"], algorithm => new _AlgorithmIdentifier.default({\n        schema: algorithm\n      }));\n    this.encapContentInfo = new _EncapsulatedContentInfo.default({\n      schema: asn1.result[\"SignedData.encapContentInfo\"]\n    });\n\n    if (\"SignedData.certificates\" in asn1.result) {\n      const certificateSet = new _CertificateSet.default({\n        schema: new asn1js.Set({\n          value: asn1.result[\"SignedData.certificates\"].valueBlock.value\n        })\n      });\n      this.certificates = certificateSet.certificates.slice(0); // Copy all just for making comfortable access\n    }\n\n    if (\"SignedData.crls\" in asn1.result) {\n      this.crls = Array.from(asn1.result[\"SignedData.crls\"], crl => {\n        if (crl.idBlock.tagClass === 1) return new _CertificateRevocationList.default({\n          schema: crl\n        }); //region Create SEQUENCE from [1]\n\n        crl.idBlock.tagClass = 1; // UNIVERSAL\n\n        crl.idBlock.tagNumber = 16; // SEQUENCE\n        //endregion\n\n        return new _OtherRevocationInfoFormat.default({\n          schema: crl\n        });\n      });\n    }\n\n    if (\"SignedData.signerInfos\" in asn1.result) // Could be empty SET SignerInfos\n      this.signerInfos = Array.from(asn1.result[\"SignedData.signerInfos\"], signerInfoSchema => new _SignerInfo.default({\n        schema: signerInfoSchema\n      })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema(encodeFlag = false) {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.Integer({\n      value: this.version\n    })); //region Create array of digest algorithms\n\n    outputArray.push(new asn1js.Set({\n      value: Array.from(this.digestAlgorithms, algorithm => algorithm.toSchema(encodeFlag))\n    })); //endregion\n\n    outputArray.push(this.encapContentInfo.toSchema());\n\n    if (\"certificates\" in this) {\n      const certificateSet = new _CertificateSet.default({\n        certificates: this.certificates\n      });\n      const certificateSetSchema = certificateSet.toSchema();\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          tagNumber: 0\n        },\n        value: certificateSetSchema.valueBlock.value\n      }));\n    }\n\n    if (\"crls\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: Array.from(this.crls, crl => {\n          if (crl instanceof _OtherRevocationInfoFormat.default) {\n            const crlSchema = crl.toSchema(encodeFlag);\n            crlSchema.idBlock.tagClass = 3;\n            crlSchema.idBlock.tagNumber = 1;\n            return crlSchema;\n          }\n\n          return crl.toSchema(encodeFlag);\n        })\n      }));\n    } //region Create array of signer infos\n\n\n    outputArray.push(new asn1js.Set({\n      value: Array.from(this.signerInfos, signerInfo => signerInfo.toSchema(encodeFlag))\n    })); //endregion\n    //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      version: this.version,\n      digestAlgorithms: Array.from(this.digestAlgorithms, algorithm => algorithm.toJSON()),\n      encapContentInfo: this.encapContentInfo.toJSON()\n    };\n    if (\"certificates\" in this) _object.certificates = Array.from(this.certificates, certificate => certificate.toJSON());\n    if (\"crls\" in this) _object.crls = Array.from(this.crls, crl => crl.toJSON());\n    _object.signerInfos = Array.from(this.signerInfos, signerInfo => signerInfo.toJSON());\n    return _object;\n  } //**********************************************************************************\n\n  /**\r\n   * Verify current SignedData value\r\n   * @param {Object} [param={}]\r\n   * @param {Number} [param.signer = -1] Index of the signer which information we need to verify\r\n   * @param {ArrayBuffer} [param.data=new ArrayBuffer(0)]\r\n   * @param {Array.<Certificate>} [param.trustedCerts=[]]\r\n   * @param {Date} [param.checkDate=new Date()]\r\n   * @param {Boolean} [param.checkChain=false]\r\n   * @param {Boolean} [param.extendedMode=false]\r\n   * @param {?Function} [findOrigin=null]\r\n   * @param {?Function} [findIssuer=null]\r\n   */\n\n\n  verify({\n    signer = -1,\n    data = new ArrayBuffer(0),\n    trustedCerts = [],\n    checkDate = new Date(),\n    checkChain = false,\n    extendedMode = false,\n    passedWhenNotRevValues = false,\n    findOrigin = null,\n    findIssuer = null\n  } = {}) {\n    //region Global variables\n    let sequence = Promise.resolve();\n    let messageDigestValue = new ArrayBuffer(0);\n    let shaAlgorithm = \"\";\n    let signerCertificate = {};\n    let timestampSerial = null;\n    let certificatePath = [];\n    const engine = (0, _common.getEngine)(); //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Get a signer number\n\n    if (signer === -1) {\n      if (extendedMode) {\n        return Promise.reject({\n          date: checkDate,\n          code: 1,\n          message: \"Unable to get signer index from input parameters\",\n          signatureVerified: null,\n          signerCertificate: null,\n          signerCertificateVerified: null\n        });\n      }\n\n      return Promise.reject(\"Unable to get signer index from input parameters\");\n    } //endregion\n    //region Check that certificates field was included in signed data\n\n\n    if (\"certificates\" in this === false) {\n      if (extendedMode) {\n        return Promise.reject({\n          date: checkDate,\n          code: 2,\n          message: \"No certificates attached to this signed data\",\n          signatureVerified: null,\n          signerCertificate: null,\n          signerCertificateVerified: null\n        });\n      }\n\n      return Promise.reject(\"No certificates attached to this signed data\");\n    } //endregion\n    //region Find a certificate for specified signer\n\n\n    if (this.signerInfos[signer].sid instanceof _IssuerAndSerialNumber.default) {\n      sequence = sequence.then(() => {\n        var _iterator = _createForOfIteratorHelper(this.certificates),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            const certificate = _step.value;\n            if (certificate instanceof _Certificate.default === false) continue;\n\n            if (certificate.issuer.isEqual(this.signerInfos[signer].sid.issuer) && certificate.serialNumber.isEqual(this.signerInfos[signer].sid.serialNumber)) {\n              signerCertificate = certificate;\n              return Promise.resolve();\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (extendedMode) {\n          return Promise.reject({\n            date: checkDate,\n            code: 3,\n            message: \"Unable to find signer certificate\",\n            signatureVerified: null,\n            signerCertificate: null,\n            signerCertificateVerified: null\n          });\n        }\n\n        return Promise.reject(\"Unable to find signer certificate\");\n      });\n    } else // Find by SubjectKeyIdentifier\n      {\n        sequence = sequence.then(() => Promise.all(Array.from(this.certificates.filter(certificate => certificate instanceof _Certificate.default), certificate => crypto.digest({\n          name: \"sha-1\"\n        }, new Uint8Array(certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(results => {\n          var _iterator2 = _createForOfIteratorHelper(this.certificates.entries()),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              const _step2$value = _slicedToArray(_step2.value, 2),\n                    index = _step2$value[0],\n                    certificate = _step2$value[1];\n\n              if (certificate instanceof _Certificate.default === false) continue;\n\n              if ((0, _pvutils.isEqualBuffer)(results[index], this.signerInfos[signer].sid.valueBlock.valueHex)) {\n                signerCertificate = certificate;\n                return Promise.resolve();\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          if (extendedMode) {\n            return Promise.reject({\n              date: checkDate,\n              code: 3,\n              message: \"Unable to find signer certificate\",\n              signatureVerified: null,\n              signerCertificate: null,\n              signerCertificateVerified: null\n            });\n          }\n\n          return Promise.reject(\"Unable to find signer certificate\");\n        }, () => {\n          if (extendedMode) {\n            return Promise.reject({\n              date: checkDate,\n              code: 3,\n              message: \"Unable to find signer certificate\",\n              signatureVerified: null,\n              signerCertificate: null,\n              signerCertificateVerified: null\n            });\n          }\n\n          return Promise.reject(\"Unable to find signer certificate\");\n        }));\n      } //endregion\n    //region Verify internal digest in case of \"tSTInfo\" content type\n\n\n    sequence = sequence.then(() => {\n      if (this.encapContentInfo.eContentType === \"1.2.840.113549.1.9.16.1.4\") {\n        //region Check \"eContent\" precense\n        if (\"eContent\" in this.encapContentInfo === false) return false; //endregion\n        //region Initialize TST_INFO value\n\n        const asn1 = asn1js.fromBER(this.encapContentInfo.eContent.valueBlock.valueHex);\n        let tstInfo;\n\n        try {\n          tstInfo = new _TSTInfo.default({\n            schema: asn1.result\n          });\n        } catch (ex) {\n          return false;\n        } //endregion\n        //region Change \"checkDate\" and append \"timestampSerial\"\n\n\n        checkDate = tstInfo.genTime;\n        timestampSerial = tstInfo.serialNumber.valueBlock.valueHex; //endregion\n        //region Check that we do have detached data content\n\n        if (data.byteLength === 0) {\n          if (extendedMode) {\n            return Promise.reject({\n              date: checkDate,\n              code: 4,\n              message: \"Missed detached data input array\",\n              signatureVerified: null,\n              signerCertificate,\n              signerCertificateVerified: null\n            });\n          }\n\n          return Promise.reject(\"Missed detached data input array\");\n        } //endregion\n\n\n        return tstInfo.verify({\n          data\n        });\n      }\n\n      return true;\n    }); //endregion\n    //region Make additional verification for signer's certificate\n\n    function checkCA(cert) {\n      /// <param name=\"cert\" type=\"in_window.org.pkijs.simpl.CERT\">Certificate to find CA flag for</param>\n      //region Do not include signer's certificate\n      if (cert.issuer.isEqual(signerCertificate.issuer) === true && cert.serialNumber.isEqual(signerCertificate.serialNumber) === true) return null; //endregion\n\n      let isCA = false;\n\n      if (\"extensions\" in cert) {\n        var _iterator3 = _createForOfIteratorHelper(cert.extensions),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            const extension = _step3.value;\n\n            if (extension.extnID === \"2.5.29.19\") // BasicConstraints\n              {\n                if (\"cA\" in extension.parsedValue) {\n                  if (extension.parsedValue.cA === true) isCA = true;\n                }\n              }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      if (isCA) return cert;\n      return null;\n    }\n\n    if (checkChain) {\n      sequence = sequence.then(result => {\n        //region Verify result of previous operation\n        if (result === false) return false; //endregion\n\n        const promiseResults = Array.from(this.certificates.filter(certificate => certificate instanceof _Certificate.default), certificate => checkCA(certificate));\n        const certificateChainValidationEngineParameters = {\n          checkDate,\n          certs: Array.from(promiseResults.filter(_result => _result !== null)),\n          trustedCerts\n        };\n        if (findIssuer !== null) certificateChainValidationEngineParameters.findIssuer = findIssuer;\n        if (findOrigin !== null) certificateChainValidationEngineParameters.findOrigin = findOrigin;\n        const certificateChainEngine = new _CertificateChainValidationEngine.default(certificateChainValidationEngineParameters);\n        certificateChainEngine.certs.push(signerCertificate);\n\n        if (\"crls\" in this) {\n          var _iterator4 = _createForOfIteratorHelper(this.crls),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              const crl = _step4.value;\n              if (\"thisUpdate\" in crl) certificateChainEngine.crls.push(crl);else // Assumed \"revocation value\" has \"OtherRevocationInfoFormat\"\n                {\n                  if (crl.otherRevInfoFormat === \"1.3.6.1.5.5.7.48.1.1\") // Basic OCSP response\n                    certificateChainEngine.ocsps.push(new _BasicOCSPResponse.default({\n                      schema: crl.otherRevInfo\n                    }));\n                }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n\n        if (\"ocsps\" in this) certificateChainEngine.ocsps.push(...this.ocsps);\n        return certificateChainEngine.verify({\n          passedWhenNotRevValues\n        }).then(verificationResult => {\n          if (\"certificatePath\" in verificationResult) certificatePath = verificationResult.certificatePath;\n          if (verificationResult.result === true) return Promise.resolve(true);\n\n          if (extendedMode) {\n            return Promise.reject({\n              date: checkDate,\n              code: 5,\n              message: `Validation of signer's certificate failed: ${verificationResult.resultMessage}`,\n              signatureVerified: null,\n              signerCertificate,\n              signerCertificateVerified: false\n            });\n          }\n\n          return Promise.reject(\"Validation of signer's certificate failed\");\n        }, error => {\n          if (extendedMode) {\n            return Promise.reject({\n              date: checkDate,\n              code: 5,\n              message: `Validation of signer's certificate failed with error: ${error instanceof Object ? error.resultMessage : error}`,\n              signatureVerified: null,\n              signerCertificate,\n              signerCertificateVerified: false\n            });\n          }\n\n          return Promise.reject(`Validation of signer's certificate failed with error: ${error instanceof Object ? error.resultMessage : error}`);\n        });\n      });\n    } //endregion\n    //region Find signer's hashing algorithm\n\n\n    sequence = sequence.then(result => {\n      //region Verify result of previous operation\n      if (result === false) return false; //endregion\n\n      const signerInfoHashAlgorithm = (0, _common.getAlgorithmByOID)(this.signerInfos[signer].digestAlgorithm.algorithmId);\n\n      if (\"name\" in signerInfoHashAlgorithm === false) {\n        if (extendedMode) {\n          return Promise.reject({\n            date: checkDate,\n            code: 7,\n            message: `Unsupported signature algorithm: ${this.signerInfos[signer].digestAlgorithm.algorithmId}`,\n            signatureVerified: null,\n            signerCertificate,\n            signerCertificateVerified: true\n          });\n        }\n\n        return Promise.reject(`Unsupported signature algorithm: ${this.signerInfos[signer].digestAlgorithm.algorithmId}`);\n      }\n\n      shaAlgorithm = signerInfoHashAlgorithm.name;\n      return true;\n    }); //endregion\n    //region Create correct data block for verification\n\n    sequence = sequence.then(result => {\n      //region Verify result of previous operation\n      if (result === false) return false; //endregion\n\n      if (\"eContent\" in this.encapContentInfo) // Attached data\n        {\n          if (this.encapContentInfo.eContent.idBlock.tagClass === 1 && this.encapContentInfo.eContent.idBlock.tagNumber === 4) {\n            if (this.encapContentInfo.eContent.idBlock.isConstructed === false) data = this.encapContentInfo.eContent.valueBlock.valueHex;else {\n              var _iterator5 = _createForOfIteratorHelper(this.encapContentInfo.eContent.valueBlock.value),\n                  _step5;\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  const contentValue = _step5.value;\n                  data = (0, _pvutils.utilConcatBuf)(data, contentValue.valueBlock.valueHex);\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n            }\n          } else data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;\n        } else // Detached data\n        {\n          if (data.byteLength === 0) // Check that \"data\" already provided by function parameter\n            {\n              if (extendedMode) {\n                return Promise.reject({\n                  date: checkDate,\n                  code: 8,\n                  message: \"Missed detached data input array\",\n                  signatureVerified: null,\n                  signerCertificate,\n                  signerCertificateVerified: true\n                });\n              }\n\n              return Promise.reject(\"Missed detached data input array\");\n            }\n        }\n\n      if (\"signedAttrs\" in this.signerInfos[signer]) {\n        //region Check mandatory attributes\n        let foundContentType = false;\n        let foundMessageDigest = false;\n\n        var _iterator6 = _createForOfIteratorHelper(this.signerInfos[signer].signedAttrs.attributes),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            const attribute = _step6.value;\n            //region Check that \"content-type\" attribute exists\n            if (attribute.type === \"1.2.840.113549.1.9.3\") foundContentType = true; //endregion\n            //region Check that \"message-digest\" attribute exists\n\n            if (attribute.type === \"1.2.840.113549.1.9.4\") {\n              foundMessageDigest = true;\n              messageDigestValue = attribute.values[0].valueBlock.valueHex;\n            } //endregion\n            //region Speed-up searching\n\n\n            if (foundContentType && foundMessageDigest) break; //endregion\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        if (foundContentType === false) {\n          if (extendedMode) {\n            return Promise.reject({\n              date: checkDate,\n              code: 9,\n              message: \"Attribute \\\"content-type\\\" is a mandatory attribute for \\\"signed attributes\\\"\",\n              signatureVerified: null,\n              signerCertificate,\n              signerCertificateVerified: true\n            });\n          }\n\n          return Promise.reject(\"Attribute \\\"content-type\\\" is a mandatory attribute for \\\"signed attributes\\\"\");\n        }\n\n        if (foundMessageDigest === false) {\n          if (extendedMode) {\n            return Promise.reject({\n              date: checkDate,\n              code: 10,\n              message: \"Attribute \\\"message-digest\\\" is a mandatory attribute for \\\"signed attributes\\\"\",\n              signatureVerified: null,\n              signerCertificate,\n              signerCertificateVerified: true\n            });\n          }\n\n          return Promise.reject(\"Attribute \\\"message-digest\\\" is a mandatory attribute for \\\"signed attributes\\\"\");\n        } //endregion\n\n      }\n\n      return true;\n    }); //endregion\n    //region Verify \"message-digest\" attribute in case of \"signedAttrs\"\n\n    sequence = sequence.then(result => {\n      //region Verify result of previous operation\n      if (result === false) return false; //endregion\n\n      if (\"signedAttrs\" in this.signerInfos[signer]) return crypto.digest(shaAlgorithm, new Uint8Array(data));\n      return true;\n    }).then(\n    /**\r\n     * @param {ArrayBuffer} result\r\n     */\n    result => {\n      //region Verify result of previous operation\n      if (result === false) return false; //endregion\n\n      if (\"signedAttrs\" in this.signerInfos[signer]) {\n        if ((0, _pvutils.isEqualBuffer)(result, messageDigestValue)) {\n          data = this.signerInfos[signer].signedAttrs.encodedValue;\n          return true;\n        }\n\n        return false;\n      }\n\n      return true;\n    }); //endregion\n\n    sequence = sequence.then(result => {\n      //region Verify result of previous operation\n      if (result === false) return false; //endregion\n\n      return engine.subtle.verifyWithPublicKey(data, this.signerInfos[signer].signature, signerCertificate.subjectPublicKeyInfo, signerCertificate.signatureAlgorithm, shaAlgorithm);\n    }); //region Make a final result\n\n    sequence = sequence.then(result => {\n      if (extendedMode) {\n        return {\n          date: checkDate,\n          code: 14,\n          message: \"\",\n          signatureVerified: result,\n          signerCertificate,\n          timestampSerial,\n          signerCertificateVerified: true,\n          certificatePath\n        };\n      }\n\n      return result;\n    }, error => {\n      if (extendedMode) {\n        if (\"code\" in error) return Promise.reject(error);\n        return Promise.reject({\n          date: checkDate,\n          code: 15,\n          message: `Error during verification: ${error.message}`,\n          signatureVerified: null,\n          signerCertificate,\n          timestampSerial,\n          signerCertificateVerified: true\n        });\n      }\n\n      return Promise.reject(error);\n    }); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Signing current SignedData\r\n   * @param {key} privateKey Private key for \"subjectPublicKeyInfo\" structure\r\n   * @param {number} signerIndex Index number (starting from 0) of signer index to make signature for\r\n   * @param {string} [hashAlgorithm=\"SHA-1\"] Hashing algorithm. Default SHA-1\r\n   * @param {ArrayBuffer} [data] Detached data\r\n   * @returns {*}\r\n   */\n\n\n  sign(privateKey, signerIndex, hashAlgorithm = \"SHA-1\", data = new ArrayBuffer(0)) {\n    //region Initial checking\n    if (typeof privateKey === \"undefined\") return Promise.reject(\"Need to provide a private key for signing\"); //endregion\n    //region Initial variables\n\n    let sequence = Promise.resolve();\n    let parameters;\n    const engine = (0, _common.getEngine)(); //endregion\n    //region Simple check for supported algorithm\n\n    const hashAlgorithmOID = (0, _common.getOIDByAlgorithm)({\n      name: hashAlgorithm\n    });\n    if (hashAlgorithmOID === \"\") return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`); //endregion\n    //region Append information about hash algorithm\n\n    if (this.digestAlgorithms.filter(algorithm => algorithm.algorithmId === hashAlgorithmOID).length === 0) {\n      this.digestAlgorithms.push(new _AlgorithmIdentifier.default({\n        algorithmId: hashAlgorithmOID,\n        algorithmParams: new asn1js.Null()\n      }));\n    }\n\n    this.signerInfos[signerIndex].digestAlgorithm = new _AlgorithmIdentifier.default({\n      algorithmId: hashAlgorithmOID,\n      algorithmParams: new asn1js.Null()\n    }); //endregion\n    //region Get a \"default parameters\" for current algorithm and set correct signature algorithm\n\n    sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));\n    sequence = sequence.then(result => {\n      parameters = result.parameters;\n      this.signerInfos[signerIndex].signatureAlgorithm = result.signatureAlgorithm;\n    }); //endregion\n    //region Create TBS data for signing\n\n    sequence = sequence.then(() => {\n      if (\"signedAttrs\" in this.signerInfos[signerIndex]) {\n        if (this.signerInfos[signerIndex].signedAttrs.encodedValue.byteLength !== 0) data = this.signerInfos[signerIndex].signedAttrs.encodedValue;else {\n          data = this.signerInfos[signerIndex].signedAttrs.toSchema(true).toBER(false); //region Change type from \"[0]\" to \"SET\" acordingly to standard\n\n          const view = new Uint8Array(data);\n          view[0] = 0x31; //endregion\n        }\n      } else {\n        if (\"eContent\" in this.encapContentInfo) // Attached data\n          {\n            if (this.encapContentInfo.eContent.idBlock.tagClass === 1 && this.encapContentInfo.eContent.idBlock.tagNumber === 4) {\n              if (this.encapContentInfo.eContent.idBlock.isConstructed === false) data = this.encapContentInfo.eContent.valueBlock.valueHex;else {\n                var _iterator7 = _createForOfIteratorHelper(this.encapContentInfo.eContent.valueBlock.value),\n                    _step7;\n\n                try {\n                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                    const content = _step7.value;\n                    data = (0, _pvutils.utilConcatBuf)(data, content.valueBlock.valueHex);\n                  }\n                } catch (err) {\n                  _iterator7.e(err);\n                } finally {\n                  _iterator7.f();\n                }\n              }\n            } else data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;\n          } else // Detached data\n          {\n            if (data.byteLength === 0) // Check that \"data\" already provided by function parameter\n              return Promise.reject(\"Missed detached data input array\");\n          }\n      }\n\n      return Promise.resolve();\n    }); //endregion\n    //region Signing TBS data on provided private key\n\n    sequence = sequence.then(() => engine.subtle.signWithPrivateKey(data, privateKey, parameters));\n    sequence = sequence.then(result => {\n      this.signerInfos[signerIndex].signature = new asn1js.OctetString({\n        valueHex: result\n      });\n      return result;\n    }); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = SignedData;\n//# sourceMappingURL=SignedData.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/SignedData.js\n// module id = ./node_modules/pkijs/build/SignedData.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _AlgorithmIdentifier = _interopRequireDefault(require(\"./AlgorithmIdentifier.js\"));\n\nvar _SignedAndUnsignedAttributes = _interopRequireDefault(require(\"./SignedAndUnsignedAttributes.js\"));\n\nvar _IssuerAndSerialNumber = _interopRequireDefault(require(\"./IssuerAndSerialNumber.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\nclass SignerInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for SignerInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {string}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", SignerInfo.defaultValues(\"version\"));\n    /**\r\n     * @type {Object}\r\n     * @desc sid\r\n     */\n\n    this.sid = (0, _pvutils.getParametersValue)(parameters, \"sid\", SignerInfo.defaultValues(\"sid\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc digestAlgorithm\r\n     */\n\n    this.digestAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"digestAlgorithm\", SignerInfo.defaultValues(\"digestAlgorithm\"));\n    if (\"signedAttrs\" in parameters)\n      /**\r\n       * @type {SignedAndUnsignedAttributes}\r\n       * @desc signedAttrs\r\n       */\n      this.signedAttrs = (0, _pvutils.getParametersValue)(parameters, \"signedAttrs\", SignerInfo.defaultValues(\"signedAttrs\"));\n    /**\r\n     * @type {AlgorithmIdentifier}\r\n     * @desc digestAlgorithm\r\n     */\n\n    this.signatureAlgorithm = (0, _pvutils.getParametersValue)(parameters, \"signatureAlgorithm\", SignerInfo.defaultValues(\"signatureAlgorithm\"));\n    /**\r\n     * @type {OctetString}\r\n     * @desc signature\r\n     */\n\n    this.signature = (0, _pvutils.getParametersValue)(parameters, \"signature\", SignerInfo.defaultValues(\"signature\"));\n    if (\"unsignedAttrs\" in parameters)\n      /**\r\n       * @type {SignedAndUnsignedAttributes}\r\n       * @desc unsignedAttrs\r\n       */\n      this.unsignedAttrs = (0, _pvutils.getParametersValue)(parameters, \"unsignedAttrs\", SignerInfo.defaultValues(\"unsignedAttrs\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"sid\":\n        return new asn1js.Any();\n\n      case \"digestAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"signedAttrs\":\n        return new _SignedAndUnsignedAttributes.default({\n          type: 0\n        });\n\n      case \"signatureAlgorithm\":\n        return new _AlgorithmIdentifier.default();\n\n      case \"signature\":\n        return new asn1js.OctetString();\n\n      case \"unsignedAttrs\":\n        return new _SignedAndUnsignedAttributes.default({\n          type: 1\n        });\n\n      default:\n        throw new Error(`Invalid member name for SignerInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n        return SignerInfo.defaultValues(\"version\") === memberValue;\n\n      case \"sid\":\n        return memberValue instanceof asn1js.Any;\n\n      case \"digestAlgorithm\":\n        if (memberValue instanceof _AlgorithmIdentifier.default === false) return false;\n        return memberValue.isEqual(SignerInfo.defaultValues(\"digestAlgorithm\"));\n\n      case \"signedAttrs\":\n        return _SignedAndUnsignedAttributes.default.compareWithDefault(\"type\", memberValue.type) && _SignedAndUnsignedAttributes.default.compareWithDefault(\"attributes\", memberValue.attributes) && _SignedAndUnsignedAttributes.default.compareWithDefault(\"encodedValue\", memberValue.encodedValue);\n\n      case \"signatureAlgorithm\":\n        if (memberValue instanceof _AlgorithmIdentifier.default === false) return false;\n        return memberValue.isEqual(SignerInfo.defaultValues(\"signatureAlgorithm\"));\n\n      case \"signature\":\n      case \"unsignedAttrs\":\n        return _SignedAndUnsignedAttributes.default.compareWithDefault(\"type\", memberValue.type) && _SignedAndUnsignedAttributes.default.compareWithDefault(\"attributes\", memberValue.attributes) && _SignedAndUnsignedAttributes.default.compareWithDefault(\"encodedValue\", memberValue.encodedValue);\n\n      default:\n        throw new Error(`Invalid member name for SignerInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * SignerInfo ::= SEQUENCE {\r\n   *    version CMSVersion,\r\n   *    sid SignerIdentifier,\r\n   *    digestAlgorithm DigestAlgorithmIdentifier,\r\n   *    signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,\r\n   *    signatureAlgorithm SignatureAlgorithmIdentifier,\r\n   *    signature SignatureValue,\r\n   *    unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }\r\n   *\r\n   * SignerIdentifier ::= CHOICE {\r\n   *    issuerAndSerialNumber IssuerAndSerialNumber,\r\n   *    subjectKeyIdentifier [0] SubjectKeyIdentifier }\r\n   *\r\n   * SubjectKeyIdentifier ::= OCTET STRING\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [sid]\r\n     * @property {string} [digestAlgorithm]\r\n     * @property {string} [signedAttrs]\r\n     * @property {string} [signatureAlgorithm]\r\n     * @property {string} [signature]\r\n     * @property {string} [unsignedAttrs]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: \"SignerInfo\",\n      value: [new asn1js.Integer({\n        name: names.version || \"SignerInfo.version\"\n      }), new asn1js.Choice({\n        value: [_IssuerAndSerialNumber.default.schema(names.sid || {\n          names: {\n            blockName: \"SignerInfo.sid\"\n          }\n        }), new asn1js.Constructed({\n          optional: true,\n          name: names.sid || \"SignerInfo.sid\",\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: [new asn1js.OctetString()]\n        })]\n      }), _AlgorithmIdentifier.default.schema(names.digestAlgorithm || {\n        names: {\n          blockName: \"SignerInfo.digestAlgorithm\"\n        }\n      }), _SignedAndUnsignedAttributes.default.schema(names.signedAttrs || {\n        names: {\n          blockName: \"SignerInfo.signedAttrs\",\n          tagNumber: 0\n        }\n      }), _AlgorithmIdentifier.default.schema(names.signatureAlgorithm || {\n        names: {\n          blockName: \"SignerInfo.signatureAlgorithm\"\n        }\n      }), new asn1js.OctetString({\n        name: names.signature || \"SignerInfo.signature\"\n      }), _SignedAndUnsignedAttributes.default.schema(names.unsignedAttrs || {\n        names: {\n          blockName: \"SignerInfo.unsignedAttrs\",\n          tagNumber: 1\n        }\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"SignerInfo.version\", \"SignerInfo.sid\", \"SignerInfo.digestAlgorithm\", \"SignerInfo.signedAttrs\", \"SignerInfo.signatureAlgorithm\", \"SignerInfo.signature\", \"SignerInfo.unsignedAttrs\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, SignerInfo.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for SignerInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result[\"SignerInfo.version\"].valueBlock.valueDec;\n    const currentSid = asn1.result[\"SignerInfo.sid\"];\n    if (currentSid.idBlock.tagClass === 1) this.sid = new _IssuerAndSerialNumber.default({\n      schema: currentSid\n    });else this.sid = currentSid;\n    this.digestAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result[\"SignerInfo.digestAlgorithm\"]\n    });\n    if (\"SignerInfo.signedAttrs\" in asn1.result) this.signedAttrs = new _SignedAndUnsignedAttributes.default({\n      type: 0,\n      schema: asn1.result[\"SignerInfo.signedAttrs\"]\n    });\n    this.signatureAlgorithm = new _AlgorithmIdentifier.default({\n      schema: asn1.result[\"SignerInfo.signatureAlgorithm\"]\n    });\n    this.signature = asn1.result[\"SignerInfo.signature\"];\n    if (\"SignerInfo.unsignedAttrs\" in asn1.result) this.unsignedAttrs = new _SignedAndUnsignedAttributes.default({\n      type: 1,\n      schema: asn1.result[\"SignerInfo.unsignedAttrs\"]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    if (SignerInfo.compareWithDefault(\"sid\", this.sid)) throw new Error(\"Incorrectly initialized \\\"SignerInfo\\\" class\"); //region Create array for output sequence \n\n    const outputArray = [];\n    outputArray.push(new asn1js.Integer({\n      value: this.version\n    }));\n    if (this.sid instanceof _IssuerAndSerialNumber.default) outputArray.push(this.sid.toSchema());else outputArray.push(this.sid);\n    outputArray.push(this.digestAlgorithm.toSchema());\n\n    if (\"signedAttrs\" in this) {\n      if (SignerInfo.compareWithDefault(\"signedAttrs\", this.signedAttrs) === false) outputArray.push(this.signedAttrs.toSchema());\n    }\n\n    outputArray.push(this.signatureAlgorithm.toSchema());\n    outputArray.push(this.signature);\n\n    if (\"unsignedAttrs\" in this) {\n      if (SignerInfo.compareWithDefault(\"unsignedAttrs\", this.unsignedAttrs) === false) outputArray.push(this.unsignedAttrs.toSchema());\n    } //endregion \n    //region Construct and return new ASN.1 schema for this object \n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion \n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    if (SignerInfo.compareWithDefault(\"sid\", this.sid)) throw new Error(\"Incorrectly initialized \\\"SignerInfo\\\" class\");\n    const _object = {\n      version: this.version\n    };\n    if (!(this.sid instanceof asn1js.Any)) _object.sid = this.sid.toJSON();\n    _object.digestAlgorithm = this.digestAlgorithm.toJSON();\n    if (SignerInfo.compareWithDefault(\"signedAttrs\", this.signedAttrs) === false) _object.signedAttrs = this.signedAttrs.toJSON();\n    _object.signatureAlgorithm = this.signatureAlgorithm.toJSON();\n    _object.signature = this.signature.toJSON();\n    if (SignerInfo.compareWithDefault(\"unsignedAttrs\", this.unsignedAttrs) === false) _object.unsignedAttrs = this.unsignedAttrs.toJSON();\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = SignerInfo;\n//# sourceMappingURL=SignerInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/SignerInfo.js\n// module id = ./node_modules/pkijs/build/SignerInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _CertID = _interopRequireDefault(require(\"./CertID.js\"));\n\nvar _Extension = _interopRequireDefault(require(\"./Extension.js\"));\n\nvar _Extensions = _interopRequireDefault(require(\"./Extensions.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC6960\r\n */\nclass SingleResponse {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for SingleResponse class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {CertID}\r\n     * @desc certID\r\n     */\n    this.certID = (0, _pvutils.getParametersValue)(parameters, \"certID\", SingleResponse.defaultValues(\"certID\"));\n    /**\r\n     * @type {Object}\r\n     * @desc certStatus\r\n     */\n\n    this.certStatus = (0, _pvutils.getParametersValue)(parameters, \"certStatus\", SingleResponse.defaultValues(\"certStatus\"));\n    /**\r\n     * @type {Date}\r\n     * @desc thisUpdate\r\n     */\n\n    this.thisUpdate = (0, _pvutils.getParametersValue)(parameters, \"thisUpdate\", SingleResponse.defaultValues(\"thisUpdate\"));\n    if (\"nextUpdate\" in parameters)\n      /**\r\n       * @type {Date}\r\n       * @desc nextUpdate\r\n       */\n      this.nextUpdate = (0, _pvutils.getParametersValue)(parameters, \"nextUpdate\", SingleResponse.defaultValues(\"nextUpdate\"));\n    if (\"singleExtensions\" in parameters)\n      /**\r\n       * @type {Array.<Extension>}\r\n       * @desc singleExtensions\r\n       */\n      this.singleExtensions = (0, _pvutils.getParametersValue)(parameters, \"singleExtensions\", SingleResponse.defaultValues(\"singleExtensions\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"certID\":\n        return new _CertID.default();\n\n      case \"certStatus\":\n        return {};\n\n      case \"thisUpdate\":\n      case \"nextUpdate\":\n        return new Date(0, 0, 0);\n\n      case \"singleExtensions\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for SingleResponse class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"certID\":\n        // noinspection OverlyComplexBooleanExpressionJS\n        return _CertID.default.compareWithDefault(\"hashAlgorithm\", memberValue.hashAlgorithm) && _CertID.default.compareWithDefault(\"issuerNameHash\", memberValue.issuerNameHash) && _CertID.default.compareWithDefault(\"issuerKeyHash\", memberValue.issuerKeyHash) && _CertID.default.compareWithDefault(\"serialNumber\", memberValue.serialNumber);\n\n      case \"certStatus\":\n        return Object.keys(memberValue).length === 0;\n\n      case \"thisUpdate\":\n      case \"nextUpdate\":\n        return memberValue === SingleResponse.defaultValues(memberName);\n\n      default:\n        throw new Error(`Invalid member name for SingleResponse class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * SingleResponse ::= SEQUENCE {\r\n   *    certID                       CertID,\r\n   *    certStatus                   CertStatus,\r\n   *    thisUpdate                   GeneralizedTime,\r\n   *    nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,\r\n   *    singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }\r\n   *\r\n   * CertStatus ::= CHOICE {\r\n   *    good        [0]     IMPLICIT NULL,\r\n   *    revoked     [1]     IMPLICIT RevokedInfo,\r\n   *    unknown     [2]     IMPLICIT UnknownInfo }\r\n   *\r\n   * RevokedInfo ::= SEQUENCE {\r\n   *    revocationTime              GeneralizedTime,\r\n   *    revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }\r\n   *\r\n   * UnknownInfo ::= NULL\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [certID]\r\n     * @property {string} [certStatus]\r\n     * @property {string} [thisUpdate]\r\n     * @property {string} [nextUpdate]\r\n     * @property {string} [singleExtensions]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [_CertID.default.schema(names.certID || {}), new asn1js.Choice({\n        value: [new asn1js.Primitive({\n          name: names.certStatus || \"\",\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          lenBlockLength: 1 // The length contains one byte 0x00\n\n        }), // IMPLICIT NULL (no \"valueBlock\")\n        new asn1js.Constructed({\n          name: names.certStatus || \"\",\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 1 // [1]\n\n          },\n          value: [new asn1js.GeneralizedTime(), new asn1js.Constructed({\n            optional: true,\n            idBlock: {\n              tagClass: 3,\n              // CONTEXT-SPECIFIC\n              tagNumber: 0 // [0]\n\n            },\n            value: [new asn1js.Enumerated()]\n          })]\n        }), new asn1js.Primitive({\n          name: names.certStatus || \"\",\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 2 // [2]\n\n          },\n          lenBlock: {\n            length: 1\n          }\n        }) // IMPLICIT NULL (no \"valueBlock\")\n        ]\n      }), new asn1js.GeneralizedTime({\n        name: names.thisUpdate || \"\"\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.GeneralizedTime({\n          name: names.nextUpdate || \"\"\n        })]\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [_Extensions.default.schema(names.singleExtensions || {})]\n      }) // EXPLICIT SEQUENCE value\n      ]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"certID\", \"certStatus\", \"thisUpdate\", \"nextUpdate\", \"singleExtensions\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, SingleResponse.schema({\n      names: {\n        certID: {\n          names: {\n            blockName: \"certID\"\n          }\n        },\n        certStatus: \"certStatus\",\n        thisUpdate: \"thisUpdate\",\n        nextUpdate: \"nextUpdate\",\n        singleExtensions: {\n          names: {\n            blockName: \"singleExtensions\"\n          }\n        }\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for SingleResponse\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.certID = new _CertID.default({\n      schema: asn1.result.certID\n    });\n    this.certStatus = asn1.result.certStatus;\n    this.thisUpdate = asn1.result.thisUpdate.toDate();\n    if (\"nextUpdate\" in asn1.result) this.nextUpdate = asn1.result.nextUpdate.toDate();\n    if (\"singleExtensions\" in asn1.result) this.singleExtensions = Array.from(asn1.result.singleExtensions.valueBlock.value, element => new _Extension.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create value array for output sequence\n    const outputArray = [];\n    outputArray.push(this.certID.toSchema());\n    outputArray.push(this.certStatus);\n    outputArray.push(new asn1js.GeneralizedTime({\n      valueDate: this.thisUpdate\n    }));\n\n    if (\"nextUpdate\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [new asn1js.GeneralizedTime({\n          valueDate: this.nextUpdate\n        })]\n      }));\n    }\n\n    if (\"singleExtensions\" in this) {\n      outputArray.push(new asn1js.Sequence({\n        value: Array.from(this.singleExtensions, element => element.toSchema())\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      certID: this.certID.toJSON(),\n      certStatus: this.certStatus.toJSON(),\n      thisUpdate: this.thisUpdate\n    };\n    if (\"nextUpdate\" in this) _object.nextUpdate = this.nextUpdate;\n    if (\"singleExtensions\" in this) _object.singleExtensions = Array.from(this.singleExtensions, element => element.toJSON());\n    return _object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = SingleResponse;\n//# sourceMappingURL=SingleResponse.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/SingleResponse.js\n// module id = ./node_modules/pkijs/build/SingleResponse.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _Attribute = _interopRequireDefault(require(\"./Attribute.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass SubjectDirectoryAttributes {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for SubjectDirectoryAttributes class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {Array.<Attribute>}\r\n     * @desc attributes\r\n     */\n    this.attributes = (0, _pvutils.getParametersValue)(parameters, \"attributes\", SubjectDirectoryAttributes.defaultValues(\"attributes\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"attributes\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for SubjectDirectoryAttributes class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * SubjectDirectoryAttributes ::= SEQUENCE SIZE (1..MAX) OF Attribute\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [utcTimeName] Name for \"utcTimeName\" choice\r\n     * @property {string} [generalTimeName] Name for \"generalTimeName\" choice\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Repeated({\n        name: names.attributes || \"\",\n        value: _Attribute.default.schema()\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"attributes\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, SubjectDirectoryAttributes.schema({\n      names: {\n        attributes: \"attributes\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for SubjectDirectoryAttributes\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.attributes = Array.from(asn1.result.attributes, element => new _Attribute.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: Array.from(this.attributes, element => element.toSchema())\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      attributes: Array.from(this.attributes, element => element.toJSON())\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = SubjectDirectoryAttributes;\n//# sourceMappingURL=SubjectDirectoryAttributes.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/SubjectDirectoryAttributes.js\n// module id = ./node_modules/pkijs/build/SubjectDirectoryAttributes.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _common = require(\"./common.js\");\n\nvar _MessageImprint = _interopRequireDefault(require(\"./MessageImprint.js\"));\n\nvar _Accuracy = _interopRequireDefault(require(\"./Accuracy.js\"));\n\nvar _GeneralName = _interopRequireDefault(require(\"./GeneralName.js\"));\n\nvar _Extension = _interopRequireDefault(require(\"./Extension.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC3161\r\n */\nclass TSTInfo {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for TSTInfo class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = (0, _pvutils.getParametersValue)(parameters, \"version\", TSTInfo.defaultValues(\"version\"));\n    /**\r\n     * @type {string}\r\n     * @desc policy\r\n     */\n\n    this.policy = (0, _pvutils.getParametersValue)(parameters, \"policy\", TSTInfo.defaultValues(\"policy\"));\n    /**\r\n     * @type {MessageImprint}\r\n     * @desc messageImprint\r\n     */\n\n    this.messageImprint = (0, _pvutils.getParametersValue)(parameters, \"messageImprint\", TSTInfo.defaultValues(\"messageImprint\"));\n    /**\r\n     * @type {Integer}\r\n     * @desc serialNumber\r\n     */\n\n    this.serialNumber = (0, _pvutils.getParametersValue)(parameters, \"serialNumber\", TSTInfo.defaultValues(\"serialNumber\"));\n    /**\r\n     * @type {Date}\r\n     * @desc genTime\r\n     */\n\n    this.genTime = (0, _pvutils.getParametersValue)(parameters, \"genTime\", TSTInfo.defaultValues(\"genTime\"));\n    if (\"accuracy\" in parameters)\n      /**\r\n       * @type {Accuracy}\r\n       * @desc accuracy\r\n       */\n      this.accuracy = (0, _pvutils.getParametersValue)(parameters, \"accuracy\", TSTInfo.defaultValues(\"accuracy\"));\n    if (\"ordering\" in parameters)\n      /**\r\n       * @type {boolean}\r\n       * @desc ordering\r\n       */\n      this.ordering = (0, _pvutils.getParametersValue)(parameters, \"ordering\", TSTInfo.defaultValues(\"ordering\"));\n    if (\"nonce\" in parameters)\n      /**\r\n       * @type {Integer}\r\n       * @desc nonce\r\n       */\n      this.nonce = (0, _pvutils.getParametersValue)(parameters, \"nonce\", TSTInfo.defaultValues(\"nonce\"));\n    if (\"tsa\" in parameters)\n      /**\r\n       * @type {GeneralName}\r\n       * @desc tsa\r\n       */\n      this.tsa = (0, _pvutils.getParametersValue)(parameters, \"tsa\", TSTInfo.defaultValues(\"tsa\"));\n    if (\"extensions\" in parameters)\n      /**\r\n       * @type {Array.<Extension>}\r\n       * @desc extensions\r\n       */\n      this.extensions = (0, _pvutils.getParametersValue)(parameters, \"extensions\", TSTInfo.defaultValues(\"extensions\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"policy\":\n        return \"\";\n\n      case \"messageImprint\":\n        return new _MessageImprint.default();\n\n      case \"serialNumber\":\n        return new asn1js.Integer();\n\n      case \"genTime\":\n        return new Date(0, 0, 0);\n\n      case \"accuracy\":\n        return new _Accuracy.default();\n\n      case \"ordering\":\n        return false;\n\n      case \"nonce\":\n        return new asn1js.Integer();\n\n      case \"tsa\":\n        return new _GeneralName.default();\n\n      case \"extensions\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for TSTInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n      case \"policy\":\n      case \"genTime\":\n      case \"ordering\":\n        return memberValue === TSTInfo.defaultValues(memberName);\n\n      case \"messageImprint\":\n        return _MessageImprint.default.compareWithDefault(\"hashAlgorithm\", memberValue.hashAlgorithm) && _MessageImprint.default.compareWithDefault(\"hashedMessage\", memberValue.hashedMessage);\n\n      case \"serialNumber\":\n      case \"nonce\":\n        return memberValue.isEqual(TSTInfo.defaultValues(memberName));\n\n      case \"accuracy\":\n        return _Accuracy.default.compareWithDefault(\"seconds\", memberValue.seconds) && _Accuracy.default.compareWithDefault(\"millis\", memberValue.millis) && _Accuracy.default.compareWithDefault(\"micros\", memberValue.micros);\n\n      case \"tsa\":\n        return _GeneralName.default.compareWithDefault(\"type\", memberValue.type) && _GeneralName.default.compareWithDefault(\"value\", memberValue.value);\n\n      case \"extensions\":\n        return memberValue.length === 0;\n\n      default:\n        throw new Error(`Invalid member name for TSTInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * TSTInfo ::= SEQUENCE  {\r\n   *   version                      INTEGER  { v1(1) },\r\n   *   policy                       TSAPolicyId,\r\n   *   messageImprint               MessageImprint,\r\n   *   serialNumber                 INTEGER,\r\n   *   genTime                      GeneralizedTime,\r\n   *   accuracy                     Accuracy                 OPTIONAL,\r\n   *   ordering                     BOOLEAN             DEFAULT FALSE,\r\n   *   nonce                        INTEGER                  OPTIONAL,\r\n   *   tsa                          [0] GeneralName          OPTIONAL,\r\n   *   extensions                   [1] IMPLICIT Extensions  OPTIONAL  }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [policy]\r\n     * @property {string} [messageImprint]\r\n     * @property {string} [serialNumber]\r\n     * @property {string} [genTime]\r\n     * @property {string} [accuracy]\r\n     * @property {string} [ordering]\r\n     * @property {string} [nonce]\r\n     * @property {string} [tsa]\r\n     * @property {string} [extensions]\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"TSTInfo\",\n      value: [new asn1js.Integer({\n        name: names.version || \"TSTInfo.version\"\n      }), new asn1js.ObjectIdentifier({\n        name: names.policy || \"TSTInfo.policy\"\n      }), _MessageImprint.default.schema(names.messageImprint || {\n        names: {\n          blockName: \"TSTInfo.messageImprint\"\n        }\n      }), new asn1js.Integer({\n        name: names.serialNumber || \"TSTInfo.serialNumber\"\n      }), new asn1js.GeneralizedTime({\n        name: names.genTime || \"TSTInfo.genTime\"\n      }), _Accuracy.default.schema(names.accuracy || {\n        names: {\n          blockName: \"TSTInfo.accuracy\"\n        }\n      }), new asn1js.Boolean({\n        name: names.ordering || \"TSTInfo.ordering\",\n        optional: true\n      }), new asn1js.Integer({\n        name: names.nonce || \"TSTInfo.nonce\",\n        optional: true\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [_GeneralName.default.schema(names.tsa || {\n          names: {\n            blockName: \"TSTInfo.tsa\"\n          }\n        })]\n      }), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [new asn1js.Repeated({\n          name: names.extensions || \"TSTInfo.extensions\",\n          value: _Extension.default.schema(names.extension || {})\n        })]\n      }) // IMPLICIT Extensions\n      ]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"TSTInfo.version\", \"TSTInfo.policy\", \"TSTInfo.messageImprint\", \"TSTInfo.serialNumber\", \"TSTInfo.genTime\", \"TSTInfo.accuracy\", \"TSTInfo.ordering\", \"TSTInfo.nonce\", \"TSTInfo.tsa\", \"TSTInfo.extensions\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, TSTInfo.schema());\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for TSTInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result[\"TSTInfo.version\"].valueBlock.valueDec;\n    this.policy = asn1.result[\"TSTInfo.policy\"].valueBlock.toString();\n    this.messageImprint = new _MessageImprint.default({\n      schema: asn1.result[\"TSTInfo.messageImprint\"]\n    });\n    this.serialNumber = asn1.result[\"TSTInfo.serialNumber\"];\n    this.genTime = asn1.result[\"TSTInfo.genTime\"].toDate();\n    if (\"TSTInfo.accuracy\" in asn1.result) this.accuracy = new _Accuracy.default({\n      schema: asn1.result[\"TSTInfo.accuracy\"]\n    });\n    if (\"TSTInfo.ordering\" in asn1.result) this.ordering = asn1.result[\"TSTInfo.ordering\"].valueBlock.value;\n    if (\"TSTInfo.nonce\" in asn1.result) this.nonce = asn1.result[\"TSTInfo.nonce\"];\n    if (\"TSTInfo.tsa\" in asn1.result) this.tsa = new _GeneralName.default({\n      schema: asn1.result[\"TSTInfo.tsa\"]\n    });\n    if (\"TSTInfo.extensions\" in asn1.result) this.extensions = Array.from(asn1.result[\"TSTInfo.extensions\"], element => new _Extension.default({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.Integer({\n      value: this.version\n    }));\n    outputArray.push(new asn1js.ObjectIdentifier({\n      value: this.policy\n    }));\n    outputArray.push(this.messageImprint.toSchema());\n    outputArray.push(this.serialNumber);\n    outputArray.push(new asn1js.GeneralizedTime({\n      valueDate: this.genTime\n    }));\n    if (\"accuracy\" in this) outputArray.push(this.accuracy.toSchema());\n    if (\"ordering\" in this) outputArray.push(new asn1js.Boolean({\n      value: this.ordering\n    }));\n    if (\"nonce\" in this) outputArray.push(this.nonce);\n\n    if (\"tsa\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: [this.tsa.toSchema()]\n      }));\n    } //region Create array of extensions\n\n\n    if (\"extensions\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: Array.from(this.extensions, element => element.toSchema())\n      }));\n    } //endregion\n    //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      version: this.version,\n      policy: this.policy,\n      messageImprint: this.messageImprint.toJSON(),\n      serialNumber: this.serialNumber.toJSON(),\n      genTime: this.genTime\n    };\n    if (\"accuracy\" in this) _object.accuracy = this.accuracy.toJSON();\n    if (\"ordering\" in this) _object.ordering = this.ordering;\n    if (\"nonce\" in this) _object.nonce = this.nonce.toJSON();\n    if (\"tsa\" in this) _object.tsa = this.tsa.toJSON();\n    if (\"extensions\" in this) _object.extensions = Array.from(this.extensions, element => element.toJSON());\n    return _object;\n  } //**********************************************************************************\n\n  /**\r\n   * Verify current TST Info value\r\n   * @param {{data: ArrayBuffer, notBefore: Date, notAfter: Date}} parameters Input parameters\r\n   * @returns {Promise}\r\n   */\n\n\n  verify(parameters = {}) {\n    //region Initial variables\n    let sequence = Promise.resolve();\n    let data;\n    let notBefore = null;\n    let notAfter = null; //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = (0, _common.getCrypto)();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Get initial parameters\n\n    if (\"data\" in parameters) data = parameters.data;else return Promise.reject(\"\\\"data\\\" is a mandatory attribute for TST_INFO verification\");\n    if (\"notBefore\" in parameters) notBefore = parameters.notBefore;\n    if (\"notAfter\" in parameters) notAfter = parameters.notAfter; //endregion\n    //region Check date\n\n    if (notBefore !== null) {\n      if (this.genTime < notBefore) return Promise.reject(\"Generation time for TSTInfo object is less than notBefore value\");\n    }\n\n    if (notAfter !== null) {\n      if (this.genTime > notAfter) return Promise.reject(\"Generation time for TSTInfo object is more than notAfter value\");\n    } //endregion\n    //region Find hashing algorithm\n\n\n    const shaAlgorithm = (0, _common.getAlgorithmByOID)(this.messageImprint.hashAlgorithm.algorithmId);\n    if (\"name\" in shaAlgorithm === false) return Promise.reject(`Unsupported signature algorithm: ${this.messageImprint.hashAlgorithm.algorithmId}`); //endregion\n    //region Calculate message digest for input \"data\" buffer\n    // noinspection JSCheckFunctionSignatures\n\n    sequence = sequence.then(() => crypto.digest(shaAlgorithm.name, new Uint8Array(data))).then(result => (0, _pvutils.isEqualBuffer)(result, this.messageImprint.hashedMessage.valueBlock.valueHex)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = TSTInfo;\n//# sourceMappingURL=TSTInfo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/TSTInfo.js\n// module id = ./node_modules/pkijs/build/TSTInfo.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n//**************************************************************************************\n\n/**\r\n * Class from RFC5280\r\n */\nclass Time {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for Time class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   * @property {number} [type] 0 - UTCTime; 1 - GeneralizedTime; 2 - empty value\r\n   * @property {Date} [value] Value of the TIME class\r\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc 0 - UTCTime; 1 - GeneralizedTime; 2 - empty value\r\n     */\n    this.type = (0, _pvutils.getParametersValue)(parameters, \"type\", Time.defaultValues(\"type\"));\n    /**\r\n     * @type {Date}\r\n     * @desc Value of the TIME class\r\n     */\n\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", Time.defaultValues(\"value\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"type\":\n        return 0;\n\n      case \"value\":\n        return new Date(0, 0, 0);\n\n      default:\n        throw new Error(`Invalid member name for Time class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * Time ::= CHOICE {\r\n      *   utcTime        UTCTime,\r\n      *   generalTime    GeneralizedTime }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @param {boolean} optional Flag that current schema should be optional\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema(parameters = {}, optional = false) {\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [utcTimeName] Name for \"utcTimeName\" choice\r\n     * @property {string} [generalTimeName] Name for \"generalTimeName\" choice\r\n     */\n    const names = (0, _pvutils.getParametersValue)(parameters, \"names\", {});\n    return new asn1js.Choice({\n      optional,\n      value: [new asn1js.UTCTime({\n        name: names.utcTimeName || \"\"\n      }), new asn1js.GeneralizedTime({\n        name: names.generalTimeName || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    (0, _pvutils.clearProps)(schema, [\"utcTimeName\", \"generalTimeName\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, Time.schema({\n      names: {\n        utcTimeName: \"utcTimeName\",\n        generalTimeName: \"generalTimeName\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for Time\"); //endregion\n    //region Get internal properties from parsed schema\n\n    if (\"utcTimeName\" in asn1.result) {\n      this.type = 0;\n      this.value = asn1.result.utcTimeName.toDate();\n    }\n\n    if (\"generalTimeName\" in asn1.result) {\n      this.type = 1;\n      this.value = asn1.result.generalTimeName.toDate();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    let result = {};\n    if (this.type === 0) result = new asn1js.UTCTime({\n      valueDate: this.value\n    });\n    if (this.type === 1) result = new asn1js.GeneralizedTime({\n      valueDate: this.value\n    });\n    return result; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    return {\n      type: this.type,\n      value: this.value\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.default = Time;\n//# sourceMappingURL=Time.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/Time.js\n// module id = ./node_modules/pkijs/build/Time.js\n// module chunks = 0 1 2 3 4","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setEngine = setEngine;\nexports.getEngine = getEngine;\nexports.getCrypto = getCrypto;\nexports.getRandomValues = getRandomValues;\nexports.getOIDByAlgorithm = getOIDByAlgorithm;\nexports.getAlgorithmParameters = getAlgorithmParameters;\nexports.createCMSECDSASignature = createCMSECDSASignature;\nexports.stringPrep = stringPrep;\nexports.createECDSASignatureFromCMS = createECDSASignatureFromCMS;\nexports.getAlgorithmByOID = getAlgorithmByOID;\nexports.getHashAlgorithm = getHashAlgorithm;\nexports.kdfWithCounter = kdfWithCounter;\nexports.kdf = kdf;\n\nvar asn1js = _interopRequireWildcard(require(\"asn1js\"));\n\nvar _pvutils = require(\"pvutils\");\n\nvar _CryptoEngine = _interopRequireDefault(require(\"./CryptoEngine.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n//**************************************************************************************\n//region Crypto engine related function\n//**************************************************************************************\nlet engine = {\n  name: \"none\",\n  crypto: null,\n  subtle: null\n}; //**************************************************************************************\n\nfunction setEngine(name, crypto, subtle) {\n  //region We are in Node\n  // noinspection JSUnresolvedVariable\n  if (typeof process !== \"undefined\" && \"pid\" in process && typeof global !== \"undefined\" && typeof window === \"undefined\") {\n    // noinspection ES6ModulesDependencies, JSUnresolvedVariable\n    if (typeof global[process.pid] === \"undefined\") {\n      // noinspection JSUnresolvedVariable\n      global[process.pid] = {};\n    } else {\n      // noinspection JSUnresolvedVariable\n      if (typeof global[process.pid] !== \"object\") {\n        // noinspection JSUnresolvedVariable\n        throw new Error(`Name global.${process.pid} already exists and it is not an object`);\n      }\n    } // noinspection JSUnresolvedVariable\n\n\n    if (typeof global[process.pid].pkijs === \"undefined\") {\n      // noinspection JSUnresolvedVariable\n      global[process.pid].pkijs = {};\n    } else {\n      // noinspection JSUnresolvedVariable\n      if (typeof global[process.pid].pkijs !== \"object\") {\n        // noinspection JSUnresolvedVariable\n        throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);\n      }\n    } // noinspection JSUnresolvedVariable\n\n\n    global[process.pid].pkijs.engine = {\n      name: name,\n      crypto: crypto,\n      subtle: subtle\n    };\n  } //endregion\n  //region We are in browser\n  else {\n      if (engine.name !== name) {\n        engine = {\n          name: name,\n          crypto: crypto,\n          subtle: subtle\n        };\n      }\n    } //endregion\n\n} //**************************************************************************************\n\n\nfunction getEngine() {\n  //region We are in Node\n  // noinspection JSUnresolvedVariable\n  if (typeof process !== \"undefined\" && \"pid\" in process && typeof global !== \"undefined\" && typeof window === \"undefined\") {\n    let _engine;\n\n    try {\n      // noinspection JSUnresolvedVariable\n      _engine = global[process.pid].pkijs.engine;\n    } catch (ex) {\n      throw new Error(\"Please call \\\"setEngine\\\" before call to \\\"getEngine\\\"\");\n    }\n\n    return _engine;\n  } //endregion\n\n\n  return engine;\n} //**************************************************************************************\n\n\n(function initCryptoEngine() {\n  if (typeof self !== \"undefined\") {\n    if (\"crypto\" in self) {\n      let engineName = \"webcrypto\";\n      /**\r\n       * Standard crypto object\r\n       * @type {Object}\r\n       * @property {Object} [webkitSubtle] Subtle object from Apple\r\n       */\n\n      const cryptoObject = self.crypto;\n      let subtleObject; // Apple Safari support\n\n      if (\"webkitSubtle\" in self.crypto) {\n        try {\n          subtleObject = self.crypto.webkitSubtle;\n        } catch (ex) {\n          subtleObject = self.crypto.subtle;\n        }\n\n        engineName = \"safari\";\n      }\n\n      if (\"subtle\" in self.crypto) subtleObject = self.crypto.subtle;\n\n      if (typeof subtleObject === \"undefined\") {\n        engine = {\n          name: engineName,\n          crypto: cryptoObject,\n          subtle: null\n        };\n      } else {\n        engine = {\n          name: engineName,\n          crypto: cryptoObject,\n          subtle: new _CryptoEngine.default({\n            name: engineName,\n            crypto: self.crypto,\n            subtle: subtleObject\n          })\n        };\n      }\n    }\n  }\n\n  setEngine(engine.name, engine.crypto, engine.subtle);\n})(); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of common functions\n//**************************************************************************************\n\n/**\r\n * Get crypto subtle from current \"crypto engine\" or \"undefined\"\r\n * @returns {({decrypt, deriveKey, digest, encrypt, exportKey, generateKey, importKey, sign, unwrapKey, verify, wrapKey}|null)}\r\n */\n\n\nfunction getCrypto() {\n  const _engine = getEngine();\n\n  if (_engine.subtle !== null) return _engine.subtle;\n  return undefined;\n} //**************************************************************************************\n\n/**\r\n * Initialize input Uint8Array by random values (with help from current \"crypto engine\")\r\n * @param {!Uint8Array} view\r\n * @returns {*}\r\n */\n\n\nfunction getRandomValues(view) {\n  return getEngine().subtle.getRandomValues(view);\n} //**************************************************************************************\n\n/**\r\n * Get OID for each specific algorithm\r\n * @param {Object} algorithm\r\n * @returns {string}\r\n */\n\n\nfunction getOIDByAlgorithm(algorithm) {\n  return getEngine().subtle.getOIDByAlgorithm(algorithm);\n} //**************************************************************************************\n\n/**\r\n * Get default algorithm parameters for each kind of operation\r\n * @param {string} algorithmName Algorithm name to get common parameters for\r\n * @param {string} operation Kind of operation: \"sign\", \"encrypt\", \"generatekey\", \"importkey\", \"exportkey\", \"verify\"\r\n * @returns {*}\r\n */\n\n\nfunction getAlgorithmParameters(algorithmName, operation) {\n  return getEngine().subtle.getAlgorithmParameters(algorithmName, operation);\n} //**************************************************************************************\n\n/**\r\n * Create CMS ECDSA signature from WebCrypto ECDSA signature\r\n * @param {ArrayBuffer} signatureBuffer WebCrypto result of \"sign\" function\r\n * @returns {ArrayBuffer}\r\n */\n\n\nfunction createCMSECDSASignature(signatureBuffer) {\n  //region Initial check for correct length\n  if (signatureBuffer.byteLength % 2 !== 0) return new ArrayBuffer(0); //endregion\n  //region Initial variables\n\n  const length = signatureBuffer.byteLength / 2; // There are two equal parts inside incoming ArrayBuffer\n\n  const rBuffer = new ArrayBuffer(length);\n  const rView = new Uint8Array(rBuffer);\n  rView.set(new Uint8Array(signatureBuffer, 0, length));\n  const rInteger = new asn1js.Integer({\n    valueHex: rBuffer\n  });\n  const sBuffer = new ArrayBuffer(length);\n  const sView = new Uint8Array(sBuffer);\n  sView.set(new Uint8Array(signatureBuffer, length, length));\n  const sInteger = new asn1js.Integer({\n    valueHex: sBuffer\n  }); //endregion\n\n  return new asn1js.Sequence({\n    value: [rInteger.convertToDER(), sInteger.convertToDER()]\n  }).toBER(false);\n} //**************************************************************************************\n\n/**\r\n * String preparation function. In a future here will be realization of algorithm from RFC4518\r\n * @param {string} inputString JavaScript string. As soon as for each ASN.1 string type we have a specific transformation function here we will work with pure JavaScript string\r\n * @returns {string} Formated string\r\n */\n\n\nfunction stringPrep(inputString) {\n  //region Initial variables\n  let isSpace = false;\n  let cuttedResult = \"\"; //endregion\n\n  const result = inputString.trim(); // Trim input string\n  //region Change all sequence of SPACE down to SPACE char\n\n  for (let i = 0; i < result.length; i++) {\n    if (result.charCodeAt(i) === 32) {\n      if (isSpace === false) isSpace = true;\n    } else {\n      if (isSpace) {\n        cuttedResult += \" \";\n        isSpace = false;\n      }\n\n      cuttedResult += result[i];\n    }\n  } //endregion\n\n\n  return cuttedResult.toLowerCase();\n} //**************************************************************************************\n\n/**\r\n * Create a single ArrayBuffer from CMS ECDSA signature\r\n * @param {Sequence} cmsSignature ASN.1 SEQUENCE contains CMS ECDSA signature\r\n * @returns {ArrayBuffer}\r\n */\n\n\nfunction createECDSASignatureFromCMS(cmsSignature) {\n  //region Check input variables\n  if (cmsSignature instanceof asn1js.Sequence === false) return new ArrayBuffer(0);\n  if (cmsSignature.valueBlock.value.length !== 2) return new ArrayBuffer(0);\n  if (cmsSignature.valueBlock.value[0] instanceof asn1js.Integer === false) return new ArrayBuffer(0);\n  if (cmsSignature.valueBlock.value[1] instanceof asn1js.Integer === false) return new ArrayBuffer(0); //endregion\n\n  const rValue = cmsSignature.valueBlock.value[0].convertFromDER();\n  const sValue = cmsSignature.valueBlock.value[1].convertFromDER(); //region Check the lengths of two parts are equal\n\n  switch (true) {\n    case rValue.valueBlock.valueHex.byteLength < sValue.valueBlock.valueHex.byteLength:\n      {\n        if (sValue.valueBlock.valueHex.byteLength - rValue.valueBlock.valueHex.byteLength !== 1) throw new Error(\"Incorrect DER integer decoding\");\n        const correctedLength = sValue.valueBlock.valueHex.byteLength;\n        const rValueView = new Uint8Array(rValue.valueBlock.valueHex);\n        const rValueBufferCorrected = new ArrayBuffer(correctedLength);\n        const rValueViewCorrected = new Uint8Array(rValueBufferCorrected);\n        rValueViewCorrected.set(rValueView, 1);\n        rValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here\n\n        return (0, _pvutils.utilConcatBuf)(rValueBufferCorrected, sValue.valueBlock.valueHex);\n      }\n\n    case rValue.valueBlock.valueHex.byteLength > sValue.valueBlock.valueHex.byteLength:\n      {\n        if (rValue.valueBlock.valueHex.byteLength - sValue.valueBlock.valueHex.byteLength !== 1) throw new Error(\"Incorrect DER integer decoding\");\n        const correctedLength = rValue.valueBlock.valueHex.byteLength;\n        const sValueView = new Uint8Array(sValue.valueBlock.valueHex);\n        const sValueBufferCorrected = new ArrayBuffer(correctedLength);\n        const sValueViewCorrected = new Uint8Array(sValueBufferCorrected);\n        sValueViewCorrected.set(sValueView, 1);\n        sValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here\n\n        return (0, _pvutils.utilConcatBuf)(rValue.valueBlock.valueHex, sValueBufferCorrected);\n      }\n\n    default:\n      {\n        //region In case we have equal length and the length is not even with 2\n        if (rValue.valueBlock.valueHex.byteLength % 2) {\n          const correctedLength = rValue.valueBlock.valueHex.byteLength + 1;\n          const rValueView = new Uint8Array(rValue.valueBlock.valueHex);\n          const rValueBufferCorrected = new ArrayBuffer(correctedLength);\n          const rValueViewCorrected = new Uint8Array(rValueBufferCorrected);\n          rValueViewCorrected.set(rValueView, 1);\n          rValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here\n\n          const sValueView = new Uint8Array(sValue.valueBlock.valueHex);\n          const sValueBufferCorrected = new ArrayBuffer(correctedLength);\n          const sValueViewCorrected = new Uint8Array(sValueBufferCorrected);\n          sValueViewCorrected.set(sValueView, 1);\n          sValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here\n\n          return (0, _pvutils.utilConcatBuf)(rValueBufferCorrected, sValueBufferCorrected);\n        } //endregion\n\n      }\n  } //endregion\n\n\n  return (0, _pvutils.utilConcatBuf)(rValue.valueBlock.valueHex, sValue.valueBlock.valueHex);\n} //**************************************************************************************\n\n/**\r\n * Get WebCrypto algorithm by wel-known OID\r\n * @param {string} oid well-known OID to search for\r\n * @returns {Object}\r\n */\n\n\nfunction getAlgorithmByOID(oid) {\n  return getEngine().subtle.getAlgorithmByOID(oid);\n} //**************************************************************************************\n\n/**\r\n * Getting hash algorithm by signature algorithm\r\n * @param {AlgorithmIdentifier} signatureAlgorithm Signature algorithm\r\n * @returns {string}\r\n */\n\n\nfunction getHashAlgorithm(signatureAlgorithm) {\n  return getEngine().subtle.getHashAlgorithm(signatureAlgorithm);\n} //**************************************************************************************\n\n/**\r\n * ANS X9.63 Key Derivation Function having a \"Counter\" as a parameter\r\n * @param {string} hashFunction Used hash function\r\n * @param {ArrayBuffer} Zbuffer ArrayBuffer containing ECDH shared secret to derive from\r\n * @param {number} Counter\r\n * @param {ArrayBuffer} SharedInfo Usually DER encoded \"ECC_CMS_SharedInfo\" structure\r\n */\n\n\nfunction kdfWithCounter(hashFunction, Zbuffer, Counter, SharedInfo) {\n  //region Check of input parameters\n  switch (hashFunction.toUpperCase()) {\n    case \"SHA-1\":\n    case \"SHA-256\":\n    case \"SHA-384\":\n    case \"SHA-512\":\n      break;\n\n    default:\n      return Promise.reject(`Unknown hash function: ${hashFunction}`);\n  }\n\n  if (Zbuffer instanceof ArrayBuffer === false) return Promise.reject(\"Please set \\\"Zbuffer\\\" as \\\"ArrayBuffer\\\"\");\n  if (Zbuffer.byteLength === 0) return Promise.reject(\"\\\"Zbuffer\\\" has zero length, error\");\n  if (SharedInfo instanceof ArrayBuffer === false) return Promise.reject(\"Please set \\\"SharedInfo\\\" as \\\"ArrayBuffer\\\"\");\n  if (Counter > 255) return Promise.reject(\"Please set \\\"Counter\\\" variable to value less or equal to 255\"); //endregion\n  //region Initial variables\n\n  const counterBuffer = new ArrayBuffer(4);\n  const counterView = new Uint8Array(counterBuffer);\n  counterView[0] = 0x00;\n  counterView[1] = 0x00;\n  counterView[2] = 0x00;\n  counterView[3] = Counter;\n  let combinedBuffer = new ArrayBuffer(0); //endregion\n  //region Get a \"crypto\" extension\n\n  const crypto = getCrypto();\n  if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n  //region Create a combined ArrayBuffer for digesting\n\n  combinedBuffer = (0, _pvutils.utilConcatBuf)(combinedBuffer, Zbuffer);\n  combinedBuffer = (0, _pvutils.utilConcatBuf)(combinedBuffer, counterBuffer);\n  combinedBuffer = (0, _pvutils.utilConcatBuf)(combinedBuffer, SharedInfo); //endregion\n  //region Return digest of combined ArrayBuffer and information about current counter\n\n  return crypto.digest({\n    name: hashFunction\n  }, combinedBuffer).then(result => ({\n    counter: Counter,\n    result\n  })); //endregion\n} //**************************************************************************************\n\n/**\r\n * ANS X9.63 Key Derivation Function\r\n * @param {string} hashFunction Used hash function\r\n * @param {ArrayBuffer} Zbuffer ArrayBuffer containing ECDH shared secret to derive from\r\n * @param {number} keydatalen Length (!!! in BITS !!!) of used kew derivation function\r\n * @param {ArrayBuffer} SharedInfo Usually DER encoded \"ECC_CMS_SharedInfo\" structure\r\n */\n\n\nfunction kdf(hashFunction, Zbuffer, keydatalen, SharedInfo) {\n  //region Initial variables\n  let hashLength = 0;\n  let maxCounter = 1;\n  const kdfArray = []; //endregion\n  //region Check of input parameters\n\n  switch (hashFunction.toUpperCase()) {\n    case \"SHA-1\":\n      hashLength = 160; // In bits\n\n      break;\n\n    case \"SHA-256\":\n      hashLength = 256; // In bits\n\n      break;\n\n    case \"SHA-384\":\n      hashLength = 384; // In bits\n\n      break;\n\n    case \"SHA-512\":\n      hashLength = 512; // In bits\n\n      break;\n\n    default:\n      return Promise.reject(`Unknown hash function: ${hashFunction}`);\n  }\n\n  if (Zbuffer instanceof ArrayBuffer === false) return Promise.reject(\"Please set \\\"Zbuffer\\\" as \\\"ArrayBuffer\\\"\");\n  if (Zbuffer.byteLength === 0) return Promise.reject(\"\\\"Zbuffer\\\" has zero length, error\");\n  if (SharedInfo instanceof ArrayBuffer === false) return Promise.reject(\"Please set \\\"SharedInfo\\\" as \\\"ArrayBuffer\\\"\"); //endregion\n  //region Calculated maximum value of \"Counter\" variable\n\n  const quotient = keydatalen / hashLength;\n\n  if (Math.floor(quotient) > 0) {\n    maxCounter = Math.floor(quotient);\n    if (quotient - maxCounter > 0) maxCounter++;\n  } //endregion\n  //region Create an array of \"kdfWithCounter\"\n\n\n  for (let i = 1; i <= maxCounter; i++) kdfArray.push(kdfWithCounter(hashFunction, Zbuffer, i, SharedInfo)); //endregion\n  //region Return combined digest with specified length\n\n\n  return Promise.all(kdfArray).then(incomingResult => {\n    //region Initial variables\n    let combinedBuffer = new ArrayBuffer(0);\n    let currentCounter = 1;\n    let found = true; //endregion\n    //region Combine all buffer together\n\n    while (found) {\n      found = false;\n\n      var _iterator = _createForOfIteratorHelper(incomingResult),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          const result = _step.value;\n\n          if (result.counter === currentCounter) {\n            combinedBuffer = (0, _pvutils.utilConcatBuf)(combinedBuffer, result.result);\n            found = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      currentCounter++;\n    } //endregion\n    //region Create output buffer with specified length\n\n\n    keydatalen >>= 3; // Divide by 8 since \"keydatalen\" is in bits\n\n    if (combinedBuffer.byteLength > keydatalen) {\n      const newBuffer = new ArrayBuffer(keydatalen);\n      const newView = new Uint8Array(newBuffer);\n      const combinedView = new Uint8Array(combinedBuffer);\n\n      for (let i = 0; i < keydatalen; i++) newView[i] = combinedView[i];\n\n      return newBuffer;\n    }\n\n    return combinedBuffer; // Since the situation when \"combinedBuffer.byteLength < keydatalen\" here we have only \"combinedBuffer.byteLength === keydatalen\"\n    //endregion\n  }); //endregion\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//# sourceMappingURL=common.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pkijs/build/common.js\n// module id = ./node_modules/pkijs/build/common.js\n// module chunks = 0 1 2 3 4","/**\n * Copyright (c) 2020, Peculiar Ventures, All rights reserved.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pvtsutils = {}));\n}(this, (function (exports) { 'use strict';\n\n  class BufferSourceConverter {\r\n      static isArrayBuffer(data) {\r\n          return Object.prototype.toString.call(data) === '[object ArrayBuffer]';\r\n      }\r\n      static toArrayBuffer(data) {\r\n          const buf = this.toUint8Array(data);\r\n          if (buf.byteOffset || buf.length) {\r\n              return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\r\n          }\r\n          return buf.buffer;\r\n      }\r\n      static toUint8Array(data) {\r\n          if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(data)) {\r\n              return new Uint8Array(data);\r\n          }\r\n          if (ArrayBuffer.isView(data)) {\r\n              return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n          }\r\n          if (this.isArrayBuffer(data)) {\r\n              return new Uint8Array(data);\r\n          }\r\n          throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\r\n      }\r\n      static isBufferSource(data) {\r\n          return this.isArrayBufferView(data)\r\n              || this.isArrayBuffer(data);\r\n      }\r\n      static isArrayBufferView(data) {\r\n          return ArrayBuffer.isView(data)\r\n              || (data && this.isArrayBuffer(data.buffer));\r\n      }\r\n  }\n\n  function PrepareBuffer(buffer) {\r\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(buffer)) {\r\n          return new Uint8Array(buffer);\r\n      }\r\n      else if (BufferSourceConverter.isArrayBufferView(buffer)) {\r\n          return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\r\n      }\r\n      else {\r\n          return new Uint8Array(buffer);\r\n      }\r\n  }\r\n  class Convert {\r\n      static isHex(data) {\r\n          return typeof data === \"string\"\r\n              && /^[a-z0-9]+$/i.test(data);\r\n      }\r\n      static isBase64(data) {\r\n          return typeof data === \"string\"\r\n              && /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(data);\r\n      }\r\n      static isBase64Url(data) {\r\n          return typeof data === \"string\"\r\n              && /^[a-zA-Z0-9-_]+$/i.test(data);\r\n      }\r\n      static ToString(buffer, enc = \"utf8\") {\r\n          const buf = PrepareBuffer(buffer);\r\n          switch (enc.toLowerCase()) {\r\n              case \"utf8\":\r\n                  return this.ToUtf8String(buf);\r\n              case \"binary\":\r\n                  return this.ToBinary(buf);\r\n              case \"hex\":\r\n                  return this.ToHex(buf);\r\n              case \"base64\":\r\n                  return this.ToBase64(buf);\r\n              case \"base64url\":\r\n                  return this.ToBase64Url(buf);\r\n              default:\r\n                  throw new Error(`Unknown type of encoding '${enc}'`);\r\n          }\r\n      }\r\n      static FromString(str, enc = \"utf8\") {\r\n          if (!str) {\r\n              return new ArrayBuffer(0);\r\n          }\r\n          switch (enc.toLowerCase()) {\r\n              case \"utf8\":\r\n                  return this.FromUtf8String(str);\r\n              case \"binary\":\r\n                  return this.FromBinary(str);\r\n              case \"hex\":\r\n                  return this.FromHex(str);\r\n              case \"base64\":\r\n                  return this.FromBase64(str);\r\n              case \"base64url\":\r\n                  return this.FromBase64Url(str);\r\n              default:\r\n                  throw new Error(`Unknown type of encoding '${enc}'`);\r\n          }\r\n      }\r\n      static ToBase64(buffer) {\r\n          const buf = PrepareBuffer(buffer);\r\n          if (typeof btoa !== \"undefined\") {\r\n              const binary = this.ToString(buf, \"binary\");\r\n              return btoa(binary);\r\n          }\r\n          else {\r\n              return Buffer.from(buf).toString(\"base64\");\r\n          }\r\n      }\r\n      static FromBase64(base64) {\r\n          const formatted = this.formatString(base64);\r\n          if (!formatted) {\r\n              return new ArrayBuffer(0);\r\n          }\r\n          if (!Convert.isBase64(formatted)) {\r\n              throw new TypeError(\"Argument 'base64Text' is not Base64 encoded\");\r\n          }\r\n          if (typeof atob !== \"undefined\") {\r\n              return this.FromBinary(atob(formatted));\r\n          }\r\n          else {\r\n              return new Uint8Array(Buffer.from(formatted, \"base64\")).buffer;\r\n          }\r\n      }\r\n      static FromBase64Url(base64url) {\r\n          const formatted = this.formatString(base64url);\r\n          if (!formatted) {\r\n              return new ArrayBuffer(0);\r\n          }\r\n          if (!Convert.isBase64Url(formatted)) {\r\n              throw new TypeError(\"Argument 'base64url' is not Base64Url encoded\");\r\n          }\r\n          return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\r\n      }\r\n      static ToBase64Url(data) {\r\n          return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\r\n      }\r\n      static FromUtf8String(text) {\r\n          const s = unescape(encodeURIComponent(text));\r\n          const uintArray = new Uint8Array(s.length);\r\n          for (let i = 0; i < s.length; i++) {\r\n              uintArray[i] = s.charCodeAt(i);\r\n          }\r\n          return uintArray.buffer;\r\n      }\r\n      static ToUtf8String(buffer) {\r\n          const buf = PrepareBuffer(buffer);\r\n          const encodedString = String.fromCharCode.apply(null, buf);\r\n          const decodedString = decodeURIComponent(escape(encodedString));\r\n          return decodedString;\r\n      }\r\n      static FromBinary(text) {\r\n          const stringLength = text.length;\r\n          const resultView = new Uint8Array(stringLength);\r\n          for (let i = 0; i < stringLength; i++) {\r\n              resultView[i] = text.charCodeAt(i);\r\n          }\r\n          return resultView.buffer;\r\n      }\r\n      static ToBinary(buffer) {\r\n          const buf = PrepareBuffer(buffer);\r\n          let resultString = \"\";\r\n          const len = buf.length;\r\n          for (let i = 0; i < len; i++) {\r\n              resultString = resultString + String.fromCharCode(buf[i]);\r\n          }\r\n          return resultString;\r\n      }\r\n      static ToHex(buffer) {\r\n          const buf = PrepareBuffer(buffer);\r\n          const splitter = \"\";\r\n          const res = [];\r\n          const len = buf.length;\r\n          for (let i = 0; i < len; i++) {\r\n              const char = buf[i].toString(16);\r\n              res.push(char.length === 1 ? \"0\" + char : char);\r\n          }\r\n          return res.join(splitter);\r\n      }\r\n      static FromHex(hexString) {\r\n          let formatted = this.formatString(hexString);\r\n          if (!formatted) {\r\n              return new ArrayBuffer(0);\r\n          }\r\n          if (!Convert.isHex(formatted)) {\r\n              throw new TypeError(\"Argument 'hexString' is not HEX encoded\");\r\n          }\r\n          if (formatted.length % 2) {\r\n              formatted = `0${formatted}`;\r\n          }\r\n          const res = new Uint8Array(formatted.length / 2);\r\n          for (let i = 0; i < formatted.length; i = i + 2) {\r\n              const c = formatted.slice(i, i + 2);\r\n              res[i / 2] = parseInt(c, 16);\r\n          }\r\n          return res.buffer;\r\n      }\r\n      static Base64Padding(base64) {\r\n          const padCount = 4 - (base64.length % 4);\r\n          if (padCount < 4) {\r\n              for (let i = 0; i < padCount; i++) {\r\n                  base64 += \"=\";\r\n              }\r\n          }\r\n          return base64;\r\n      }\r\n      static formatString(data) {\r\n          return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, \"\")) || \"\";\r\n      }\r\n  }\n\n  function assign(target, ...sources) {\r\n      const res = arguments[0];\r\n      for (let i = 1; i < arguments.length; i++) {\r\n          const obj = arguments[i];\r\n          for (const prop in obj) {\r\n              res[prop] = obj[prop];\r\n          }\r\n      }\r\n      return res;\r\n  }\r\n  function combine(...buf) {\r\n      const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);\r\n      const res = new Uint8Array(totalByteLength);\r\n      let currentPos = 0;\r\n      buf.map((item) => new Uint8Array(item)).forEach((arr) => {\r\n          for (const item2 of arr) {\r\n              res[currentPos++] = item2;\r\n          }\r\n      });\r\n      return res.buffer;\r\n  }\r\n  function isEqual(bytes1, bytes2) {\r\n      if (!(bytes1 && bytes2)) {\r\n          return false;\r\n      }\r\n      if (bytes1.byteLength !== bytes2.byteLength) {\r\n          return false;\r\n      }\r\n      const b1 = new Uint8Array(bytes1);\r\n      const b2 = new Uint8Array(bytes2);\r\n      for (let i = 0; i < bytes1.byteLength; i++) {\r\n          if (b1[i] !== b2[i]) {\r\n              return false;\r\n          }\r\n      }\r\n      return true;\r\n  }\n\n  exports.BufferSourceConverter = BufferSourceConverter;\n  exports.Convert = Convert;\n  exports.assign = assign;\n  exports.combine = combine;\n  exports.isEqual = isEqual;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pvtsutils/build/index.js\n// module id = ./node_modules/pvtsutils/build/index.js\n// module chunks = 0 1 2 3 4","//**************************************************************************************\r\n/**\r\n * Making UTC date from local date\r\n * @param {Date} date Date to convert from\r\n * @returns {Date}\r\n */\r\nexport function getUTCDate(date)\r\n{\r\n\t// noinspection NestedFunctionCallJS, MagicNumberJS\r\n\treturn new Date(date.getTime() + (date.getTimezoneOffset() * 60000));\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Get value for input parameters, or set a default value\r\n * @param {Object} parameters\r\n * @param {string} name\r\n * @param defaultValue\r\n */\r\nexport function getParametersValue(parameters, name, defaultValue)\r\n{\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\r\n\tif((parameters instanceof Object) === false)\r\n\t\treturn defaultValue;\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tif(name in parameters)\r\n\t\treturn parameters[name];\r\n\t\r\n\treturn defaultValue;\r\n}\r\n//**************************************************************************************\r\n/**\r\n * Converts \"ArrayBuffer\" into a hexdecimal string\r\n * @param {ArrayBuffer} inputBuffer\r\n * @param {number} [inputOffset=0]\r\n * @param {number} [inputLength=inputBuffer.byteLength]\r\n * @param {boolean} [insertSpace=false]\r\n * @returns {string}\r\n */\r\nexport function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false)\r\n{\r\n\tlet result = \"\";\r\n\t\r\n\tfor(const item of (new Uint8Array(inputBuffer, inputOffset, inputLength)))\r\n\t{\r\n\t\t// noinspection ChainedFunctionCallJS\r\n\t\tconst str = item.toString(16).toUpperCase();\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif(str.length === 1)\r\n\t\t\tresult += \"0\";\r\n\t\t\r\n\t\tresult += str;\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(insertSpace)\r\n\t\t\tresult += \" \";\r\n\t}\r\n\t\r\n\treturn result.trim();\r\n}\r\n//**************************************************************************************\r\n// noinspection JSValidateJSDoc, FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Check input \"ArrayBuffer\" for common functions\r\n * @param {LocalBaseBlock} baseBlock\r\n * @param {ArrayBuffer} inputBuffer\r\n * @param {number} inputOffset\r\n * @param {number} inputLength\r\n * @returns {boolean}\r\n */\r\nexport function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)\r\n{\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif((inputBuffer instanceof ArrayBuffer) === false)\r\n\t{\r\n\t\t// noinspection JSUndefinedPropertyAssignment\r\n\t\tbaseBlock.error = \"Wrong parameter: inputBuffer must be \\\"ArrayBuffer\\\"\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif(inputBuffer.byteLength === 0)\r\n\t{\r\n\t\t// noinspection JSUndefinedPropertyAssignment\r\n\t\tbaseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif(inputOffset < 0)\r\n\t{\r\n\t\t// noinspection JSUndefinedPropertyAssignment\r\n\t\tbaseBlock.error = \"Wrong parameter: inputOffset less than zero\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif(inputLength < 0)\r\n\t{\r\n\t\t// noinspection JSUndefinedPropertyAssignment\r\n\t\tbaseBlock.error = \"Wrong parameter: inputLength less than zero\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif((inputBuffer.byteLength - inputOffset - inputLength) < 0)\r\n\t{\r\n\t\t// noinspection JSUndefinedPropertyAssignment\r\n\t\tbaseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\treturn true;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Convert number from 2^base to 2^10\r\n * @param {Uint8Array} inputBuffer\r\n * @param {number} inputBase\r\n * @returns {number}\r\n */\r\nexport function utilFromBase(inputBuffer, inputBase)\r\n{\r\n\tlet result = 0;\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\r\n\tif(inputBuffer.length === 1)\r\n\t\treturn inputBuffer[0];\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\r\n\tfor(let i = (inputBuffer.length - 1); i >= 0; i--)\r\n\t\tresult += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);\r\n\t\r\n\treturn result;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Convert number from 2^10 to 2^base\r\n * @param {!number} value The number to convert\r\n * @param {!number} base The base for 2^base\r\n * @param {number} [reserved=0] Pre-defined number of bytes in output array (-1 = limited by function itself)\r\n * @returns {ArrayBuffer}\r\n */\r\nexport function utilToBase(value, base, reserved = (-1))\r\n{\r\n\tconst internalReserved = reserved;\r\n\tlet internalValue = value;\r\n\t\r\n\tlet result = 0;\r\n\tlet biggest = Math.pow(2, base);\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tfor(let i = 1; i < 8; i++)\r\n\t{\r\n\t\tif(value < biggest)\r\n\t\t{\r\n\t\t\tlet retBuf;\r\n\t\t\t\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tif(internalReserved < 0)\r\n\t\t\t{\r\n\t\t\t\tretBuf = new ArrayBuffer(i);\r\n\t\t\t\tresult = i;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\tif(internalReserved < i)\r\n\t\t\t\t\treturn (new ArrayBuffer(0));\r\n\t\t\t\t\r\n\t\t\t\tretBuf = new ArrayBuffer(internalReserved);\r\n\t\t\t\t\r\n\t\t\t\tresult = internalReserved;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst retView = new Uint8Array(retBuf);\r\n\t\t\t\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tfor(let j = (i - 1); j >= 0; j--)\r\n\t\t\t{\r\n\t\t\t\tconst basis = Math.pow(2, j * base);\r\n\t\t\t\t\r\n\t\t\t\tretView[result - j - 1] = Math.floor(internalValue / basis);\r\n\t\t\t\tinternalValue -= (retView[result - j - 1]) * basis;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn retBuf;\r\n\t\t}\r\n\t\t\r\n\t\tbiggest *= Math.pow(2, base);\r\n\t}\r\n\t\r\n\treturn new ArrayBuffer(0);\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS\r\n/**\r\n * Concatenate two ArrayBuffers\r\n * @param {...ArrayBuffer} buffers Set of ArrayBuffer\r\n */\r\nexport function utilConcatBuf(...buffers)\r\n{\r\n\t//region Initial variables\r\n\tlet outputLength = 0;\r\n\tlet prevLength = 0;\r\n\t//endregion\r\n\t\r\n\t//region Calculate output length\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(const buffer of buffers)\r\n\t\toutputLength += buffer.byteLength;\r\n\t//endregion\r\n\t\r\n\tconst retBuf = new ArrayBuffer(outputLength);\r\n\tconst retView = new Uint8Array(retBuf);\r\n\t\r\n\tfor(const buffer of buffers)\r\n\t{\r\n\t\t// noinspection NestedFunctionCallJS\r\n\t\tretView.set(new Uint8Array(buffer), prevLength);\r\n\t\tprevLength += buffer.byteLength;\r\n\t}\r\n\t\r\n\treturn retBuf;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS\r\n/**\r\n * Concatenate two Uint8Array\r\n * @param {...Uint8Array} views Set of Uint8Array\r\n */\r\nexport function utilConcatView(...views)\r\n{\r\n\t//region Initial variables\r\n\tlet outputLength = 0;\r\n\tlet prevLength = 0;\r\n\t//endregion\r\n\t\r\n\t//region Calculate output length\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(const view of views)\r\n\t\toutputLength += view.length;\r\n\t//endregion\r\n\t\r\n\tconst retBuf = new ArrayBuffer(outputLength);\r\n\tconst retView = new Uint8Array(retBuf);\r\n\t\r\n\tfor(const view of views)\r\n\t{\r\n\t\tretView.set(view, prevLength);\r\n\t\tprevLength += view.length;\r\n\t}\r\n\t\r\n\treturn retView;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS\r\n/**\r\n * Decoding of \"two complement\" values\r\n * The function must be called in scope of instance of \"hexBlock\" class (\"valueHex\" and \"warnings\" properties must be present)\r\n * @returns {number}\r\n */\r\nexport function utilDecodeTC()\r\n{\r\n\tconst buf = new Uint8Array(this.valueHex);\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif(this.valueHex.byteLength >= 2)\r\n\t{\r\n\t\t//noinspection JSBitwiseOperatorUsage, ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(condition1 || condition2)\r\n\t\t\tthis.warnings.push(\"Needlessly long format\");\r\n\t}\r\n\t\r\n\t//region Create big part of the integer\r\n\tconst bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\r\n\tconst bigIntView = new Uint8Array(bigIntBuffer);\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(let i = 0; i < this.valueHex.byteLength; i++)\r\n\t\tbigIntView[i] = 0;\r\n\t\r\n\t// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\tbigIntView[0] = (buf[0] & 0x80); // mask only the biggest bit\r\n\t\r\n\tconst bigInt = utilFromBase(bigIntView, 8);\r\n\t//endregion\r\n\t\r\n\t//region Create small part of the integer\r\n\tconst smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\r\n\tconst smallIntView = new Uint8Array(smallIntBuffer);\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(let j = 0; j < this.valueHex.byteLength; j++)\r\n\t\tsmallIntView[j] = buf[j];\r\n\t\r\n\t// noinspection MagicNumberJS\r\n\tsmallIntView[0] &= 0x7F; // mask biggest bit\r\n\t\r\n\tconst smallInt = utilFromBase(smallIntView, 8);\r\n\t//endregion\r\n\t\r\n\treturn (smallInt - bigInt);\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Encode integer value to \"two complement\" format\r\n * @param {number} value Value to encode\r\n * @returns {ArrayBuffer}\r\n */\r\nexport function utilEncodeTC(value)\r\n{\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS\r\n\tconst modValue = (value < 0) ? (value * (-1)) : value;\r\n\tlet bigInt = 128;\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tfor(let i = 1; i < 8; i++)\r\n\t{\r\n\t\tif(modValue <= bigInt)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tif(value < 0)\r\n\t\t\t{\r\n\t\t\t\tconst smallInt = bigInt - modValue;\r\n\t\t\t\t\r\n\t\t\t\tconst retBuf = utilToBase(smallInt, 8, i);\r\n\t\t\t\tconst retView = new Uint8Array(retBuf);\r\n\t\t\t\t\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tretView[0] |= 0x80;\r\n\t\t\t\t\r\n\t\t\t\treturn retBuf;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlet retBuf = utilToBase(modValue, 8, i);\r\n\t\t\tlet retView = new Uint8Array(retBuf);\r\n\t\t\t\r\n\t\t\t//noinspection JSBitwiseOperatorUsage, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\t\tif(retView[0] & 0x80)\r\n\t\t\t{\r\n\t\t\t\t//noinspection JSCheckFunctionSignatures\r\n\t\t\t\tconst tempBuf = retBuf.slice(0);\r\n\t\t\t\tconst tempView = new Uint8Array(tempBuf);\r\n\t\t\t\t\r\n\t\t\t\tretBuf = new ArrayBuffer(retBuf.byteLength + 1);\r\n\t\t\t\t// noinspection ReuseOfLocalVariableJS\r\n\t\t\t\tretView = new Uint8Array(retBuf);\r\n\t\t\t\t\r\n\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\tfor(let k = 0; k < tempBuf.byteLength; k++)\r\n\t\t\t\t\tretView[k + 1] = tempView[k];\r\n\t\t\t\t\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tretView[0] = 0x00;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn retBuf;\r\n\t\t}\r\n\t\t\r\n\t\tbigInt *= Math.pow(2, 8);\r\n\t}\r\n\t\r\n\treturn (new ArrayBuffer(0));\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleReturnPointsJS, ParameterNamingConventionJS\r\n/**\r\n * Compare two array buffers\r\n * @param {!ArrayBuffer} inputBuffer1\r\n * @param {!ArrayBuffer} inputBuffer2\r\n * @returns {boolean}\r\n */\r\nexport function isEqualBuffer(inputBuffer1, inputBuffer2)\r\n{\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tif(inputBuffer1.byteLength !== inputBuffer2.byteLength)\r\n\t\treturn false;\r\n\t\r\n\t// noinspection LocalVariableNamingConventionJS\r\n\tconst view1 = new Uint8Array(inputBuffer1);\r\n\t// noinspection LocalVariableNamingConventionJS\r\n\tconst view2 = new Uint8Array(inputBuffer2);\r\n\t\r\n\tfor(let i = 0; i < view1.length; i++)\r\n\t{\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(view1[i] !== view2[i])\r\n\t\t\treturn false;\r\n\t}\r\n\t\r\n\treturn true;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Pad input number with leade \"0\" if needed\r\n * @returns {string}\r\n * @param {number} inputNumber\r\n * @param {number} fullLength\r\n */\r\nexport function padNumber(inputNumber, fullLength)\r\n{\r\n\tconst str = inputNumber.toString(10);\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tif(fullLength < str.length)\r\n\t\treturn \"\";\r\n\t\r\n\tconst dif = fullLength - str.length;\r\n\t\r\n\tconst padding = new Array(dif);\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(let i = 0; i < dif; i++)\r\n\t\tpadding[i] = \"0\";\r\n\t\r\n\tconst paddingString = padding.join(\"\");\r\n\t\r\n\treturn paddingString.concat(str);\r\n}\r\n//**************************************************************************************\r\nconst base64Template = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\nconst base64UrlTemplate = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\";\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionTooLongJS, FunctionNamingConventionJS\r\n/**\r\n * Encode string into BASE64 (or \"base64url\")\r\n * @param {string} input\r\n * @param {boolean} useUrlTemplate If \"true\" then output would be encoded using \"base64url\"\r\n * @param {boolean} skipPadding Skip BASE-64 padding or not\r\n * @param {boolean} skipLeadingZeros Skip leading zeros in input data or not\r\n * @returns {string}\r\n */\r\nexport function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false)\r\n{\r\n\tlet i = 0;\r\n\t\r\n\t// noinspection LocalVariableNamingConventionJS\r\n\tlet flag1 = 0;\r\n\t// noinspection LocalVariableNamingConventionJS\r\n\tlet flag2 = 0;\r\n\t\r\n\tlet output = \"\";\r\n\t\r\n\t// noinspection ConditionalExpressionJS\r\n\tconst template = (useUrlTemplate) ? base64UrlTemplate : base64Template;\r\n\t\r\n\tif(skipLeadingZeros)\r\n\t{\r\n\t\tlet nonZeroPosition = 0;\r\n\t\t\r\n\t\tfor(let i = 0; i < input.length; i++)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tif(input.charCodeAt(i) !== 0)\r\n\t\t\t{\r\n\t\t\t\tnonZeroPosition = i;\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\tinput = input.slice(nonZeroPosition);\r\n\t}\r\n\t\r\n\twhile(i < input.length)\r\n\t{\r\n\t\t// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\r\n\t\tconst chr1 = input.charCodeAt(i++);\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(i >= input.length)\r\n\t\t\tflag1 = 1;\r\n\t\t// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\r\n\t\tconst chr2 = input.charCodeAt(i++);\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(i >= input.length)\r\n\t\t\tflag2 = 1;\r\n\t\t// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\r\n\t\tconst chr3 = input.charCodeAt(i++);\r\n\t\t\r\n\t\t// noinspection LocalVariableNamingConventionJS\r\n\t\tconst enc1 = chr1 >> 2;\r\n\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);\r\n\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tlet enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);\r\n\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tlet enc4 = chr3 & 0x3F;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\tif(flag1 === 1)\r\n\t\t{\r\n\t\t\t// noinspection NestedAssignmentJS, AssignmentResultUsedJS, MagicNumberJS\r\n\t\t\tenc3 = enc4 = 64;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tif(flag2 === 1)\r\n\t\t\t{\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tenc4 = 64;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(skipPadding)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\r\n\t\t\tif(enc3 === 64)\r\n\t\t\t\toutput += `${template.charAt(enc1)}${template.charAt(enc2)}`;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\r\n\t\t\t\tif(enc4 === 64)\r\n\t\t\t\t\toutput += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;\r\n\t\t\t\telse\r\n\t\t\t\t\toutput += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\toutput += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\r\n\t}\r\n\t\r\n\treturn output;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMoreThanThreeNegationsJS, FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionNamingConventionJS\r\n/**\r\n * Decode string from BASE64 (or \"base64url\")\r\n * @param {string} input\r\n * @param {boolean} [useUrlTemplate=false] If \"true\" then output would be encoded using \"base64url\"\r\n * @param {boolean} [cutTailZeros=false] If \"true\" then cut tailing zeroz from function result\r\n * @returns {string}\r\n */\r\nexport function fromBase64(input, useUrlTemplate = false, cutTailZeros = false)\r\n{\r\n\t// noinspection ConditionalExpressionJS\r\n\tconst template = (useUrlTemplate) ? base64UrlTemplate : base64Template;\r\n\t\r\n\t//region Aux functions\r\n\t// noinspection FunctionWithMultipleReturnPointsJS, NestedFunctionJS\r\n\tfunction indexof(toSearch)\r\n\t{\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, MagicNumberJS\r\n\t\tfor(let i = 0; i < 64; i++)\r\n\t\t{\r\n\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\tif(template.charAt(i) === toSearch)\r\n\t\t\t\treturn i;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection MagicNumberJS\r\n\t\treturn 64;\r\n\t}\r\n\t\r\n\t// noinspection NestedFunctionJS\r\n\tfunction test(incoming)\r\n\t{\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS, MagicNumberJS\r\n\t\treturn ((incoming === 64) ? 0x00 : incoming);\r\n\t}\r\n\t//endregion\r\n\t\r\n\tlet i = 0;\r\n\t\r\n\tlet output = \"\";\r\n\t\r\n\twhile(i < input.length)\r\n\t{\r\n\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\r\n\t\tconst enc1 = indexof(input.charAt(i++));\r\n\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS\r\n\t\tconst enc2 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));\r\n\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS\r\n\t\tconst enc3 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));\r\n\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS\r\n\t\tconst enc4 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));\r\n\t\t\r\n\t\t// noinspection LocalVariableNamingConventionJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst chr1 = (test(enc1) << 2) | (test(enc2) >> 4);\r\n\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);\r\n\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);\r\n\t\t\r\n\t\toutput += String.fromCharCode(chr1);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\r\n\t\tif(enc3 !== 64)\r\n\t\t\toutput += String.fromCharCode(chr2);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\r\n\t\tif(enc4 !== 64)\r\n\t\t\toutput += String.fromCharCode(chr3);\r\n\t}\r\n\t\r\n\tif(cutTailZeros)\r\n\t{\r\n\t\tconst outputLength = output.length;\r\n\t\tlet nonZeroStart = (-1);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\tfor(let i = (outputLength - 1); i >= 0; i--)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tif(output.charCodeAt(i) !== 0)\r\n\t\t\t{\r\n\t\t\t\tnonZeroStart = i;\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS, NegatedIfStatementJS\r\n\t\tif(nonZeroStart !== (-1))\r\n\t\t\toutput = output.slice(0, nonZeroStart + 1);\r\n\t\telse\r\n\t\t\toutput = \"\";\r\n\t}\r\n\t\r\n\treturn output;\r\n}\r\n//**************************************************************************************\r\nexport function arrayBufferToString(buffer)\r\n{\r\n\tlet resultString = \"\";\r\n\tconst view = new Uint8Array(buffer);\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(const element of view)\r\n\t\tresultString += String.fromCharCode(element);\r\n\t\r\n\treturn resultString;\r\n}\r\n//**************************************************************************************\r\nexport function stringToArrayBuffer(str)\r\n{\r\n\tconst stringLength = str.length;\r\n\t\r\n\tconst resultBuffer = new ArrayBuffer(stringLength);\r\n\tconst resultView = new Uint8Array(resultBuffer);\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(let i = 0; i < stringLength; i++)\r\n\t\tresultView[i] = str.charCodeAt(i);\r\n\t\r\n\treturn resultBuffer;\r\n}\r\n//**************************************************************************************\r\nconst log2 = Math.log(2);\r\n//**************************************************************************************\r\n// noinspection FunctionNamingConventionJS\r\n/**\r\n * Get nearest to input length power of 2\r\n * @param {number} length Current length of existing array\r\n * @returns {number}\r\n */\r\nexport function nearestPowerOf2(length)\r\n{\r\n\tconst base = (Math.log(length) / log2);\r\n\t\r\n\tconst floor = Math.floor(base);\r\n\tconst round = Math.round(base);\r\n\t\r\n\t// noinspection ConditionalExpressionJS\r\n\treturn ((floor === round) ? floor : round);\r\n}\r\n//**************************************************************************************\r\n/**\r\n * Delete properties by name from specified object\r\n * @param {Object} object Object to delete properties from\r\n * @param {Array.<string>} propsArray Array of properties names\r\n */\r\nexport function clearProps(object, propsArray)\r\n{\r\n\tfor(const prop of propsArray)\r\n\t\tdelete object[prop];\r\n}\r\n//**************************************************************************************\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pvutils/src/utils.js\n// module id = ./node_modules/pvutils/src/utils.js\n// module chunks = 0 1 2 3 4","/**\n * Maritime Connectivity Platform Identity Registry API\n * MCP Identity Registry API can be used for managing entities in the Maritime Connectivity Platform.\n *\n * OpenAPI spec version: 0.7.0\n * Contact: info@maritimecloud.net\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\nimport * as models from './models';\n\nexport interface Organization {\n    address: string;\n\n    /**\n     * Cannot be created/updated by editing in the model. Use the dedicate create and revoke calls.\n     */\n    certificates?: Array<models.Certificate>;\n\n    country: string;\n\n    createdAt?: Date;\n\n    email: string;\n\n    /**\n     * Type of identity federation used by organization\n     */\n    federationType?: Organization.FederationTypeEnum;\n\n    id?: number;\n\n    identityProviderAttributes?: Array<models.IdentityProviderAttribute>;\n\n    /**\n     * The Maritime Resource Name\n     */\n    mrn: string;\n\n    /**\n     * The name of the organization\n     */\n    name: string;\n\n    updatedAt?: Date;\n\n    url: string;\n\n}\nexport namespace Organization {\n    export enum FederationTypeEnum {\n        TestIdp = <any> 'test-idp',\n        OwnIdp = <any> 'own-idp',\n        ExternalIdp = <any> 'external-idp'\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/backend-api/identity-registry/autogen/model/Organization.ts","/**\n * Maritime Connectivity Platform Identity Registry API\n * MCP Identity Registry API can be used for managing entities in the Maritime Connectivity Platform.\n *\n * OpenAPI spec version: 0.7.0\n * Contact: info@maritimecloud.net\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\nimport * as models from './models';\n\nexport interface Service {\n    /**\n     * The domain name the service will be available on. Used in the issued certificates for the service.\n     */\n    certDomainName?: string;\n\n    /**\n     * Cannot be created/updated by editing in the model. Use the dedicate create and revoke calls.\n     */\n    certificates?: Array<models.Certificate>;\n\n    createdAt?: Date;\n\n    id?: number;\n\n    /**\n     * The version of this service instance.\n     */\n    instanceVersion: string;\n\n    /**\n     * The Maritime Resource Name\n     */\n    mrn: string;\n\n    name: string;\n\n    /**\n     * Access type of the OpenId Connect client\n     */\n    oidcAccessType?: Service.OidcAccessTypeEnum;\n\n    /**\n     * The client id of the service in MCP. Will be generated.\n     */\n    oidcClientId?: string;\n\n    /**\n     * The client secret of the service in MCP. Will be generated.\n     */\n    oidcClientSecret?: string;\n\n    /**\n     * The OpenId Connect redirect uri of service.\n     */\n    oidcRedirectUri?: string;\n\n    /**\n     * Permissions as assigned from the organization\n     */\n    permissions?: string;\n\n    updatedAt?: Date;\n\n    /**\n     * The vessel that is linked to this service.\n     */\n    vessel?: models.Vessel;\n\n}\nexport namespace Service {\n    export enum OidcAccessTypeEnum {\n        Public = <any> 'public',\n        BearerOnly = <any> 'bearer-only',\n        Confidential = <any> 'confidential'\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/backend-api/identity-registry/autogen/model/Service.ts","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'administration',\n  template: `<router-outlet></router-outlet>`\n})\nexport class AdministrationComponent {\n  constructor() {\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/administration/administration.component.ts","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { routing } from './administration.routing';\nimport { AdministrationComponent } from './administration.component';\nimport { NgaModule } from \"../../theme/nga.module\";\nimport ApproveOrganizationModule from \"./approve-organizations/approve-organization.module\";\n\n\n@NgModule({\n  imports: [\n    CommonModule,\n    NgaModule,\n\t  ApproveOrganizationModule,\n    routing\n  ],\n  declarations: [\n    AdministrationComponent\n  ]\n})\nexport default class AdministrationModule {\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/administration/administration.module.ts","import { RouterModule, Routes } from '@angular/router';\n\nimport { AdministrationComponent } from './administration.component';\nimport { ApproveOrganizationComponent } from \"./approve-organizations/approve-organization.component\";\nimport { SiteAdminAuthGuard } from \"../../authentication/services/site-admin-guard.service\";\n\n// noinspection TypeScriptValidateTypes\nconst routes: Routes = [\n  {\n    path: '',\n    component: AdministrationComponent,\n\t  canActivate: [SiteAdminAuthGuard],\n    children: [\n\t    { path: 'approve', component: ApproveOrganizationComponent }\n    ]\n  }\n];\n\nexport const routing = RouterModule.forChild(routes);\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/administration/administration.routing.ts","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'approve-organization',\n  template: `<router-outlet></router-outlet>`\n})\nexport class ApproveOrganizationComponent {\n  constructor() {\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/administration/approve-organizations/approve-organization.component.ts","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { routing } from './approve-organization.routing';\nimport { ApproveOrganizationComponent } from \"./approve-organization.component\";\nimport { NgaModule } from \"../../../theme/nga.module\";\nimport { SharedModule } from \"../../shared/shared.module\";\nimport { ApproveListComponent } from \"./components/approve-list/approve-list.component\";\nimport { ApproveDetailsComponent } from \"./components/approve-details/approve-details.component\";\n\n\n@NgModule({\n  imports: [\n    CommonModule,\n    NgaModule,\n    SharedModule,\n    routing\n  ],\n  declarations: [\n    ApproveOrganizationComponent,\n\t  ApproveListComponent,\n\t  ApproveDetailsComponent\n  ]\n})\nexport default class ApproveOrganizationModule {\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/administration/approve-organizations/approve-organization.module.ts","import { RouterModule, Routes } from '@angular/router';\nimport { ApproveOrganizationComponent } from \"./approve-organization.component\";\nimport { ApproveListComponent } from \"./components/approve-list/approve-list.component\";\nimport { ApproveDetailsComponent } from \"./components/approve-details/approve-details.component\";\n\n// noinspection TypeScriptValidateTypes\nconst routes: Routes = [\n  {\n    path: 'approve',\n\t  component: ApproveOrganizationComponent,\n\t  data:{breadcrumb: 'Approve organizations'},\n    children: [\n      {\n        path: '',\n        component: ApproveListComponent\n      },\n\t    {\n\t\t    path: ':id',\n\t\t    component: ApproveDetailsComponent,\n\t\t    data:{breadcrumb: 'Details'}\n\t    }\n    ]\n  }\n];\n\nexport const routing = RouterModule.forChild(routes);\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/administration/approve-organizations/approve-organization.routing.ts","import { Component, ViewEncapsulation } from '@angular/core';\nimport { ActivatedRoute, Router } from \"@angular/router\";\nimport {\n\tMCNotificationsService,\n\tMCNotificationType\n} from \"../../../../../shared/mc-notifications.service\";\nimport { Organization } from \"../../../../../backend-api/identity-registry/autogen/model/Organization\";\nimport { OrganizationsService } from \"../../../../../backend-api/identity-registry/services/organizations.service\";\nimport { FormBuilder, FormControl, FormGroup, Validators } from \"@angular/forms\";\nimport { MrnHelperService } from \"../../../../../shared/mrn-helper.service\";\nimport { McUtils } from \"../../../../../shared/mc-utils\";\nimport { User } from \"../../../../../backend-api/identity-registry/autogen/model/User\";\nimport { MC_ADMIN } from \"../../../../../shared/app.constants\";\nimport { UsersService } from \"../../../../../backend-api/identity-registry/services/users.service\";\nimport { RolesService } from \"../../../../../backend-api/identity-registry/services/roles.service\";\nimport { Role } from \"../../../../../backend-api/identity-registry/autogen/model/Role\";\nimport {\n\tMcFormControlModel,\n\tMcFormControlType\n} from \"../../../../../theme/components/mcForm/mcFormControlModel\";\nimport RoleNameEnum = Role.RoleNameEnum;\n\n@Component({\n  selector: 'approve-details',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./approve-details.html'),\n\tstyles: [require('./approve-details.scss')]\n})\nexport class ApproveDetailsComponent {\n\tprivate userMrn: string;\n\tprivate mrnPattern:string;\n\tprivate mrnPatternError:string;\n\t// McForm params\n\tpublic isApproving = false;\n\tpublic approveTitle = \"Approve\";\n\tpublic userForm: FormGroup;\n\tpublic formControlModels: Array<McFormControlModel>;\n\n\n\tpublic organization:Organization;\n\tpublic title:string;\n\tpublic isLoading:boolean;\n  constructor(private route: ActivatedRoute, private router: Router, private notifications:MCNotificationsService, private userService: UsersService, private roleService: RolesService, private orgService: OrganizationsService, private formBuilder: FormBuilder, private mrnHelper: MrnHelperService) {\n\t  this.mrnPattern = mrnHelper.mrnPattern();\n\t  this.mrnPatternError = mrnHelper.mrnPatternError();\n  }\n\n  ngOnInit() {\n\t  this.title = 'Approve organization';\n\t  this.loadOrganization();\n  }\n\n  public approve() {\n\t  this.isApproving = true;\n\t  this.approveOrganization();\n  }\n\n  public cancel() {\n\t  this.router.navigate(['../'], {relativeTo: this.route });\n  }\n\n\tprivate loadOrganization() {\n\t\tthis.isLoading = true;\n\t\tlet orgMrn = this.route.snapshot.params['id'];\n\n\t\tthis.orgService.getUnapprovedOrganization(orgMrn).subscribe(\n\t\t organization => {\n\t\t\t\tthis.organization = organization;\n\t\t\t this.userMrn = this.mrnHelper.mrnMaskForUserOfOrg(organization.mrn);\n\t\t\t this.generateForm();\n\t\t\t this.isLoading = false;\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.isLoading = false;\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to get the organization', MCNotificationType.Error, err);\n\t\t\t\tthis.router.navigate(['../'], {relativeTo: this.route });\n\t\t\t}\n\t\t);\n\t}\n\n\n\tprivate approveOrganization() {\n\t\tthis.orgService.approveOrganization(this.organization.mrn).subscribe(\n\t\t\torganization => {\n\t\t\t\tthis.createAdminRole();\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.isApproving = false;\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to approve the organization', MCNotificationType.Error, err);\n\t\t\t}\n\t\t);\n\t}\n\n\tprivate createAdminRole() {\n\t\tlet role:Role = {\n\t\t\tpermission: MC_ADMIN, // TODO is this correct? Revise when creating the new role-functionality\n\t\t\troleName: RoleNameEnum.ORGADMIN\n\t\t};\n\n\t\tthis.roleService.createRole(this.organization.mrn, role).subscribe(\n\t\t\trole => {\n\t\t\t\tthis.createUser();\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.isApproving = false;\n\t\t\t\tthis.notifications.generateNotification('User not created', 'The organization was approved, but user creation failed. You can go to organizations and try to create the user again later.', MCNotificationType.Alert, err);\n\t\t\t\tthis.router.navigate(['../'], {relativeTo: this.route });\n\t\t\t}\n\t\t);\n\t}\n\n\tprivate createUser() {\n\t\tlet user:User = {\n\t\t\tmrn: this.userMrn,\n\t\t\tfirstName: this.userForm.value.firstName,\n\t\t\tlastName: this.userForm.value.lastName,\n\t\t\tpermissions: MC_ADMIN, // TODO is this correct? Revise when creating the new role-functionality\n\t\t\temail: this.userForm.value.emails.email\n\t\t};\n\n\t\tthis.userService.createUserForOrg(this.organization.mrn, user).subscribe(\n\t\t\tuser => {\n\t\t\t\tthis.isApproving = false;\n\t\t\t\tthis.notifications.generateNotification('Organization Approved', 'The organization was approved and now has access to the Maritime Connectivity Platform', MCNotificationType.Success);\n\t\t\t\tthis.router.navigate(['../'], {relativeTo: this.route });\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.isApproving = false;\n\t\t\t\tthis.notifications.generateNotification('User not created', 'The organization was approved, but user creation failed. You can go to organizations and try to create the user again later.', MCNotificationType.Alert, err);\n\t\t\t\tthis.router.navigate(['../'], {relativeTo: this.route });\n\t\t\t}\n\t\t);\n\t}\n\n\tprivate generateMRN(idValue:string) {\n\t\tvar mrn = (idValue?idValue:'');\n\t\tlet valueNoSpaces = mrn.split(' ').join('').toLowerCase();\n\t\tthis.userMrn = this.mrnHelper.mrnMaskForUserOfOrg(this.organization.mrn) + valueNoSpaces;\n\t\tthis.userForm.patchValue({mrn: this.userMrn});\n\t}\n/*\n {\n \"mrn\":\"urn:mrn:mcl:user:dma:dma-employee\",\n \"firstName\":\"Dma\",\n \"lastName\": \"Employee\",\n \"email\" : \"dma-employee@dma.dk\",\n \"permissions\": \"MCADMIN\"\n }\n */\n\tprivate generateForm() {\n\t\tthis.userForm = this.formBuilder.group({});\n\t\tthis.formControlModels = [];\n\n\t\tvar formControlModel:McFormControlModel = {formGroup: this.userForm, elementId: 'mrn', controlType: McFormControlType.Text, labelName: 'MRN', placeholder: '', isDisabled: true};\n\t\tvar formControl = new FormControl(this.userMrn, formControlModel.validator);\n\t\tthis.userForm.addControl(formControlModel.elementId, formControl);\n\t\tthis.formControlModels.push(formControlModel);\n\n\t\tformControlModel = {formGroup: this.userForm, elementId: 'userId', controlType: McFormControlType.Text, labelName: 'User ID', placeholder: 'Enter user ID to generate MRN', validator:Validators.required, pattern:this.mrnPattern, errorText:this.mrnPatternError};\n\t\tformControl = new FormControl('', formControlModel.validator);\n\t\tformControl.valueChanges.subscribe(param => this.generateMRN(param));\n\t\tthis.userForm.addControl(formControlModel.elementId, formControl);\n\t\tthis.formControlModels.push(formControlModel);\n\n\t\tformControlModel = {formGroup: this.userForm, elementId: 'firstName', controlType: McFormControlType.Text, labelName: 'First Name', placeholder: 'First Name is required', validator:Validators.required};\n\t\tformControl = new FormControl('', formControlModel.validator);\n\t\tthis.userForm.addControl(formControlModel.elementId, formControl);\n\t\tthis.formControlModels.push(formControlModel);\n\n\t\tformControlModel = {formGroup: this.userForm, elementId: 'lastName', controlType: McFormControlType.Text, labelName: 'Last Name', placeholder: 'Last Name is required', validator:Validators.required};\n\t\tformControl = new FormControl('', formControlModel.validator);\n\t\tthis.userForm.addControl(formControlModel.elementId, formControl);\n\t\tthis.formControlModels.push(formControlModel);\n\n\t\tMcUtils.generateEmailConfirmGroup(this.formBuilder, this.userForm, this.formControlModels, this.organization.email);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/administration/approve-organizations/components/approve-details/approve-details.component.ts","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-lg-12\\\">\\n    <ba-card title=\\\"{{title}}\\\" baCardClass=\\\"with-scroll table-panel\\\">\\n      <organization-details-table [displayLogo]=\\\"false\\\" [isLoading]=\\\"isLoading\\\" [organization]=\\\"organization\\\"></organization-details-table>\\n\\n      <div  *ngIf=\\\"!isLoading\\\">\\n        <div class=\\\"separator\\\"></div>\\n\\n        <div class=\\\"important-notice\\\">\\n          To approve <span>{{organization.name}}</span>, you need to fill out the form below with a user, that will get administrative access to the organization.\\n        </div>\\n\\n        <div class=\\\"separator\\\"></div>\\n\\n        <mc-form [formGroup]=\\\"userForm\\\" [formControlModels]=\\\"formControlModels\\\" [isLoading]=\\\"isLoading\\\" [isRegistering]=\\\"isApproving\\\" [registerTitle]=\\\"approveTitle\\\" (onCancel)=\\\"cancel()\\\" (onRegister)=\\\"approve()\\\"></mc-form>\\n      </div>\\n    </ba-card>\\n\\n\\n  </div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/administration/approve-organizations/components/approve-details/approve-details.html\n// module id = ./src/app/pages/administration/approve-organizations/components/approve-details/approve-details.html\n// module chunks = 2","module.exports = \".important-notice {\\n  max-width: 440px;\\n  line-height: 18px;\\n  font-size: 18px;\\n  margin-bottom: 15px; }\\n  .important-notice > span {\\n    font-style: italic;\\n    font-weight: bold; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/administration/approve-organizations/components/approve-details/approve-details.scss\n// module id = ./src/app/pages/administration/approve-organizations/components/approve-details/approve-details.scss\n// module chunks = 2","import { Component, OnInit, ViewEncapsulation } from '@angular/core';\nimport { ActivatedRoute, Router } from \"@angular/router\";\nimport { Organization } from \"../../../../../backend-api/identity-registry/autogen/model/Organization\";\nimport { OrganizationsService } from \"../../../../../backend-api/identity-registry/services/organizations.service\";\nimport {\n\tMCNotificationsService,\n\tMCNotificationType\n} from \"../../../../../shared/mc-notifications.service\";\nimport {\n\tTableActionButton,\n\tTableCell,\n\tTableCellActionButtons,\n\tTableHeader,\n\tTableRow\n} from \"../../../../../theme/components/mcTable/mcTable.component\";\n\n@Component({\n  selector: 'approve-list',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./approve-list.html'),\n  styles: []\n})\nexport class ApproveListComponent implements OnInit {\n\tpublic showModal:boolean = false;\n\tpublic modalDescription:string;\n\n\tprivate organizations:Array<Organization>;\n  public isLoading: boolean;\n\tpublic onGotoDetails: Function;\n\tpublic tableHeaders: Array<TableHeader>;\n\tpublic tableRows: Array<TableRow>;\n  constructor(private router:Router, private route:ActivatedRoute, private orgService: OrganizationsService, private notifications:MCNotificationsService) {\n\n  }\n\n  ngOnInit() {\n    this.isLoading = true;\n\t  this.onGotoDetails = this.gotoDetails.bind(this);\n    this.loadOrganizations();\n  }\n\n\tprivate loadOrganizations() {\n\t\tthis.orgService.getUnapprovedOrganizations().subscribe(\n\t\t\torganizations => {\n\t\t\t\tthis.organizations = organizations;\n\t\t\t\tthis.generateHeadersAndRows();\n\t\t\t\tthis.isLoading = false;\n\t\t\t},\n\t\t\terr => {\n\t\t    this.isLoading = false;\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to get organizations', MCNotificationType.Error, err);\n\t\t\t}\n\t\t);\n\t}\n\n\tprivate gotoDetails(index:number) {\n\t\tthis.approve(this.organizations[index]);\n\t}\n\n\tprivate generateHeadersAndRows() {\n\t\tvar tableHeaders: Array<TableHeader> = [];\n\t\tvar tableRows: Array<TableRow> = [];\n\n\t\tvar tableHeader: TableHeader = {title:'Name', class:''};\n\t\ttableHeaders.push(tableHeader);\n\n\t\ttableHeader = {title:'Country', class:'nowrap'};\n\t\ttableHeaders.push(tableHeader);\n\n\t\ttableHeader = {title:'Address', class:'nowrap'};\n\t\ttableHeaders.push(tableHeader);\n\n\t\ttableHeader = {title:'', class:'table-buttons'};\n\t\ttableHeaders.push(tableHeader);\n\n\t\tfor (let organization of this.organizations) {\n\t\t\tvar cells:Array<TableCell> = [];\n\n\t\t\tvar tableCell: TableCell = {valueHtml:organization.name, class:'', truncateNumber:70};\n\t\t\tcells.push(tableCell);\n\n\t\t\ttableCell = {valueHtml:organization.country, class:'nowrap', truncateNumber:0};\n\t\t\tcells.push(tableCell);\n\n\t\t\ttableCell = {valueHtml:organization.address, class:'table-description', truncateNumber:140};\n\t\t\tcells.push(tableCell);\n\n\t\t\tlet actionButtons:Array<TableActionButton> = [];\n\t\t\tlet actionButton:TableActionButton = {buttonClass: 'btn btn btn-success btn-raised btn-sm', name: 'Approve', onClick:() => {this.approve(organization)}};\n\t\t\tactionButtons.push(actionButton);\n\n\t\t\tactionButton = {buttonClass: 'btn btn-danger btn-raised btn-sm', name: 'Delete', onClick:() => {this.delete(organization)}};\n\t\t\tactionButtons.push(actionButton);\n\n\t\t\tlet tableCellActionButtons: TableCellActionButtons = {valueHtml:'', class:'nowrap table-buttons', truncateNumber:0, actionButtons:actionButtons};\n\t\t\tcells.push(tableCellActionButtons);\n\n\n\t\t\tlet tableRow: TableRow = {cells: cells};\n\t\t\ttableRows.push(tableRow);\n\t\t}\n\n\t\tthis.tableHeaders = tableHeaders;\n\t\tthis.tableRows = tableRows;\n\t}\n\n\tprivate approve(organization:Organization) {\n\t\tthis.router.navigate([organization.mrn], {relativeTo: this.route });\n\t}\n\n\tprivate organizationToDelete:Organization;\n\tprivate delete(organization:Organization) {\n\t\tthis.modalDescription = 'Do you want to delete ' + organization.name;\n\t\tthis.organizationToDelete = organization;\n\t\tthis.showModal = true;\n\t}\n\tpublic cancelModal() {\n\t\tthis.showModal = false;\n\t}\n\n\tprivate deleteForSure() {\n\t\tthis.isLoading = true;\n\t\tthis.showModal = false;\n\t\tthis.orgService.deleteOrganization(this.organizationToDelete.mrn).subscribe(\n\t\t\t() => {\n\t\t\t\tthis.loadOrganizations();\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to delete organization', MCNotificationType.Error, err);\n\t\t\t}\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/administration/approve-organizations/components/approve-list/approve-list.component.ts","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-lg-12\\\">\\n    <ba-card title=\\\"Organizations needing approval\\\" baCardClass=\\\"with-scroll table-panel\\\">\\n      <mc-table [tableHeaders]=\\\"tableHeaders\\\" [tableRows]=\\\"tableRows\\\" [isLoading]=\\\"isLoading\\\" [onRowClick]=\\\"onGotoDetails\\\"></mc-table>\\n    </ba-card>\\n  </div>\\n</div>\\n<mc-modal (onCancel)=\\\"cancelModal()\\\" (onOk)=\\\"deleteForSure()\\\" (onClose)=\\\"cancelModal()\\\" [show]=\\\"showModal\\\" [title]=\\\"'Delete organization'\\\" [description]=\\\"modalDescription\\\" [cancelClass]=\\\"'btn btn-default btn-raised'\\\" [cancelTitle]=\\\"'Cancel'\\\" [okClass]=\\\"'btn btn-danger btn-raised'\\\" [okTitle]=\\\"'Delete'\\\"></mc-modal>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/administration/approve-organizations/components/approve-list/approve-list.html\n// module id = ./src/app/pages/administration/approve-organizations/components/approve-list/approve-list.html\n// module chunks = 2","import {EnumsHelper} from \"../../../../shared/enums-helper\";\nimport {Service} from \"../../../../backend-api/identity-registry/autogen/model/Service\";\nimport OidcAccessTypeEnum = Service.OidcAccessTypeEnum;\n\nexport interface OidcAccessTypeViewModel {\n\tvalue?:string;\n\tlabel?:string;\n}\n\nexport class ServiceViewModel {\n\n\n\tpublic static getAllOidcAccessTypes(): Array<OidcAccessTypeViewModel> {\n\t\tlet models:Array<OidcAccessTypeViewModel> = [];\n\n\t\tlet keysAndValues = EnumsHelper.getKeysAndValuesFromEnum(OidcAccessTypeEnum);\n\t\tkeysAndValues.forEach(enumKeyAndValue => {\n\t\t\tlet model:OidcAccessTypeViewModel = {};\n\t\t\tmodel.value = enumKeyAndValue.value;\n\t\t\tmodel.label = ServiceViewModel.getLabelForEnum(enumKeyAndValue.value);\n\t\t\tmodels.push(model);\n\t\t});\n\t\treturn models;\n\t}\n\n\n\tpublic static getLabelForEnum(oidcAccessTypeEnum:OidcAccessTypeEnum):string {\n\t\tif (!oidcAccessTypeEnum) {\n\t\t\treturn '';\n\t\t}\n\t\tvar text = '';\n\t\tswitch (oidcAccessTypeEnum) {\n\t\t\tcase OidcAccessTypeEnum.BearerOnly: {\n\t\t\t\ttext = 'Bearer only';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase OidcAccessTypeEnum.Confidential: {\n\t\t\t\ttext = 'Confidential';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase OidcAccessTypeEnum.Public: {\n\t\t\t\ttext = 'Public';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault : {\n\t\t\t\ttext = OidcAccessTypeEnum[oidcAccessTypeEnum];\n\t\t\t\tif (!text) {\n\t\t\t\t\ttext = ''+ oidcAccessTypeEnum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn text;\n\t}\n\n}\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/org-identity-registry/services/view-models/ServiceViewModel.ts","import { Injectable } from '@angular/core';\nimport { ServiceRegistrySearchRequest } from \"../../../shared/components/service-registry-search/ServiceRegistrySearchRequest\";\n\n@Injectable()\nexport class SrSearchRequestsService {\n\tprivate searchRequests: { [key: string]: ServiceRegistrySearchRequest } = {};\n  constructor() {\n  }\n\n  // Returns null if none found\n  public getSearchRequest(key:string) : ServiceRegistrySearchRequest {\n  \treturn this.searchRequests[key];\n\t}\n\n\tpublic addSearchRequest(key:string, searchRequest:ServiceRegistrySearchRequest) {\n  \tthis.searchRequests[key] = searchRequest;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/org-service-registry/shared/services/sr-search-requests.service.ts","import { Injectable, OnInit } from '@angular/core';\nimport { Specification } from \"../../../../backend-api/service-registry/autogen/model/Specification\";\nimport { LabelValueModel } from \"../../../../theme/components/mcLabelValueTable/mcLabelValueTable.component\";\nimport { Design } from \"../../../../backend-api/service-registry/autogen/model/Design\";\nimport { Instance } from \"../../../../backend-api/service-registry/autogen/model/Instance\";\nimport { McUtils } from \"../../../../shared/mc-utils\";\nimport { isNullOrUndefined } from \"util\";\n\n@Injectable()\nexport class SrViewModelService implements OnInit {\n  constructor() {\n  }\n\n  ngOnInit() {\n\n  }\n\n  public generateLabelValuesForSpecification(specification:Specification, organizationName:string):Array<LabelValueModel> {\n    var labelValues:Array<LabelValueModel> = undefined;\n    if (specification) {\n      labelValues = [];\n      labelValues.push({label: 'MRN', valueHtml: specification.specificationId});\n      labelValues.push({label: 'Name', valueHtml: specification.name});\n      labelValues.push({label: 'Version', valueHtml: specification.version});\n\t    labelValues.push({label: 'Status', valueHtml: specification.status});\n\t\t  labelValues.push({label: 'Organization', valueHtml: organizationName});\n      labelValues.push({label: 'Description', valueHtml: specification.description});\n    }\n    return labelValues\n  }\n\n  public generateLabelValuesForDesign(design:Design, organizationName:string):Array<LabelValueModel> {\n    var labelValues:Array<LabelValueModel> = undefined;\n    if (design) {\n      labelValues = [];\n      labelValues.push({label: 'MRN', valueHtml: design.designId});\n      labelValues.push({label: 'Name', valueHtml: design.name});\n      labelValues.push({label: 'Version', valueHtml: design.version});\n      labelValues.push({label: 'Status', valueHtml: design.status});\n\t    labelValues.push({label: 'Organization', valueHtml: organizationName});\n      labelValues.push({label: 'Description', valueHtml: design.description});\n    }\n    return labelValues;\n  }\n\n  public generateLabelValuesForInstance(instance:Instance, organizationName:string):Array<LabelValueModel> {\n    var labelValues:Array<LabelValueModel> = undefined;\n    if (instance) {\n      labelValues = [];\n      labelValues.push({label: 'MRN', valueHtml: instance.instanceId});\n      labelValues.push({label: 'Name', valueHtml: instance.name});\n      labelValues.push({label: 'Version', valueHtml: instance.version});\n      labelValues.push({label: 'Status', valueHtml: instance.status});\n\t    labelValues.push({label: 'Organization', valueHtml: organizationName});\n      labelValues.push({label: 'Description', valueHtml: instance.description});\n\t    labelValues.push({label: 'Service endpoint', valueHtml: instance.endpointUri});\n\n\t    if (!isNullOrUndefined(instance.compliant)) {\n\t    \tlet compliantClass =  instance.compliant ? '' : 'label-danger';\n\t\t    labelValues.push({label: 'Compliant', valueHtml: McUtils.getYesNoString(instance.compliant), linkClass: compliantClass});\n\t    }\n    }\n    return labelValues;\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/org-service-registry/shared/services/sr-view-model.service.ts","import { Component, OnInit, ViewEncapsulation } from '@angular/core';\nimport {\n  MCNotificationsService,\n  MCNotificationType\n} from \"../../../../shared/mc-notifications.service\";\nimport { NavigationHelperService, queryKeys } from \"../../../../shared/navigation-helper.service\";\nimport { ActivatedRoute } from \"@angular/router\";\nimport { CertificateEntityType } from \"../../services/certificate-helper.service\";\nimport { CertificatesService } from \"../../../../backend-api/identity-registry/services/certificates.service\";\nimport { LabelValueModel } from \"../../../../theme/components\";\nimport { FileHelperService } from \"../../../../shared/file-helper.service\";\nimport { TOKEN_DELIMITER } from \"../../../../shared/app.constants\";\nimport { BitString, BmpString, fromBER, OctetString, PrintableString } from 'asn1js';\nimport { Convert } from 'pvtsutils';\nimport PrivateKeyInfo from 'pkijs/build/PrivateKeyInfo';\nimport Certificate from 'pkijs/build/Certificate';\nimport PFX from 'pkijs/build/PFX';\nimport SafeBag from 'pkijs/build/SafeBag';\nimport AuthenticatedSafe from 'pkijs/build/AuthenticatedSafe';\nimport CertBag from 'pkijs/build/CertBag';\nimport CertificationRequest from 'pkijs/build/CertificationRequest';\nimport AttributeTypeAndValue from 'pkijs/build/AttributeTypeAndValue';\nimport { CertificateBundle } from '../../../../backend-api/identity-registry/autogen/model/CertificateBundle';\nimport { stringToArrayBuffer } from 'pvutils';\nimport SafeContents from 'pkijs/build/SafeContents';\nimport PKCS8ShroudedKeyBag from 'pkijs/build/PKCS8ShroudedKeyBag';\nimport Attribute from 'pkijs/build/Attribute';\nimport { getRandomValues } from 'pkijs/build/common';\nimport { UserError } from '../../../../shared/UserError';\n\n@Component({\n  selector: 'certificate-issue-new',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./certificate-issue-new.html'),\n  styles: []\n})\nexport class CertificateIssueNewComponent implements OnInit {\n  public entityType: CertificateEntityType;\n  public entityMrn: string;\n  public entityTitle: string;\n  public isLoading: boolean;\n  public certificateBundle: CertificateBundle;\n  public showLocalIssueModal: boolean = false;\n  public showsChoiceModal: boolean = false;\n  public modalDescription: string;\n  public choiceModalDescription: string;\n\n  public labelValues: Array<LabelValueModel>;\n\n  private serverGeneratedKeys: boolean = false;\n\n  constructor(private fileHelper: FileHelperService, private certificateService: CertificatesService,\n              private route: ActivatedRoute, private navigationHelper: NavigationHelperService,\n              private notificationService: MCNotificationsService) {\n  }\n\n  ngOnInit() {\n    this.isLoading = false;\n    let entityType = this.route.snapshot.queryParams[queryKeys.ENTITY_TYPE];\n    let entityMrn = this.route.snapshot.queryParams[queryKeys.ENTITY_MRN];\n    let entityTitle = this.route.snapshot.queryParams[queryKeys.ENTITY_TITLE];\n    if (entityType == null || !entityMrn || !entityTitle) {\n      this.notificationService.generateNotification('Error',\n          'Unresolved state when trying to issue new certificate', MCNotificationType.Error);\n      this.navigationHelper.takeMeHome();\n    }\n    this.entityMrn = entityMrn;\n    this.entityTitle = entityTitle;\n    this.entityType = +entityType; // +-conversion from string to int\n    this.generateLabelValues();\n  }\n\n  public zipAndDownload() {\n    this.fileHelper.downloadPemCertificate(this.certificateBundle, this.entityTitle, this.serverGeneratedKeys);\n  }\n\n  public showChoiceModal() {\n    if (this.showsChoiceModal) {\n      this.showsChoiceModal = false;\n    }\n    this.showLocalIssueModal = false;\n    this.choiceModalDescription = `You are about to get a new certificate issued. Do you want to \n        generate the key pair for the certificate locally in your browser or do you want to let the \n        MIR API server generate it for you? NOTE that it is strongly recommended \n        to NOT let the server generate the key pair for you as in case of a breach of the \n        MIR API server, a malicious third party can potentially take control over your identity \n        by stealing your private key when it is generated. Also note that the possibility of \n        getting server generated key pairs will be removed completely in the future, and that MCP \n        ID service providers can already choose to disable it now.\n        <br/>A third option is to generate the key pair and a CSR yourself - an example on how to \n        do this can be found \n        <a href=\"https://github.com/maritimeconnectivity/IdentityRegistry#certificate-issuing-by-certificate-signing-request\" target=\"_blank\">here</a>`;\n    this.showsChoiceModal = true;\n  }\n\n  public showGenerationModal() {\n    this.showsChoiceModal = false;\n    let nameNoSpaces = this.entityTitle.split(' ').join('_');\n    this.modalDescription = `Many operating systems and browsers require that certificates are \n        imported as a password protected PKCS#12 keystore. This can be generated either manually \n        using OpenSSL or by letting the browser generate it for you. \n        If you want to manually generate the keystore, which is the recommended approach, \n        you should click 'Manual', download the resulting zip file, unzip it and then use OpenSSL \n        to generate the keystore using the following command:\n        <br><pre>openssl pkcs12 -export -out keystore.p12 -in Certificate_${nameNoSpaces}.pem -inkey PrivateKey_${nameNoSpaces}.pem</pre>\n        This will prompt you for a passphrase to protect the keystore. If successful the command will \n        result in a PKCS#12 keystore file called 'keystore.p12'.\n        <br>If you don't want to generate a keystore at all you can just skip executing the OpenSSL command.\n        <br>As an alternative you can also let your browser generate a keystore for you by clicking \n        'Browser'. NOTE that this action will take a little while and the resulting keystore will \n        NOT be compatible with most major operating systems and browsers.`;\n    this.showLocalIssueModal = true;\n  }\n\n  public issueNewWithServerKeys() {\n    this.showsChoiceModal = false;\n    this.isLoading = true;\n    this.certificateService.issueNewCertificate(null, this.entityType, this.entityMrn, true)\n        .subscribe((certificateBundle: CertificateBundle) => {\n          this.certificateBundle = certificateBundle;\n          this.serverGeneratedKeys = true;\n          this.isLoading = false;\n        }, err => {\n          this.isLoading = false;\n          if (err.status === 410) {\n            let userErr = new UserError('Operation not supported', err);\n            this.notificationService.generateNotification('Operation not supported',\n                'Generating certificates with server generated keys is not supported by ' +\n                'this ID provider', MCNotificationType.Alert, userErr);\n            return;\n          }\n          this.notificationService.generateNotification('Error',\n              'Error when trying to issue new certificate', MCNotificationType.Error, err);\n        });\n  }\n\n  public issueNewWithLocalKeys(generatePkcs12: boolean) {\n    this.showLocalIssueModal = false;\n    this.isLoading = true;\n    let ecKeyGenParams = {name: 'ECDSA', namedCurve: 'P-384', typedCurve: ''};\n    let keyResult = crypto.subtle.generateKey(ecKeyGenParams, true, ['sign', 'verify']);\n    keyResult.then(keyPair => {\n      let csr = new CertificationRequest();\n      csr.subject.typesAndValues.push(new AttributeTypeAndValue({\n        type: '2.5.4.3', // Common name\n        value: new PrintableString({ value: 'Test' })\n      }));\n      csr.subjectPublicKeyInfo.importKey(keyPair.publicKey).then(() => {\n        csr.sign(keyPair.privateKey, 'SHA-384').then(() => {\n          let csrBytes = csr.toSchema().toBER(false);\n          let pemCsr = this.toPem(csrBytes, 'CERTIFICATE REQUEST');\n          this.certificateService.issueNewCertificate(pemCsr, this.entityType, this.entityMrn, false)\n              .subscribe((certificate: string) => {\n                crypto.subtle.exportKey('pkcs8', keyPair.privateKey).then(rawPrivateKey => {\n                  crypto.subtle.exportKey('spki', keyPair.publicKey).then(rawPublicKey => {\n                    let privateKey = new PrivateKeyInfo({schema: fromBER(rawPrivateKey).result});\n\n                    if (generatePkcs12) {\n                      let rawCerts = this.convertCertChain(certificate);\n                      let certs = rawCerts.map(cert =>\n                          new Certificate({schema: fromBER(cert).result}));\n                      let password = this.generatePassword();\n\n                      Promise.resolve().then(() =>\n                          this.generatePKCS12(privateKey, certs, password)).then(result => {\n                        this.certificateBundle = {\n                          pemCertificate: {\n                            privateKey: this.toPem(rawPrivateKey, 'PRIVATE KEY'),\n                            publicKey: this.toPem(rawPublicKey, 'PUBLIC KEY'),\n                            certificate: certificate\n                          },\n                          pkcs12Keystore: result,\n                          keystorePassword: password\n                        };\n                        this.isLoading = false;\n                      }, err => {\n                        this.isLoading = false;\n                        this.notificationService.generateNotification('Error',\n                            'PKCS#12 keystore could not be generated',\n                            MCNotificationType.Error, err);\n                      });\n                    } else {\n                      this.certificateBundle = {\n                        pemCertificate: {\n                          privateKey: this.toPem(rawPrivateKey, 'PRIVATE KEY'),\n                          publicKey: this.toPem(rawPublicKey, 'PUBLIC KEY'),\n                          certificate: certificate\n                        }\n                      };\n                      this.isLoading = false;\n                    }\n                  }, err => {\n                    this.isLoading = false;\n                    this.notificationService.generateNotification('Error',\n                        'Public key could not be exported', MCNotificationType.Error, err);\n                  });\n                }, err => {\n                  this.isLoading = false;\n                  this.notificationService.generateNotification('Error',\n                      'Private key could not be exported', MCNotificationType.Error, err);\n                });\n              },\n              err => {\n                this.isLoading = false;\n                this.notificationService.generateNotification('Error',\n                    'Error when trying to issue new certificate', MCNotificationType.Error, err);\n              }\n          );\n        });\n      });\n    }, err => {\n      this.isLoading = false;\n      this.notificationService.generateNotification('Error',\n          'Error when trying to issue new certificate', MCNotificationType.Error, err);\n    });\n  }\n\n  public cancel() {\n    this.navigationHelper.cancelNavigateCertificates();\n  }\n\n  private generateLabelValues() {\n    this.labelValues = [];\n    this.labelValues.push({label: 'Name', valueHtml: this.entityTitle});\n    this.labelValues.push({label: 'MRN', valueHtml: this.entityMrn.split(TOKEN_DELIMITER)[0]});\n  }\n\n  private toPem(arrayBuffer: ArrayBuffer, type: string): string {\n    let b64 = Convert.ToBase64(arrayBuffer);\n    let finalString = '';\n    while (b64.length > 0) {\n      finalString += b64.substring(0, 64) + '\\n';\n      b64 = b64.substring(64);\n    }\n    return `-----BEGIN ${type}-----\\n${finalString}-----END ${type}-----\\n`;\n  }\n\n  private convertCertChain(pemCertChain: string): Array<ArrayBuffer> {\n    let certs = pemCertChain.split(/-----END CERTIFICATE-----/);\n    certs = certs.slice(0, certs.length - 1);\n    let tmp = certs.map(c => c.split(/-----BEGIN CERTIFICATE-----/)[1].replace(/\\n/mg, ''));\n    return tmp.map(c => Convert.FromBase64(c));\n  }\n\n  private generatePassword(): string {\n    let charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_^$#&!%';\n    let values = new Uint32Array(26);\n    crypto.getRandomValues(values);\n    let result = '';\n    for (let i = 0; i < values.length; i++) {\n      result += charset[values[i] % charset.length];\n    }\n    return result;\n  }\n\n  private generatePKCS12(privateKey: PrivateKeyInfo, certs: Array<Certificate>, password: string): Promise<ArrayBuffer> {\n    const keyLocalIDBuffer = new ArrayBuffer(4);\n    const keyLocalIDView = new Uint8Array(keyLocalIDBuffer);\n    getRandomValues(keyLocalIDView);\n\n    const certLocalIDBuffer = new ArrayBuffer(4);\n    const certLocalIDView = new Uint8Array(certLocalIDBuffer);\n    getRandomValues(certLocalIDView);\n\n    const caCertLocalIDBuffer = new ArrayBuffer(4);\n    const caCertLocalIDView = new Uint8Array(caCertLocalIDBuffer);\n    getRandomValues(caCertLocalIDView);\n\n    const bitArray = new ArrayBuffer(1);\n    const bitView = new Uint8Array(bitArray);\n\n    // tslint:disable-next-line:no-bitwise\n    bitView[0] |= 0x80;\n\n    const keyUsage = new BitString({\n      valueHex: bitArray,\n      unusedBits: 7\n    });\n\n    privateKey.attributes = [\n      new Attribute({\n        type: '2.5.29.15',\n        values: [\n          keyUsage\n        ]\n      })\n    ];\n\n    let certCn = '';\n    certs[0].subject.typesAndValues.forEach(t => {\n      if (t.type === '2.5.4.3') {\n        certCn = t.value.valueBlock.value;\n      }\n    });\n\n    let caCn = '';\n    certs[1].subject.typesAndValues.forEach(t => {\n      if (t.type === '2.5.4.3') {\n        caCn = t.value.valueBlock.value;\n      }\n    });\n\n    const pfx = new PFX({\n      parsedValue: {\n        integrityMode: 0,\n        authenticatedSafe: new AuthenticatedSafe({\n          parsedValue: {\n            safeContents: [\n              {\n                privacyMode: 0,\n                value: new SafeContents({\n                  safeBags: [\n                      new SafeBag({\n                        bagId: '1.2.840.113549.1.12.10.1.2',\n                        bagValue: new PKCS8ShroudedKeyBag({\n                          parsedValue: privateKey\n                        }),\n                        bagAttributes: [\n                            new Attribute({\n                              type: '1.2.840.113549.1.9.20', // friendlyName\n                              values: [\n                                  new BmpString({ value: 'PKCS8ShroudedKeyBag from PKIjs' })\n                              ]\n                            }),\n                            new Attribute({\n                              type: '1.2.840.113549.1.9.21', // localKeyID\n                              values: [\n                                  new OctetString({ valueHex: keyLocalIDBuffer })\n                              ]\n                            }),\n                            new Attribute({\n                              type: '1.3.6.1.4.1.311.17.1', // pkcs12KeyProviderNameAttr\n                              values: [\n                                  new BmpString({ value: 'MCP using https://pkijs.org/' })\n                              ]\n                            })\n                        ]\n                      })\n                  ]\n                })\n              },\n              {\n                privacyMode: 1,\n                value: new SafeContents({\n                  safeBags: [\n                      new SafeBag({\n                        bagId: '1.2.840.113549.1.12.10.1.3',\n                        bagValue: new CertBag({\n                          parsedValue: certs[0]\n                        }),\n                        bagAttributes: [\n                            new Attribute({\n                              type: '1.2.840.113549.1.9.20', // friendlyName\n                              values: [\n                                  new BmpString({ value: certCn })\n                              ]\n                            }),\n                            new Attribute({\n                              type: '1.2.840.113549.1.9.21', // localKeyID\n                              values: [\n                                  new OctetString({ valueHex: certLocalIDBuffer })\n                              ]\n                            }),\n                            new Attribute({\n                              type: '1.3.6.1.4.1.311.17.1', // pkcs12KeyProviderNameAttr\n                              values: [\n                                  new BmpString({ value: 'MCP using https://pkijs.org/' })\n                              ]\n                            })\n                        ]\n                      }),\n                      new SafeBag({\n                        bagId: '1.2.840.113549.1.12.10.1.3',\n                        bagValue: new CertBag({\n                          parsedValue: certs[1]\n                        }),\n                        bagAttributes: [\n                          new Attribute({\n                            type: '1.2.840.113549.1.9.20', // friendlyName\n                            values: [\n                              new BmpString({ value: caCn })\n                            ]\n                          }),\n                          new Attribute({\n                            type: '1.2.840.113549.1.9.21', // localKeyID\n                            values: [\n                              new OctetString({ valueHex: caCertLocalIDBuffer })\n                            ]\n                          }),\n                          new Attribute({\n                            type: '1.3.6.1.4.1.311.17.1', // pkcs12KeyProviderNameAttr\n                            values: [\n                              new BmpString({ value: 'MCP using https://pkijs.org/' })\n                            ]\n                          })\n                        ]\n                      })\n                  ]\n                })\n              }\n            ]\n          }\n        })\n      }\n    });\n\n    let passwordConverted = stringToArrayBuffer(password);\n    let sequence = Promise.resolve();\n\n    sequence = sequence.then(\n        () => pfx.parsedValue.authenticatedSafe.parsedValue.safeContents[0].value\n            .safeBags[0].bagValue.makeInternalValues({\n          password: passwordConverted,\n          contentEncryptionAlgorithm: {\n            name: 'AES-CBC', // OpenSSL can handle AES-CBC only\n            length: 128\n          },\n          hmacHashAlgorithm: 'SHA-256',\n          iterationCount: 100000\n        })\n    );\n\n    sequence = sequence.then(\n        () => pfx.parsedValue.authenticatedSafe.makeInternalValues({\n          safeContents: [\n            {\n              // Empty parameters for first SafeContent since \"No Privacy\" protection mode there\n            },\n            {\n              password: passwordConverted,\n              contentEncryptionAlgorithm: {\n                name: 'AES-CBC', // OpenSSL can handle AES-CBC only\n                length: 128\n              },\n              hmacHashAlgorithm: 'SHA-256',\n              iterationCount: 100000\n            }\n          ]\n        })\n    );\n\n    sequence = sequence.then(\n        () => pfx.makeInternalValues({\n          password: passwordConverted,\n          iterations: 100000,\n          pbkdf2HashAlgorithm: 'SHA-256',\n          hmacHashAlgorithm: 'SHA-256'\n        })\n    );\n\n    sequence = sequence.then(() => pfx.toSchema().toBER(false));\n\n    return sequence;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/certificate-issue-new/certificate-issue-new.component.ts","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-lg-12\\\">\\n    <ba-card title=\\\"Issue new certificate\\\" baCardClass=\\\"with-scroll table-panel\\\">\\n      <!-- Before issue -->\\n      <div *ngIf=\\\"entityType != null && !certificateBundle && !isLoading\\\">\\n        <h5>Issuing a new certificate for:</h5>\\n        <mc-label-value-table [isLoading]=\\\"isLoading\\\" [labelValues]=\\\"labelValues\\\"></mc-label-value-table>\\n        <ul *ngIf=\\\"entityType != null\\\" class=\\\"btn-list clearfix\\\">\\n          <li>\\n            <button type=\\\"button\\\" class=\\\"btn btn-danger btn-raised\\\" (click)=\\\"showChoiceModal()\\\">Issue Certificate</button>\\n          </li>\\n          <li>\\n            <button type=\\\"button\\\" class=\\\"btn btn-default btn-raised\\\" (click)=\\\"cancel()\\\">Cancel</button>\\n          </li>\\n        </ul>\\n      </div>\\n\\n      <sk-fading-circle [isRunning]=\\\"isLoading\\\" ></sk-fading-circle>\\n\\n      <!-- After issue and success -->\\n      <div *ngIf=\\\"certificateBundle\\\">\\n        Certificate issued with success\\n        <ul *ngIf=\\\"entityType != null\\\" class=\\\"btn-list clearfix\\\">\\n          <li>\\n            <button type=\\\"button\\\" class=\\\"btn btn-primary btn-raised\\\" (click)=\\\"zipAndDownload()\\\">Download certificate</button>\\n          </li>\\n          <li>\\n            <button type=\\\"button\\\" class=\\\"btn btn-default btn-raised\\\" (click)=\\\"cancel()\\\">OK</button>\\n          </li>\\n        </ul>\\n      </div>\\n    </ba-card>\\n  </div>\\n</div>\\n<mc-modal (onCancel)=\\\"issueNewWithServerKeys()\\\" (onOk)=\\\"showGenerationModal()\\\" (onClose)=\\\"cancel()\\\" [show]=\\\"showsChoiceModal\\\" [title]=\\\"'How do you want to generate your certificate key pair?'\\\" [description]=\\\"choiceModalDescription\\\" [cancelClass]=\\\"'btn btn-danger btn-raised'\\\" [cancelTitle]=\\\"'Server'\\\" [okClass]=\\\"'btn btn-success btn-raised'\\\" [okTitle]=\\\"'Local'\\\"></mc-modal>\\n<mc-modal (onCancel)=\\\"issueNewWithLocalKeys(true)\\\" (onOk)=\\\"issueNewWithLocalKeys(false)\\\" (onClose)=\\\"cancel()\\\" [show]=\\\"showLocalIssueModal\\\" [title]=\\\"'Generate a PKCS#12 Keystore?'\\\" [description]=\\\"modalDescription\\\" [cancelClass]=\\\"'btn btn-danger btn-raised'\\\" [cancelTitle]=\\\"'Browser'\\\" [okClass]=\\\"'btn btn-success btn-raised'\\\" [okTitle]=\\\"'Manual'\\\"></mc-modal>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/certificate-issue-new/certificate-issue-new.html\n// module id = ./src/app/pages/shared/components/certificate-issue-new/certificate-issue-new.html\n// module chunks = 0 1 2 3 4","import { Component, OnInit, ViewEncapsulation } from '@angular/core';\nimport {\n    MCNotificationsService,\n    MCNotificationType\n} from \"../../../../shared/mc-notifications.service\";\nimport { NavigationHelperService, queryKeys } from \"../../../../shared/navigation-helper.service\";\nimport { ActivatedRoute } from \"@angular/router\";\nimport {\n    CertificateEntityType,\n    CertificateHelperService\n} from \"../../services/certificate-helper.service\";\nimport { CertificatesService } from \"../../../../backend-api/identity-registry/services/certificates.service\";\nimport { LabelValueModel } from \"../../../../theme/components/mcLabelValueTable/mcLabelValueTable.component\";\nimport { FormBuilder, FormControl, FormGroup, Validators } from \"@angular/forms\";\nimport {\n    McFormControlModel,\n    McFormControlModelDatepicker,\n    McFormControlModelSelect,\n    McFormControlType,\n    SelectModel\n} from \"../../../../theme/components/mcForm/mcFormControlModel\";\nimport { SelectValidator } from \"../../../../theme/validators/select.validator\";\nimport { CertificateRevocation } from \"../../../../backend-api/identity-registry/autogen/model/CertificateRevocation\";\nimport RevokationReasonEnum = CertificateRevocation.RevokationReasonEnum;\n\n\n@Component({\n  selector: 'certificate-revoke',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./certificate-revoke.html'),\n  styles: []\n})\nexport class CertificateRevokeComponent implements OnInit {\n  public entityType: CertificateEntityType;\n  public entityMrn: string;\n\tpublic entityTitle: string;\n\tpublic certificateId: string;\n  public isLoading: boolean;\n  \n\tpublic isRevoking = false;\n\tpublic revokeTitle = \"Revoke\";\n\tpublic revokeForm: FormGroup;\n\tpublic formControlModels: Array<McFormControlModel>;\n\n  public labelValues:Array<LabelValueModel>;\n\n  constructor(private certificateHelper:CertificateHelperService, private formBuilder: FormBuilder, private certificateService: CertificatesService, private route:ActivatedRoute, private navigationHelper: NavigationHelperService, private notificationService: MCNotificationsService) {\n  }\n\n  ngOnInit() {\n    this.isLoading = true;\n    let entityType = this.route.snapshot.queryParams[queryKeys.ENTITY_TYPE];\n    let entityMrn = this.route.snapshot.queryParams[queryKeys.ENTITY_MRN];\n\t  let entityTitle = this.route.snapshot.queryParams[queryKeys.ENTITY_TITLE];\n\t  let certificateId = this.route.snapshot.queryParams[queryKeys.CERT_ID];\n    if (entityType == null || !entityMrn || !entityTitle) {\n      this.notificationService.generateNotification(\"Error\", \"Unresolved state when trying to revoke certificate\", MCNotificationType.Error);\n      this.navigationHelper.takeMeHome();\n    }\n    this.entityMrn = entityMrn;\n    this.entityTitle = entityTitle;\n    this.entityType = +entityType; // +-conversion from string to int\n\t  this.certificateId = certificateId;\n    this.generateLabelValues();\n    this.generateForm();\n\n\t  this.isLoading = false;\n  }\n\n  public revoke() {\n    this.isRevoking = true;\n    let revokeDate:Date = this.revokeForm.value.revokedAt;\n\t  let tempRevocationReason = this.revokeForm.value.revocationReason;\n\t  var revocationReason:RevokationReasonEnum = null;\n\t  if (tempRevocationReason && tempRevocationReason.toLowerCase().indexOf('undefined') < 0) {\n\t\t  revocationReason = tempRevocationReason;\n\t  }\n    let certificateRevocation:CertificateRevocation = {revokationReason:revocationReason, revokedAt:revokeDate.getTime()+''}\n    this.certificateService.revokeCertificate(this.entityType, this.entityMrn, this.certificateId, certificateRevocation).subscribe(\n      _ => {\n        this.isRevoking = false;\n        this.navigationHelper.cancelNavigateCertificates();\n      },\n      err => {\n        this.isRevoking = false;\n        this.notificationService.generateNotification('Error', 'Error when trying to revoke certificate', MCNotificationType.Error, err);\n      }\n    );\n  }\n\n  public cancel() {\n    this.navigationHelper.cancelNavigateCertificates();\n  }\n\n  private generateLabelValues() {\n    this.labelValues = [];\n    this.labelValues.push({label: 'Name', valueHtml: this.entityTitle});\n    this.labelValues.push({label: 'MRN', valueHtml: this.entityMrn});\n  }\n  \n\tprivate generateForm() {\n\t\tthis.revokeForm = this.formBuilder.group({});\n\t\tthis.formControlModels = [];\n\n\t\tlet selectValues = this.selectValues();\n\t\tlet formControlModelSelect:McFormControlModelSelect = {selectValues:selectValues, formGroup: this.revokeForm, elementId: 'revocationReason', controlType: McFormControlType.Select, labelName: '', placeholder: '', validator:SelectValidator.validate, showCheckmark:false};\n\t\tvar formControl = new FormControl('', formControlModelSelect.validator);\n\t\tthis.revokeForm.addControl(formControlModelSelect.elementId, formControl);\n\t\tthis.formControlModels.push(formControlModelSelect);\n\n\t\tlet formControlModel:McFormControlModelDatepicker = {minDate:new Date(), formGroup: this.revokeForm, elementId: 'revokedAt', controlType: McFormControlType.Datepicker, labelName: '', validator:Validators.required};\n\t\tformControl = new FormControl('', formControlModel.validator);\n\t\tthis.revokeForm.addControl(formControlModel.elementId, formControl);\n\t\tthis.formControlModels.push(formControlModel);\n\t}\n\n\tprivate selectValues():Array<SelectModel> {\n\t\tlet selectValues:Array<SelectModel> = [];\n\t\tselectValues.push({value:undefined, label:'Choose reason...', isSelected: true});\n\t\tlet allrevokeTypes = this.certificateHelper.getAllRevocationTypes();\n\t\tallrevokeTypes.forEach(revokeType => {\n\t\t\tselectValues.push({value:revokeType.value, label:revokeType.label, isSelected: false});\n\t\t});\n\t\treturn selectValues;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/certificate-revoke/certificate-revoke.component.ts","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-lg-12\\\">\\n    <ba-card title=\\\"Revoke certificate\\\" baCardClass=\\\"with-scroll table-panel\\\">\\n      <!-- Before issue -->\\n      <div *ngIf=\\\"entityType != null && !isLoading\\\">\\n        <h5>Revoking certificate for:</h5>\\n        <mc-label-value-table [isLoading]=\\\"isLoading\\\" [labelValues]=\\\"labelValues\\\"></mc-label-value-table>\\n        <br>\\n        <h5>\\n          Please choose a reason and date for revocation.\\n        </h5>\\n        <mc-form [formGroup]=\\\"revokeForm\\\" [formControlModels]=\\\"formControlModels\\\" [isLoading]=\\\"isLoading\\\" [isRegistering]=\\\"isRevoking\\\" [registerTitle]=\\\"revokeTitle\\\" (onCancel)=\\\"cancel()\\\" (onRegister)=\\\"revoke()\\\"></mc-form>\\n      </div>\\n      <sk-fading-circle [isRunning]=\\\"isLoading\\\" ></sk-fading-circle>\\n    </ba-card>\\n  </div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/certificate-revoke/certificate-revoke.html\n// module id = ./src/app/pages/shared/components/certificate-revoke/certificate-revoke.html\n// module chunks = 0 1 2 3 4","import { Component, Input, OnChanges, ViewEncapsulation } from '@angular/core';\nimport { Certificate } from \"../../../../backend-api/identity-registry/autogen/model/Certificate\";\nimport {\n    CertificateEntityType,\n    CertificateHelperService\n} from \"../../services/certificate-helper.service\";\nimport { DATE_FORMAT } from \"../../../../theme/theme.constants\";\nimport { AuthService } from \"../../../../authentication/services/auth.service\";\nimport { CertificateViewModel } from \"../../view-models/CertificateViewModel\";\nimport { NavigationHelperService } from \"../../../../shared/navigation-helper.service\";\nimport { MCNotificationsService } from \"../../../../shared/mc-notifications.service\";\nimport { FileHelperService } from \"../../../../shared/file-helper.service\";\nimport { PemCertificate } from \"../../../../backend-api/identity-registry/autogen/model/PemCertificate\";\nimport {\n    TableActionButton,\n    TableCell,\n    TableCellActionButtons,\n    TableHeader,\n    TableRow\n} from \"../../../../theme/components/mcTable/mcTable.component\";\nimport { DatePipe } from \"@angular/common\";\nimport { CertificateBundle } from \"../../../../backend-api/identity-registry/autogen/model/CertificateBundle\";\n\n@Component({\n  selector: 'certificates-table',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./certificates-table.html'),\n  styles: [require('./certificates-table.scss')]\n})\nexport class CertificatesTableComponent implements OnChanges{\n  @Input() certificates: Array<Certificate>;\n  @Input() certificateEntityType: CertificateEntityType;\n  @Input() entityMrn: string;\n  @Input() isLoading: boolean;\n  @Input() certificateTitle: string;\n  @Input() isAdmin: boolean;\n\n\tpublic tableHeaders: Array<TableHeader>;\n\tpublic tableRows: Array<TableRow>;\n  public newCertificateTitle = \"Issue new Certificate\";\n  public certificateViewModels: Array<CertificateViewModel>;\n  public tableClass:string;\n  public onIssueCertificate: Function;\n\n\tpublic onDownload:Function;\n\n  constructor(private datePipe: DatePipe, private fileHelper: FileHelperService, private navigationHelper: NavigationHelperService, private authService:AuthService, private certificateHelperService: CertificateHelperService, private notificationService: MCNotificationsService) {\n    this.onIssueCertificate = this.issueCertificate.bind(this);\n  }\n\n\tngOnInit() {\n\t\tif (!this.authService.authState.rolesLoaded) {\n\t\t\tthis.authService.rolesLoaded.subscribe((mode)=> {\n\t\t\t\tthis.generateHeadersAndRows();\n\t\t\t});\n\t\t}\n\t}\n\n  ngOnChanges() {\n    if (this.certificates) {\n      this.certificateViewModels = this.certificateHelperService.convertCertificatesToViewModels(this.certificates);\n      this.sortCertificates();\n\t    this.generateHeadersAndRows();\n    }\n  }\n\tprivate generateHeadersAndRows() {\n\t\tvar tableHeaders: Array<TableHeader> = [];\n\t\tvar tableRows: Array<TableRow> = [];\n\n\t\tvar tableHeader: TableHeader = {title:'Certificate', class:''};\n\t\ttableHeaders.push(tableHeader);\n\n\t\ttableHeader = {title:'Valid from', class:'nowrap'};\n\t\ttableHeaders.push(tableHeader);\n\n\t\ttableHeader = {title:'Valid to', class:'nowrap'};\n\t\ttableHeaders.push(tableHeader);\n\n\t\ttableHeader = {title:'', class:'table-buttons'};\n\t\ttableHeaders.push(tableHeader);\n\n\t\tfor (let certificate of this.certificateViewModels) {\n\t\t\tvar cells:Array<TableCell> = [];\n\n\t\t\tvar tableCell: TableCell = {valueHtml:'Certificate for ' + this.certificateTitle, class:'', truncateNumber:50};\n\t\t\tcells.push(tableCell);\n\n\t\t\ttableCell = {valueHtml:this.datePipe.transform(certificate.start, DATE_FORMAT), class:'nowrap', truncateNumber:0};\n\t\t\tcells.push(tableCell);\n\n\t\t\ttableCell = {valueHtml:this.datePipe.transform(certificate.end, DATE_FORMAT), class:'nowrap', truncateNumber:0};\n\t\t\tcells.push(tableCell);\n\n\t\t\tif (certificate.revoked) {\n\t\t\t\ttableCell = {valueHtml:'Revoked (' + certificate.revokeReasonText + ')', class:'red-text', truncateNumber:50};\n\t\t\t\tcells.push(tableCell);\n\t\t\t} else {\n\t\t\t\tlet actionButtons:Array<TableActionButton> = [];\n\t\t\t\tlet actionButton:TableActionButton = {buttonClass: 'btn btn-primary btn-raised btn-sm', name: 'Download certificate', onClick:() => {this.download(certificate)}};\n\t\t\t\tactionButtons.push(actionButton);\n\t\t\t\tif (this.isAdmin) {\n\t\t\t\t\tactionButton = {buttonClass: 'btn btn-primary btn-raised btn-sm', name: 'Revoke certificate', onClick:() => {this.revoke(certificate)}};\n\t\t\t\t\tactionButtons.push(actionButton);\n\t\t\t\t}\n\t\t\t\tlet tableCellActionButtons: TableCellActionButtons = {valueHtml:'', class:'table-buttons', truncateNumber:0, actionButtons:actionButtons};\n\t\t\t\tcells.push(tableCellActionButtons);\n\t\t\t}\n\n\t\t\tlet tableRow: TableRow = {cells: cells};\n\t\t\ttableRows.push(tableRow);\n\t\t}\n\n\t\tthis.tableHeaders = tableHeaders;\n\t\tthis.tableRows = tableRows;\n\t}\n  private sortCertificates() {\n    // We are sorting with longest due date on top\n    this.certificateViewModels.sort((obj1: CertificateViewModel, obj2: CertificateViewModel) => {\n      var obj1Time:number;\n      var obj2Time:number;\n      // Why is this needed??? for some reason sometimes the obj.end is a number and not a Date???\n      if (typeof obj1.end === \"Date\") {\n        obj1Time = obj1.end.getTime();\n      } else {\n        obj1Time = obj1.end;\n      }\n      if (typeof obj2.end === \"Date\") {\n        obj2Time = obj2.end.getTime();\n      } else {\n        obj2Time = obj2.end;\n      }\n\n      if (obj1.revoked && obj2.revoked) {\n        return obj2Time - obj1Time;\n      }\n      if (obj1.revoked) {\n        return 1;\n      }\n      if (obj2.revoked) {\n        return -1;\n      }\n      return obj2Time - obj1Time;\n    });\n  }\n\n  public issueCertificate() {\n    this.navigationHelper.navigateToIssueNewCertificate(this.certificateEntityType, this.entityMrn, this.certificateTitle);\n  }\n\n  public revoke(certificate:Certificate) {\n  \tthis.navigationHelper.navigateToRevokeCertificate(this.certificateEntityType, this.entityMrn, this.certificateTitle, certificate.serialNumber);\n  }\n\n  public download(certificate:Certificate) {\n    let pemCertificate:PemCertificate = {certificate:certificate.certificate};\n    let certBundle:CertificateBundle = {pemCertificate:pemCertificate};\n    this.fileHelper.downloadPemCertificate(certBundle, this.certificateTitle, true);\n  }\n\n  public canCreate(): boolean {\n      return this.isAdmin;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/certificates-table/certificates-table.component.ts","module.exports = \"<mc-table [tableHeaders]=\\\"tableHeaders\\\" [tableRows]=\\\"tableRows\\\" [isLoading]=\\\"isLoading\\\"></mc-table>\\n<div *ngIf=\\\"!isLoading\\\">\\n  <mc-create-button [isAdmin]=\\\"canCreate()\\\" [title]=\\\"newCertificateTitle\\\" [onClick]=\\\"onIssueCertificate\\\"></mc-create-button>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/certificates-table/certificates-table.html\n// module id = ./src/app/pages/shared/components/certificates-table/certificates-table.html\n// module chunks = 0 1 2 3 4","module.exports = \".table-buttons {\\n  width: 100%; }\\n  .table-buttons button {\\n    margin: 5px !important; }\\n\\n.certificate-table td {\\n  vertical-align: middle; }\\n\\n.certificate-table td:first-child {\\n  white-space: nowrap; }\\n\\n.certificate-table-short td {\\n  vertical-align: middle; }\\n\\n.certificate-table-short td:first-child {\\n  min-width: 200px; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/certificates-table/certificates-table.scss\n// module id = ./src/app/pages/shared/components/certificates-table/certificates-table.scss\n// module chunks = 0 1 2 3 4","import { Component, Input, OnChanges, ViewEncapsulation } from '@angular/core';\nimport { Design } from \"../../../../backend-api/service-registry/autogen/model/Design\";\nimport {\n    TableCell,\n    TableHeader,\n    TableRow\n} from \"../../../../theme/components/mcTable/mcTable.component\";\nimport {\n    MCNotificationsService,\n    MCNotificationType\n} from \"../../../../shared/mc-notifications.service\";\nimport { OrganizationsService } from \"../../../../backend-api/identity-registry/services/organizations.service\";\n\n@Component({\n  selector: 'designs-table',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./designs-table.html'),\n  styles: []\n})\nexport class DesignsTableComponent implements OnChanges {\n  @Input() designs: Array<Design>;\n  @Input() isLoading: boolean;\n  @Input() onRowClick: (index:number) => void;\n  public tableHeaders: Array<TableHeader>;\n  public tableRows: Array<TableRow>;\n  constructor(private orgsService: OrganizationsService, private notifications: MCNotificationsService) {\n  }\n  ngOnInit() {\n  }\n  ngOnChanges() {\n    if (this.designs) {\n      this.generateHeadersAndRows();\n    }\n  }\n  private generateHeadersAndRows() {\n    var tableHeaders: Array<TableHeader> = [];\n    var tableRows: Array<TableRow> = [];\n\n    var tableHeader: TableHeader = {title:'Name', class:''};\n    tableHeaders.push(tableHeader);\n\n    tableHeader = {title:'Version', class:'nowrap align-center'};\n    tableHeaders.push(tableHeader);\n\n    tableHeader = {title:'Status', class:'nowrap'};\n    tableHeaders.push(tableHeader);\n\n\t  tableHeader = {title:'Organization', class:'nowrap'};\n\t  tableHeaders.push(tableHeader);\n\n    tableHeader = {title:'Description', class:''};\n    tableHeaders.push(tableHeader);\n\n    for (let design of this.designs) {\n      var cells:Array<TableCell> = [];\n\n      var tableCell: TableCell = {valueHtml:design.name, class:'', truncateNumber:50};\n      cells.push(tableCell);\n\n      tableCell = {valueHtml:design.version, class:'nowrap align-center', truncateNumber:0};\n      cells.push(tableCell);\n\n      tableCell = {valueHtml:design.status, class:'nowrap', truncateNumber:0};\n      cells.push(tableCell);\n\n\t    tableCell = {valueHtml:'', class:'nowrap', truncateNumber:30};\n\t    this.setOrganizationCell(tableCell, design.organizationId);\n\t    cells.push(tableCell);\n\n      tableCell = {valueHtml:design.description, class:'table-description', truncateNumber:250};\n      cells.push(tableCell);\n\n      let tableRow: TableRow = {cells: cells};\n      tableRows.push(tableRow);\n    }\n\n    this.tableHeaders = tableHeaders;\n    this.tableRows = tableRows;\n  }\n\n\tprivate setOrganizationCell(tableCell: TableCell, organizationId) {\n\t\tthis.orgsService.getOrganizationName(organizationId).subscribe(\n\t\t\torganizationName => {\n\t\t\t\ttableCell.valueHtml = organizationName;\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to get organization', MCNotificationType.Error, err);\n\t\t\t}\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/designs-table/designs-table.component.ts","module.exports = \"<mc-table [tableHeaders]=\\\"tableHeaders\\\" [tableRows]=\\\"tableRows\\\" [isLoading]=\\\"isLoading\\\" [onRowClick]=\\\"onRowClick\\\"></mc-table>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/designs-table/designs-table.html\n// module id = ./src/app/pages/shared/components/designs-table/designs-table.html\n// module chunks = 0 1 2 3 4","import { Component, Input, ViewEncapsulation } from '@angular/core';\nimport { EntityImageModel } from \"../../../../theme/components/mcEntityImage/mcEntityImage.component\";\nimport { AuthService } from \"../../../../authentication/services/auth.service\";\nimport { Observable } from \"rxjs\";\nimport { LogoService } from \"../../../../backend-api/identity-registry/services/logo.service\";\nimport { Endorsement } from \"../../../../backend-api/endorsements/autogen/model/Endorsement\";\nimport { NavigationHelperService } from \"../../../../shared/navigation-helper.service\";\nimport { OrganizationsService } from \"../../../../backend-api/identity-registry/services/organizations.service\";\n\n@Component({\n  selector: 'endorsed-by-list',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./endorsed-by-list.html'),\n  styles: []\n})\nexport class EndorsedByListComponent {\n\t@Input() endorsements:Array<Endorsement>;\n\t@Input() isLoading:boolean;\n\t@Input() title:string;\n\n\tprivate cardTitle:string;\n\n\tprivate oldEndorsements:Array<Endorsement>;\n\tpublic entityImageList: Array<EntityImageModel>;\n\n  constructor(private logoService: LogoService, private authService: AuthService, private orgService:OrganizationsService, private navigationHelper:NavigationHelperService) {\n  }\n\n  ngOnInit() {\n  \tthis.cardTitle = this.title;\n\t  this.generateEntityImageList();\n  }\n\n\tngOnChanges() {\n\t\tthis.cardTitle = this.title;\n\t\tthis.generateEntityImageList();\n\t}\n\n\tpublic gotoDetails(entityModel:EntityImageModel) {\n\t\tif (this.isMyOrg(entityModel.entityId)) {\n\t\t\tthis.navigationHelper.takeMeHome();\n\t\t} else {\n\t\t\tthis.navigationHelper.navigateToOrganizationDetails(entityModel.entityId)\n\t\t}\n\t}\n\n\tprivate isMyOrg(orgMrn) {\n\t\treturn this.authService.authState.orgMrn === orgMrn;\n\t}\n\n  private generateEntityImageList() {\n  \tif (this.endorsements) {\n  \t\tif (this.endorsements !== this.oldEndorsements) { // Check to see if the endorsements is the same as last time we generated the list, because no need to do all this load again if not needed\n\t\t\t\tthis.oldEndorsements = this.endorsements;\n\t\t\t  this.entityImageList = [];\n\t\t\t  this.endorsements.forEach(endorsement => {\n\t\t\t\t\t\tlet entityImage:EntityImageModel = {imageSourceObservable:this.createImgObservable(endorsement.orgMrn), entityId:endorsement.orgMrn, title:endorsement.orgName};\n\n\t\t\t\t    this.entityImageList.push(entityImage);\n\t\t\t\t  }\n\t\t\t  );\n\t\t  }\n\t  }\n  }\n\n  private createImgObservable(orgMrn:string):Observable<string> {\n\t  let imageSrc = 'assets/img/no_organization.png';\n\t  return Observable.create(observer => {\n\t\t  this.logoService.getLogoForOrganization(orgMrn).subscribe(\n\t\t\t  logo => {\n\t\t\t\t  observer.next(URL.createObjectURL(new Blob([logo])));\n\t\t\t  },\n\t\t\t  err => {\n\t\t\t\t  observer.next(imageSrc);\n\t\t\t  }\n\t\t  );\n\t  });\n  }\n\n\tprivate setRealOrganizationName(entityImage:EntityImageModel, organizationMrn:string) {\n\t\tthis.orgService.getOrganizationName(organizationMrn).subscribe(\n\t\t\torganizationName => {\n\t\t\t\tentityImage.title = organizationName;\n\t\t\t},\n\t\t\terr => {\n\t\t\t\t// Do nothing. We already have a name set, which should be correct 99% of the time\n\t\t\t}\n\t\t);\n\t}\n\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/endorsed-by-list/endorsed-by-list.component.ts","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-lg-12\\\">\\n    <ba-card title=\\\"{{cardTitle}}\\\" baCardClass=\\\"with-scroll table-panel\\\">\\n      <mc-entity-image-list [noDataText]=\\\"'None'\\\" [isLoading]=\\\"isLoading\\\" [entityImageList]=\\\"entityImageList\\\" (onClick)=\\\"gotoDetails($event)\\\"></mc-entity-image-list>\\n    </ba-card>\\n  </div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/endorsed-by-list/endorsed-by-list.html\n// module id = ./src/app/pages/shared/components/endorsed-by-list/endorsed-by-list.html\n// module chunks = 0 1 2 3 4","import { Component, Input, OnChanges, ViewEncapsulation } from '@angular/core';\nimport {\n    TableCell,\n    TableHeader,\n    TableRow\n} from \"../../../../theme/components/mcTable/mcTable.component\";\nimport { Instance } from \"../../../../backend-api/service-registry/autogen/model/Instance\";\nimport {\n    MCNotificationsService,\n    MCNotificationType\n} from \"../../../../shared/mc-notifications.service\";\nimport { OrganizationsService } from \"../../../../backend-api/identity-registry/services/organizations.service\";\nimport { McUtils } from \"../../../../shared/mc-utils\";\n\n@Component({\n  selector: 'instances-table',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./instances-table.html'),\n  styles: []\n})\nexport class InstancesTableComponent implements OnChanges {\n  @Input() instances: Array<Instance>;\n  @Input() isLoading: boolean;\n  @Input() onRowClick: (index:number) => void;\n  public tableHeaders: Array<TableHeader>;\n  public tableRows: Array<TableRow>;\n  constructor(private orgsService: OrganizationsService, private notifications: MCNotificationsService) {\n  }\n  ngOnInit() {\n  }\n  ngOnChanges() {\n    if (this.instances) {\n      this.generateHeadersAndRows();\n    }\n  }\n  private generateHeadersAndRows() {\n    var tableHeaders: Array<TableHeader> = [];\n    var tableRows: Array<TableRow> = [];\n\n    var tableHeader: TableHeader = {title:'Name', class:''};\n    tableHeaders.push(tableHeader);\n\n    tableHeader = {title:'Version', class:'nowrap align-center'};\n    tableHeaders.push(tableHeader);\n\n    tableHeader = {title:'Status', class:'nowrap'};\n    tableHeaders.push(tableHeader);\n\n\t  tableHeader = {title:'Compliant', class:'nowrap'};\n\t  tableHeaders.push(tableHeader);\n\n\t  tableHeader = {title:'Organization', class:'nowrap'};\n\t  tableHeaders.push(tableHeader);\n\n\t  tableHeader = {title:'Service endpoint', class:''};\n\t  tableHeaders.push(tableHeader);\n\n\t  tableHeader = {title:'Description', class:''};\n\t  tableHeaders.push(tableHeader);\n\n    for (let instance of this.instances) {\n      var cells:Array<TableCell> = [];\n\n      var tableCell: TableCell = {valueHtml:instance.name, class:'', truncateNumber:45};\n      cells.push(tableCell);\n\n      tableCell = {valueHtml:instance.version, class:'nowrap align-center', truncateNumber:0};\n      cells.push(tableCell);\n\n\t    tableCell = {valueHtml:instance.status, class:'nowrap', truncateNumber:0};\n\t    cells.push(tableCell);\n\n\t    let compliantClass = instance.compliant ? '' : 'label-danger';\n\t    tableCell = {valueHtml:McUtils.getYesNoString(instance.compliant), class:'nowrap ' + compliantClass, truncateNumber:0};\n\t    cells.push(tableCell);\n\n\t    tableCell = {valueHtml:'', class:'nowrap', truncateNumber:25};\n\t    this.setOrganizationCell(tableCell, instance.organizationId);\n\t    cells.push(tableCell);\n\n\t    tableCell = {valueHtml:instance.endpointUri, class:'list-endpoint', truncateNumber:60};\n\t    cells.push(tableCell);\n\n      tableCell = {valueHtml:instance.description, class:'table-description-short', truncateNumber:150};\n      cells.push(tableCell);\n\n      let tableRow: TableRow = {cells: cells};\n      tableRows.push(tableRow);\n    }\n\n    this.tableHeaders = tableHeaders;\n    this.tableRows = tableRows;\n  }\n\n\tprivate setOrganizationCell(tableCell: TableCell, organizationId) {\n\t\tthis.orgsService.getOrganizationName(organizationId).subscribe(\n\t\t\torganizationName => {\n\t\t\t\ttableCell.valueHtml = organizationName;\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to get organization', MCNotificationType.Error, err);\n\t\t\t}\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/instances-table/instances-table.component.ts","module.exports = \"<mc-table [tableHeaders]=\\\"tableHeaders\\\" [tableRows]=\\\"tableRows\\\" [isLoading]=\\\"isLoading\\\" [onRowClick]=\\\"onRowClick\\\"></mc-table>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/instances-table/instances-table.html\n// module id = ./src/app/pages/shared/components/instances-table/instances-table.html\n// module chunks = 0 1 2 3 4","import {\n\tComponent,\n\tEventEmitter,\n\tInput,\n\tOnChanges,\n\tOutput,\n\tViewEncapsulation\n} from '@angular/core';\nimport { LabelValueModel } from \"../../../../theme/components/mcLabelValueTable/mcLabelValueTable.component\";\nimport { Organization } from \"../../../../backend-api/identity-registry/autogen/model/Organization\";\nimport { OrganizationViewModelService } from \"../../services/organization-view-model.service\";\nimport { LogoService } from \"../../../../backend-api/identity-registry/services/logo.service\";\nimport { AuthPermission, AuthService } from \"../../../../authentication/services/auth.service\";\nimport {\n\tMCNotificationsService,\n\tMCNotificationType\n} from \"../../../../shared/mc-notifications.service\";\n\n@Component({\n  selector: 'organization-details-table',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./organization-details-table.html'),\n  styles: []\n})\nexport class OrganizationDetailsTableComponent implements OnChanges {\n  private labelValues:Array<LabelValueModel>;\n\t@Input() displayLogo:boolean = true;\n  @Input() isLoading:boolean;\n\t@Input() organization: Organization;\n\t@Output() onLogoLoaded: EventEmitter<any> = new EventEmitter<any>();\n\tpublic logo:string;\n\tpublic canChangeLogo:boolean;\n\tpublic isLoadingOrgAndLogo:boolean = true;\n\tpublic uploadingLogo:boolean = false;\n  constructor(private authService:AuthService, private logoService: LogoService, private orgViewModelService: OrganizationViewModelService, private notifications:MCNotificationsService) {\n  }\n  ngOnChanges() {\n    if (this.organization) {\n\t    this.canChangeLogo = this.canChangeTheLogo();\n\t    this.loadLogo();\n    }\n  }\n\n  public uploadLogo(logo:any) {\n\t  let oldLogo = this.logo;\n\t  this.uploadingLogo = true;\n\t  this.logoService.uploadLogo(this.organization.mrn, logo).subscribe(\n\t\t  logo => {\n\t\t\t  this.loadLogo();\n\t\t  },\n\t\t  err => {\n\t\t\t  this.logo = oldLogo;\n\t\t\t  this.uploadingLogo = false;\n\t\t\t  this.notifications.generateNotification('Error', 'Error when trying to upload logo', MCNotificationType.Error, err);\n\t\t  }\n\t  );\n  }\n\n  private setLabelValues() {\n\t  this.labelValues = this.orgViewModelService.generateLabelValuesForOrganization(this.organization);\n\t  this.isLoadingOrgAndLogo = false;\n  }\n\n\tprivate loadLogo(){\n\t\tthis.logoService.getLogoForOrganization(this.organization.mrn).subscribe(\n\t\t\tlogo => {\n\t\t\t\tthis.logo = URL.createObjectURL(new Blob([logo]));\n\t\t\t\tthis.setLabelValues();\n\t\t\t\tthis.uploadingLogo = false;\n\t\t\t\tthis.onLogoLoaded.emit('');\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (this.canChangeTheLogo()) {\n\t\t\t\t\tthis.logo = 'assets/img/no_organization.png';\n\t\t\t\t}\n\t\t\t\tthis.setLabelValues();\n\t\t\t\tthis.uploadingLogo = false;\n\t\t\t\tthis.onLogoLoaded.emit('');\n\t\t\t}\n\t\t);\n\t}\n\tprivate canChangeTheLogo():boolean {\n\t\treturn this.authService.authState.hasPermission(AuthPermission.OrgAdmin);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/organizaton-details-table/organization-details-table.component.ts","module.exports = \"<div *ngIf=\\\"displayLogo && logo\\\" style=\\\"margin-bottom: 10px;\\\">\\n  <img class=\\\"logo-image-no-center\\\" [attr.src]=\\\"logo | sanitizeUrl\\\" *ngIf=\\\"logo && !canChangeLogo\\\">\\n  <mc-logo-uploader [logo]=\\\"logo\\\" [uploadingLogo]=\\\"uploadingLogo\\\" (onUpload)=\\\"uploadLogo($event)\\\" *ngIf=\\\"logo && canChangeLogo\\\"></mc-logo-uploader>\\n</div>\\n<mc-label-value-table [isLoading]=\\\"isLoadingOrgAndLogo\\\" [labelValues]=\\\"labelValues\\\"></mc-label-value-table>\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/organizaton-details-table/organization-details-table.html\n// module id = ./src/app/pages/shared/components/organizaton-details-table/organization-details-table.html\n// module chunks = 0 1 2 3 4","import { Component, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';\nimport { LabelValueModel } from \"../../../../theme/components/mcLabelValueTable/mcLabelValueTable.component\";\nimport { Service } from \"../../../../backend-api/identity-registry/autogen/model/Service\";\nimport { CertificateEntityType } from \"../../services/certificate-helper.service\";\nimport { FileHelperService } from \"../../../../shared/file-helper.service\";\nimport { AuthPermission, AuthService } from \"../../../../authentication/services/auth.service\";\nimport { ServiceViewModel } from \"../../../org-identity-registry/services/view-models/ServiceViewModel\";\nimport {\n\tMCNotificationsService,\n\tMCNotificationType\n} from \"../../../../shared/mc-notifications.service\";\nimport { IdServicesService } from \"../../../../backend-api/identity-registry/services/id-services.service\";\nimport { NavigationHelperService } from \"../../../../shared/navigation-helper.service\";\nimport { TOKEN_DELIMITER } from \"../../../../shared/app.constants\";\nimport { InstancesService } from \"../../../../backend-api/service-registry/services/instances.service\";\n\n@Component({\n  selector: 'service-details-view',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./service-details-view.html'),\n  styles: []\n})\nexport class ServiceDetailsViewComponent {\n\t@Input() service:Service;\n\t@Input() shouldShowDelete:boolean = true;\n\t@Input() shouldShowUpdate:boolean = true;\n\t@Input() shouldShowLinkToInstance:boolean = true;\n\t@Input() isLoading:boolean;\n\t@Input() title:string;\n\n\t@Output() deleteAction:EventEmitter<any> = new EventEmitter<any>();\n\t@Output() updateAction:EventEmitter<any> = new EventEmitter<any>();\n\n\tpublic labelValues:Array<LabelValueModel>;\n\tpublic entityType: CertificateEntityType;\n\tpublic entityMrn:string;\n\tpublic onGotoVessel: Function;\n\tpublic onGotoInstance: Function;\n\tprivate linkToInstance:boolean = false;\n\tpublic isLoadingInstance:boolean = false;\n\n\tconstructor(private fileHelperService:FileHelperService, private authService: AuthService, private servicesService: IdServicesService, private notifications:MCNotificationsService, private navigationHelperService: NavigationHelperService, private instancesService:InstancesService) {\n\n\t}\n\n\tngOnInit() {\n\t\tthis.isLoadingInstance = true;\n\t\tthis.entityType = CertificateEntityType.Service;\n\t\tthis.onGotoVessel = this.gotoVessel.bind(this);\n\t\tthis.onGotoInstance = this.gotoInstance.bind(this);\n\t}\n\n\tngOnChanges() {\n\t\tif (this.service) {\n\t\t\tthis.entityMrn = this.service.mrn + TOKEN_DELIMITER + this.service.instanceVersion;\n\t\t\tif (this.shouldShowLinkToInstance) {\n\t\t\t\tthis.loadInstance();\n\t\t\t} else {\n\t\t\t\tthis.generateLabelValues();\n\t\t\t\tthis.isLoadingInstance = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate loadInstance() {\n\t\tthis.instancesService.getInstance(this.service.mrn, this.service.instanceVersion).subscribe(\n\t\t\tinstance => {\n\t\t\t\tthis.linkToInstance = true;\n\t\t\t\tthis.generateLabelValues();\n\t\t\t\tthis.isLoadingInstance = false;\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err.status == 404) {\n\t\t\t\t\tthis.linkToInstance = false;\n\t\t\t\t\tthis.generateLabelValues();\n\t\t\t\t} else {\n\t\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to get the Instance for the ID service', MCNotificationType.Error, err);\n\t\t\t\t}\n\t\t\t\tthis.isLoadingInstance = false;\n\t\t\t}\n\t\t);\n\t}\n\n\tpublic showDownload():boolean {\n\t\treturn this.service.oidcClientId && this.isAdmin();\n\t}\n\n\tpublic downloadXML() {\n\t\tthis.servicesService.getIdServiceJbossXml(this.service.mrn, this.service.instanceVersion).subscribe(\n\t\t\txmlString => {\n\t\t\t\tthis.fileHelperService.downloadFile(xmlString, 'text/xml', 'keycloak-oidc-subsystem.xml');\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.isLoading = false;\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to download the XML', MCNotificationType.Error, err);\n\t\t\t}\n\t\t);\n\t}\n\n\tpublic downloadJSON() {\n\t\tthis.servicesService.getServiceKeycloakJson(this.service.mrn, this.service.instanceVersion).subscribe(\n\t\t\tjsonString => {\n\t\t\t\tthis.fileHelperService.downloadFile(jsonString, 'text/json', 'keycloak.json');\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.isLoading = false;\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to download the JSON', MCNotificationType.Error, err);\n\t\t\t}\n\t\t);\n\t}\n\n\tpublic generateLabelValues() {\n\t\tthis.labelValues = [];\n\t\tif (this.service) {\n\t\t\tthis.labelValues.push({label: 'MRN', valueHtml: this.service.mrn});\n\t\t\tthis.labelValues.push({label: 'Name', valueHtml: this.service.name});\n\t\t\tthis.labelValues.push({label: 'Version', valueHtml: this.service.instanceVersion});\n\t\t\tthis.labelValues.push({label: 'Permissions', valueHtml: this.service.permissions});\n\t\t\tthis.labelValues.push({label: 'Certificate domain name', valueHtml: this.service.certDomainName});\n\t\t\tif (this.service.oidcRedirectUri) {\n\t\t\t\tthis.labelValues.push({label: 'OIDC Redirect URI', valueHtml: this.service.oidcRedirectUri});\n\t\t\t}\n\t\t\tif (this.service.oidcClientId) {\n\t\t\t\tthis.labelValues.push({label: 'OIDC Client ID', valueHtml: this.service.oidcClientId});\n\t\t\t}\n\t\t\tif (this.service.oidcClientSecret) {\n\t\t\t\tthis.labelValues.push({label: 'OIDC Client Secret', valueHtml: this.service.oidcClientSecret});\n\t\t\t}\n\n\t\t\tif (this.service.oidcAccessType) {\n\t\t\t\tthis.labelValues.push({label: 'Access type', valueHtml: ServiceViewModel.getLabelForEnum(this.service.oidcAccessType)});\n\t\t\t}\n\n\t\t\tthis.generateLabelValueForVessel();\n\n\t\t\tthis.generateLabelValueForInstance();\n\t\t}\n\t}\n\n\tprivate generateLabelValueForVessel() {\n\t\tlet vessel = this.service.vessel;\n\t\tif (vessel) {\n\t\t\tlet label = 'Linked vessel';\n\t\t\tthis.labelValues.push({label: label, valueHtml: vessel.name, linkFunction: this.onGotoVessel, linkValue: [vessel.mrn]});\n\t\t}\n\t}\n\n\tprivate generateLabelValueForInstance() {\n\t\tif (this.shouldShowLinkToInstance && this.linkToInstance) {\n\t\t\tlet label = 'Linked Instance';\n\t\t\tthis.labelValues.push({label: label, valueHtml: this.service.name, linkFunction: this.onGotoInstance, linkValue: [this.service.mrn, this.service.instanceVersion]});\n\t\t}\n\t}\n\n\tpublic showDelete():boolean {\n\t\treturn this.shouldShowDelete && this.isAdmin() && this.service != null;\n\t}\n\n\tpublic showUpdate():boolean {\n\t\treturn this.shouldShowUpdate && this.isAdmin() && this.service != null;\n\t}\n\n\tprivate isAdmin() {\n\t\treturn this.authService.authState.hasPermission(AuthPermission.ServiceAdmin);\n\t}\n\n\tprivate delete() {\n\t\tthis.deleteAction.emit('');\n\t}\n\n\tprivate update() {\n\t\tthis.updateAction.emit('');\n\t}\n\n\tprivate gotoInstance(linkValue:any) {\n\t\ttry {\n\t\t\tthis.navigationHelperService.navigateToOrgInstance(linkValue[0], linkValue[1]);\n\t\t} catch (error) {\n\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to go to instance', MCNotificationType.Error, error);\n\t\t}\n\t}\n\n\tprivate gotoVessel(linkValue:any) {\n\t\ttry {\n\t\t\tthis.navigationHelperService.navigateToVessel(linkValue[0]);\n\t\t} catch (error) {\n\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to go to vessel', MCNotificationType.Error, error);\n\t\t}\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/service-details-view/service-details-view.component.ts","module.exports = \"<ba-card title=\\\"{{title}}\\\" baCardClass=\\\"with-scroll table-panel\\\">\\n  <mc-label-value-table [isLoading]=\\\"isLoading || isLoadingInstance\\\" [labelValues]=\\\"labelValues\\\"></mc-label-value-table>\\n  <ul *ngIf=\\\"!isLoading && service && (showDownload() || showDelete() || showUpdate())\\\" class=\\\"btn-list clearfix\\\">\\n    <li *ngIf=\\\"showDownload()\\\">\\n      <button type=\\\"button\\\" class=\\\"btn btn-primary btn-raised\\\" (click)=\\\"downloadXML()\\\">Download JBOSS XML</button>\\n    </li>\\n    <li *ngIf=\\\"showDownload()\\\">\\n      <button type=\\\"button\\\" class=\\\"btn btn-primary btn-raised\\\" (click)=\\\"downloadJSON()\\\">Download Keycloak JSON</button>\\n    </li>\\n    <li *ngIf=\\\"showUpdate()\\\">\\n      <button type=\\\"button\\\" class=\\\"btn btn-primary btn-raised\\\" (click)=\\\"update()\\\">Update</button>\\n    </li>\\n    <li *ngIf=\\\"showDelete()\\\">\\n      <button type=\\\"button\\\" class=\\\"btn btn-danger btn-raised\\\" (click)=\\\"delete()\\\">Delete Service</button>\\n    </li>\\n  </ul>\\n</ba-card>\\n\\n<div *ngIf=\\\"service\\\">\\n  <ba-card title=\\\"Certificates for {{service.name}}\\\" baCardClass=\\\"with-scroll table-panel\\\">\\n    <certificates-table [isAdmin]=\\\"isAdmin()\\\" [entityMrn]=\\\"entityMrn\\\" [isLoading]=\\\"isLoading\\\" [certificateTitle]=\\\"service.name\\\" [certificateEntityType]=\\\"entityType\\\" [certificates]=\\\"service.certificates\\\"></certificates-table>\\n  </ba-card>\\n</div>\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/service-details-view/service-details-view.html\n// module id = ./src/app/pages/shared/components/service-details-view/service-details-view.html\n// module chunks = 0 1 2 3 4","import {\n\tChangeDetectorRef,\n\tComponent,\n\tEventEmitter,\n\tInput,\n\tOnDestroy,\n\tOutput,\n\tViewEncapsulation\n} from '@angular/core';\nimport {\n\tMCNotificationsService,\n\tMCNotificationType\n} from \"../../../../shared/mc-notifications.service\";\nimport { OrganizationsService } from \"../../../../backend-api/identity-registry/services/organizations.service\";\nimport { ServiceRegistrySearchRequest } from \"./ServiceRegistrySearchRequest\";\nimport { FormBuilder, FormControl, FormGroup } from \"@angular/forms\";\nimport { Organization } from \"../../../../backend-api/identity-registry/autogen/model/Organization\";\nimport { AuthService } from \"../../../../authentication/services/auth.service\";\nimport { SrSearchRequestsService } from \"../../../org-service-registry/shared/services/sr-search-requests.service\";\nimport { SHOW_ENDORSEMENTS } from \"../../../../shared/app.constants\";\n\ninterface SelectModel {\n\tlabel:string;\n\tvalue:string;\n}\n\n@Component({\n  selector: 'service-registry-search',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./service-registry-search.html'),\n\tstyles: [require('./service-registry-search.scss')]\n})\nexport class ServiceRegistrySearchComponent implements OnDestroy {\n\t@Input() searchTitle: string;\n\t@Input() searchKey: string;\n\t@Input() isSearching: boolean;\n\t@Input() preFilterMyOrg: boolean;\n\t@Input() showEndorsement: boolean;\n\t@Input() showKeywords: boolean = true;\n\t@Output() onSearch:EventEmitter<ServiceRegistrySearchRequest> = new EventEmitter<ServiceRegistrySearchRequest>();\n\tprivate endorsementMainSwitch = SHOW_ENDORSEMENTS;\n\n\tpublic isLoading: boolean;\n\tpublic formGroup: FormGroup;\n\tpublic selectValuesOrganizations:Array<SelectModel>;\n\tpublic selectValuesOrganizationsForEndorsement:Array<SelectModel>;\n\tpublic onSearchFunction: Function;\n\tpublic isCollapsed:boolean;\n\tpublic collapsedClass:string;\n\tpublic toggleClass:string;\n\n  constructor(private searchRequestsService:SrSearchRequestsService, private changeDetector: ChangeDetectorRef, private authService:AuthService, formBuilder:FormBuilder, private orgsService: OrganizationsService, private notifications: MCNotificationsService) {\n  \tthis.formGroup = formBuilder.group({});\n  }\n\n\tngOnDestroy() {\n\t\tthis.changeDetector.detach();\n\t}\n\n\tngOnInit() {\n\t\tthis.onSearchFunction = this.search.bind(this);\n\t\tthis.isCollapsed = false;\n\t\tthis.setClass();\n  \tthis.isLoading = true;\n\t\tthis.generateForm();\n  \tthis.loadOrganizations();\n\t}\n\n\tpublic toggle() {\n\t\tthis.isCollapsed = !this.isCollapsed;\n\t\tthis.setClass();\n\t}\n\n\tprivate setClass() {\n\t\tthis.toggleClass = this.isCollapsed ? 'fa fa-caret-square-o-down' : 'fa fa-caret-square-o-up';\n\t}\n\n\tpublic search() {\n\t\tlet keywords = this.formGroup.value.keywords;\n\n\t\tlet endorsedBy:string;\n\t\tlet registeredBy:string;\n\n\t\tlet registeredByValue = this.formGroup.value.registeredBy;\n\t\tif (registeredByValue && registeredByValue.toLowerCase().indexOf('undefined') < 0) {\n\t\t\tregisteredBy = registeredByValue;\n\t\t}\n\n\t\tlet endorsedByValue = this.formGroup.value.endorsedBy;\n\t\tif (endorsedByValue && endorsedByValue.toLowerCase().indexOf('undefined') < 0) {\n\t\t\tendorsedBy = endorsedByValue;\n\t\t}\n\t\tthis.doSearch(keywords, registeredBy, endorsedBy);\n\t}\n\n\tprivate searchFromRegisteredBy(registeredBy) {\n\t\tlet keywords = this.formGroup.value.keywords;\n\n\t\tlet endorsedBy:string;\n\n\t\tif (registeredBy && registeredBy.toLowerCase().indexOf('undefined') > -1) {\n\t\t\tregisteredBy = undefined;\n\t\t}\n\n\t\tlet endorsedByValue = this.formGroup.value.endorsedBy;\n\t\tif (endorsedByValue && endorsedByValue.toLowerCase().indexOf('undefined') < 0) {\n\t\t\tendorsedBy = endorsedByValue;\n\t\t}\n\t\tthis.doSearch(keywords, registeredBy, endorsedBy);\n\t}\n\n\tprivate searchFromEndorsedBy(endorsedBy:string) {\n\t\tlet keywords = this.formGroup.value.keywords;\n\n\t\tlet registeredBy:string;\n\n\n\t\tlet registeredByValue = this.formGroup.value.registeredBy;\n\t\tif (registeredByValue && registeredByValue.toLowerCase().indexOf('undefined') < 0) {\n\t\t\tregisteredBy = registeredByValue;\n\t\t}\n\n\t\tif (endorsedBy && endorsedBy.toLowerCase().indexOf('undefined') > -1) {\n\t\t\tendorsedBy = undefined;\n\t\t}\n\n\t\tthis.doSearch(keywords, registeredBy, endorsedBy);\n\t}\n\n\tprivate doSearch(keywords:string, registeredBy:string, endorsedBy:string) {\n\t\tlet searchRequest: ServiceRegistrySearchRequest = {keywords:keywords, registeredBy:registeredBy, endorsedBy:endorsedBy};\n\t\tthis.searchRequestsService.addSearchRequest(this.searchKey, searchRequest);\n\t\tthis.notifications.errorLog = null; // Remove error log if it is present\n\t\tthis.onSearch.emit(searchRequest);\n\t}\n\n\tprivate generateForm() {\n\t\tvar formControl = new FormControl('');\n\t\tthis.formGroup.addControl('keywords', formControl);\n\n\t\tformControl = new FormControl(undefined);\n\t\tthis.formGroup.addControl('registeredBy', formControl);\n\n\t\tformControl = new FormControl(undefined);\n\t\tthis.formGroup.addControl('endorsedBy', formControl);\n\t}\n\n\tprivate loadOrganizations() {\n\t\tthis.orgsService.getAllOrganizations().subscribe(\n\t\t\torganizations => {\n\t\t\t\tthis.setupSearchRequest(organizations);\n\t\t\t\tthis.isLoading = false;\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.setupSearchRequest([]);\n\t\t\t\tthis.isLoading = false;\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to get organizations', MCNotificationType.Error, err);\n\t\t\t}\n\t\t);\n\t}\n\n\tprivate setupSearchRequest(organizations:Array<Organization>) {\n\t\tthis.selectValuesOrganizations = [];\n\t\tthis.selectValuesOrganizations.push({value:undefined, label:'All'});\n\t\tthis.selectValuesOrganizationsForEndorsement = [];\n\t\tthis.selectValuesOrganizationsForEndorsement.push({value:undefined, label:'No filter'});\n\n\t\torganizations.forEach(organization => {\n\t\t\tthis.selectValuesOrganizations.push({value:organization.mrn, label:organization.name});\n\t\t\tthis.selectValuesOrganizationsForEndorsement.push({value:organization.mrn, label:organization.name});\n\t\t});\n\t\tvar registeredBy:string;\n\t\tvar endorsedBy:string;\n\t\tvar keywords:string = '';\n\t\tlet searchRequest = this.searchRequestsService.getSearchRequest(this.searchKey);\n\t\tif (searchRequest) {\n\t\t\tregisteredBy = searchRequest.registeredBy;\n\t\t\tendorsedBy = searchRequest.endorsedBy;\n\t\t\tif (searchRequest.keywords) {\n\t\t\t\tkeywords = searchRequest.keywords;\n\t\t\t}\n\t\t} else if (this.preFilterMyOrg){\n\t\t\tregisteredBy = this.authService.authState.orgMrn;\n\t\t}\n\t\tthis.formGroup.patchValue({registeredBy: registeredBy});\n\t\tthis.formGroup.patchValue({endorsedBy: endorsedBy});\n\t\tthis.formGroup.patchValue({keywords: keywords});\n\n\t\tthis.formGroup.controls['registeredBy'].valueChanges.subscribe(param => this.searchFromRegisteredBy(param));\n\t\tthis.formGroup.controls['endorsedBy'].valueChanges.subscribe(param => this.searchFromEndorsedBy(param));\n\n\t\tthis.changeDetector.detectChanges();\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/service-registry-search/service-registry-search.component.ts","module.exports = \"<a class=\\\"search-link\\\" (click)=\\\"toggle()\\\">\\n  <h4>{{searchTitle}} <i style=\\\"margin-left:2px;color: white; font-size: 16px;\\\" class=\\\"{{toggleClass}}\\\" aria-hidden=\\\"true\\\"></i></h4>\\n</a>\\n<div class=\\\"mc-form-group\\\" style=\\\"margin-bottom: 0px !important;\\\" *ngIf=\\\"!isCollapsed && !isLoading && formGroup\\\">\\n  <form [formGroup]=\\\"formGroup\\\">\\n    <div *ngIf=\\\"showKeywords\\\" class=\\\"row\\\">\\n      <div class=\\\"col-sm-12\\\">\\n        <div [formGroup]=\\\"formGroup\\\" class=\\\"form-group mc-form-group\\\">\\n          <label class=\\\"mc-form-label\\\">Keywords\\n            <div class=\\\"input-group\\\">\\n              <input type=\\\"text\\\" class=\\\"form-control mc-form-control\\\" formControlName=\\\"keywords\\\">\\n              <span class=\\\"mc-form-control-input-group-btn input-group-btn\\\">\\n                <mc-loading-button [type]=\\\"'submit'\\\" [class]=\\\"'btn btn-primary search-button'\\\" [isLoading]=\\\"isSearching\\\" [title]=\\\"'Search'\\\" [onClick]=\\\"onSearchFunction\\\" ></mc-loading-button>\\n              </span>\\n            </div>\\n          </label>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\\\"row\\\">\\n      <div class=\\\"col-sm-6\\\">\\n        <div [formGroup]=\\\"formGroup\\\" class=\\\"form-group mc-form-group\\\" style=\\\"margin-bottom: 0px !important;\\\">\\n          <label class=\\\"mc-form-label\\\">Registered by\\n            <select class=\\\"form-control mc-form-control mc-form-control-select\\\" formControlName=\\\"registeredBy\\\">\\n              <option *ngFor=\\\"let selectValue of selectValuesOrganizations\\\" [ngValue]=\\\"selectValue.value\\\">\\n                {{selectValue.label}}\\n              </option>\\n            </select>\\n          </label>\\n        </div>\\n      </div>\\n      <div *ngIf=\\\"showEndorsement && endorsementMainSwitch\\\" class=\\\"col-sm-6\\\">\\n        <div [formGroup]=\\\"formGroup\\\" class=\\\"form-group mc-form-group\\\" style=\\\"margin-bottom: 0px !important;\\\">\\n          <label class=\\\"mc-form-label\\\">Endorsed by\\n            <select class=\\\"form-control mc-form-control mc-form-control-select\\\" formControlName=\\\"endorsedBy\\\">\\n              <option *ngFor=\\\"let selectValue of selectValuesOrganizationsForEndorsement\\\" [ngValue]=\\\"selectValue.value\\\">\\n                {{selectValue.label}}\\n              </option>\\n            </select>\\n          </label>\\n        </div>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n<div *ngIf=\\\"!isCollapsed\\\">\\n  <sk-fading-circle [isRunning]=\\\"isLoading\\\" ></sk-fading-circle>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/service-registry-search/service-registry-search.html\n// module id = ./src/app/pages/shared/components/service-registry-search/service-registry-search.html\n// module chunks = 0 1 2 3 4","module.exports = \".mc-form-label {\\n  width: 100%; }\\n\\n.mc-form-control {\\n  margin-top: 5px; }\\n\\n.mc-form-control:read-only {\\n  cursor: not-allowed;\\n  color: rgba(255, 255, 255, 0.7); }\\n\\n.mc-form-control-success {\\n  border: 1px solid #8bd22f !important; }\\n  .mc-form-control-success:focus {\\n    border: 1px solid #aee06d !important; }\\n\\n.mc-form-control-error {\\n  border: 1px solid #f95372 !important; }\\n  .mc-form-control-error:focus {\\n    border: 1px solid #fb879c !important; }\\n\\n.mc-form-group {\\n  max-width: 450px;\\n  margin-bottom: 0.5rem !important; }\\n\\n.mc-form-control-feedback {\\n  top: 20px !important;\\n  right: 10px !important; }\\n\\n.mc-form-control-select:read-only {\\n  cursor: default !important;\\n  color: #ffffff !important; }\\n\\n.search-link {\\n  cursor: pointer;\\n  color: #ffffff; }\\n  .search-link:hover {\\n    transform: none;\\n    color: #ffffff; }\\n\\n.mc-form-control-input-group-btn {\\n  padding-top: 5px; }\\n\\n.search-button {\\n  border-bottom-left-radius: 0 !important;\\n  border-top-left-radius: 0 !important; }\\n  .search-button:hover {\\n    transform: none; }\\n\\n.input-group {\\n  margin-bottom: 0px !important; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/service-registry-search/service-registry-search.scss\n// module id = ./src/app/pages/shared/components/service-registry-search/service-registry-search.scss\n// module chunks = 0 1 2 3 4","import { Component, Input, OnChanges, ViewEncapsulation } from '@angular/core';\nimport {\n\tTableCell,\n\tTableHeader,\n\tTableRow\n} from \"../../../../theme/components/mcTable/mcTable.component\";\nimport {\n\tMCNotificationsService,\n\tMCNotificationType\n} from \"../../../../shared/mc-notifications.service\";\nimport { InstancesService } from \"../../../../backend-api/service-registry/services/instances.service\";\nimport { BugReportingService } from \"../../../../backend-api/identity-registry/services/bug-reporting.service\";\nimport { BugReport } from \"../../../../backend-api/identity-registry/autogen/model/BugReport\";\nimport { Service } from \"../../../../backend-api/identity-registry/autogen/model/Service\";\nimport { OrganizationsService } from \"../../../../backend-api/identity-registry/services/organizations.service\";\nimport { NavigationHelperService } from \"../../../../shared/navigation-helper.service\";\n\n@Component({\n  selector: 'services-table',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./services-table.html'),\n  styles: []\n})\nexport class ServicesTableComponent implements OnChanges {\n  @Input() services: Array<Service>;\n  @Input() isLoading: boolean;\n\tpublic onRowClick: Function;\n  public tableHeaders: Array<TableHeader>;\n  public tableRows: Array<TableRow>;\n  constructor(private navigationHelperService:NavigationHelperService, private orgsService:OrganizationsService, private notifications: MCNotificationsService, private instancesService: InstancesService, private bugService: BugReportingService) {\n  }\n  ngOnInit() {\n\t  this.onRowClick = this.gotoService.bind(this);\n  }\n  ngOnChanges() {\n    if (this.services) {\n\t    this.loadMyOrganization();\n    }\n  }\n\n\tprivate loadMyOrganization() {\n\t\tthis.orgsService.getMyOrganization().subscribe(\n\t\t\torganization => {\n\t\t\t\tthis.generateHeadersAndRows(organization.mrn);\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to get organization', MCNotificationType.Error, err);\n\t\t\t}\n\t\t);\n\t}\n\n  private generateHeadersAndRows(orgMrn:string) {\n    var tableHeaders: Array<TableHeader> = [];\n    var tableRows: Array<TableRow> = [];\n\n    var tableHeader: TableHeader = {title:'Name', class:''};\n    tableHeaders.push(tableHeader);\n\n    tableHeader = {title:'Version', class:'nowrap align-center'};\n    tableHeaders.push(tableHeader);\n\n\t  tableHeader = {title:'Organization', class:'nowrap'};\n\t  tableHeaders.push(tableHeader);\n\n    for (let service of this.services) {\n      var cells:Array<TableCell> = [];\n\n      var tableCell: TableCell = {valueHtml:service.name, class:'', truncateNumber:250};\n      cells.push(tableCell);\n\n      tableCell = {valueHtml:service.instanceVersion, class:'nowrap align-center', truncateNumber:0};\n      cells.push(tableCell);\n\n\t    tableCell = {valueHtml:'', class:'nowrap', truncateNumber:30};\n\t    this.setOrganizationCell(tableCell, orgMrn);\n\t    cells.push(tableCell);\n\n      let tableRow: TableRow = {cells: cells};\n      tableRows.push(tableRow);\n    }\n\n    this.tableHeaders = tableHeaders;\n    this.tableRows = tableRows;\n  }\n\n  private setOrganizationCell(tableCell: TableCell, organizationId) {\n\t\tthis.orgsService.getOrganizationName(organizationId).subscribe(\n\t\t\torganizationName => {\n\t\t\t\ttableCell.valueHtml = organizationName;\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.notifications.generateNotification('Error', 'Error when trying to get organization', MCNotificationType.Error, err);\n\t\t\t}\n\t\t);\n\t}\n\n\tprivate gotoService(index:number) {\n  \tlet mrn = this.services[index].mrn;\n  \tlet version = this.services[index].instanceVersion;\n  \tthis.isLoading = true;\n\t\tthis.instancesService.getInstance(mrn, version).subscribe(\n\t\t\tinstance => {\n\t\t\t\tthis.navigationHelperService.navigateToOrgInstance(mrn, version);\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err.status == 404) {\n\t\t\t\t\t// when using the portal only to register instances, this should never happen. However, if someone uses the SR api only then there might be something missing. We log it for further investigation\n\t\t\t\t\tlet bugReport:BugReport = {subject:\"Missing instance\", description:\"There is a service in the IR that doesn't exist in the SR.\\n\\n MRN: \" + mrn + \",\\nVersion: \" + version};\n\t\t\t\t\tthis.bugService.reportBug(bugReport)\n\t\t\t\t}\n\t\t\t\tthis.navigationHelperService.navigateToOrgInstance(mrn, version);\n\n\t\t\t},\n\t\t);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/services-table/services-table.component.ts","module.exports = \"<mc-table [tableHeaders]=\\\"tableHeaders\\\" [tableRows]=\\\"tableRows\\\" [isLoading]=\\\"isLoading\\\" [onRowClick]=\\\"onRowClick\\\"></mc-table>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/services-table/services-table.html\n// module id = ./src/app/pages/shared/components/services-table/services-table.html\n// module chunks = 0 1 2 3 4","import { Component, Input, OnChanges, ViewEncapsulation } from '@angular/core';\nimport { Specification } from \"../../../../backend-api/service-registry/autogen/model/Specification\";\nimport {\n    TableCell,\n    TableHeader,\n    TableRow\n} from \"../../../../theme/components/mcTable/mcTable.component\";\nimport { Organization } from \"../../../../backend-api/identity-registry/autogen/model/Organization\";\nimport { OrganizationsService } from \"../../../../backend-api/identity-registry/services/organizations.service\";\nimport {\n    MCNotificationsService,\n    MCNotificationType\n} from \"../../../../shared/mc-notifications.service\";\n\n@Component({\n  selector: 'specifications-table',\n  encapsulation: ViewEncapsulation.None,\n  template: require('./specifications-table.html'),\n  styles: []\n})\nexport class SpecificationsTableComponent implements OnChanges {\n  @Input() specifications: Array<Specification>;\n  @Input() isLoading: boolean;\n  @Input() onRowClick: (index:number) => void;\n  public tableHeaders: Array<TableHeader>;\n  public tableRows: Array<TableRow>;\n  constructor(private orgsService: OrganizationsService, private notifications: MCNotificationsService) {\n  }\n  ngOnInit() {\n  }\n  ngOnChanges() {\n    if (this.specifications) {\n      this.generateHeadersAndRows();\n    }\n  }\n  private generateHeadersAndRows() {\n    var tableHeaders: Array<TableHeader> = [];\n    var tableRows: Array<TableRow> = [];\n\n    var tableHeader: TableHeader = {title:'Name', class:''};\n    tableHeaders.push(tableHeader);\n\n    tableHeader = {title:'Version', class:'nowrap align-center'};\n    tableHeaders.push(tableHeader);\n\n\t  tableHeader = {title:'Status', class:'nowrap'};\n\t  tableHeaders.push(tableHeader);\n\n\t  tableHeader = {title:'Organization', class:'nowrap'};\n\t  tableHeaders.push(tableHeader);\n\n    tableHeader = {title:'Description', class:''};\n    tableHeaders.push(tableHeader);\n\n    for (let specification of this.specifications) {\n      var cells:Array<TableCell> = [];\n\n      var tableCell: TableCell = {valueHtml:specification.name, class:'', truncateNumber:50};\n      cells.push(tableCell);\n\n      tableCell = {valueHtml:specification.version, class:'nowrap align-center', truncateNumber:0};\n      cells.push(tableCell);\n\n\t    tableCell = {valueHtml:specification.status, class:'nowrap', truncateNumber:0};\n\t    cells.push(tableCell);\n\n\t    tableCell = {valueHtml:'', class:'nowrap', truncateNumber:30};\n\t    this.setOrganizationCell(tableCell, specification.organizationId);\n\t    cells.push(tableCell);\n\n      tableCell = {valueHtml:specification.description, class:'table-description', truncateNumber:250};\n      cells.push(tableCell);\n\n      let tableRow: TableRow = {cells: cells};\n      tableRows.push(tableRow);\n    }\n\n    this.tableHeaders = tableHeaders;\n    this.tableRows = tableRows;\n  }\n\n  private setOrganizationCell(tableCell: TableCell, organizationId) {\n\t  this.orgsService.getOrganizationName(organizationId).subscribe(\n\t\t  organizationName => {\n\t\t\t  tableCell.valueHtml = organizationName;\n\t\t  },\n\t\t  err => {\n\t\t\t  this.notifications.generateNotification('Error', 'Error when trying to get organization', MCNotificationType.Error, err);\n\t\t  }\n\t  );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/components/specifications-table/specifications-table.component.ts","module.exports = \"<mc-table [tableHeaders]=\\\"tableHeaders\\\" [tableRows]=\\\"tableRows\\\" [isLoading]=\\\"isLoading\\\" [onRowClick]=\\\"onRowClick\\\"></mc-table>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/pages/shared/components/specifications-table/specifications-table.html\n// module id = ./src/app/pages/shared/components/specifications-table/specifications-table.html\n// module chunks = 0 1 2 3 4","import { Injectable, OnInit } from '@angular/core';\nimport { Organization } from \"../../../backend-api/identity-registry/autogen/model/Organization\";\nimport { LabelValueModel } from \"../../../theme/components/mcLabelValueTable/mcLabelValueTable.component\";\n\n@Injectable()\nexport class OrganizationViewModelService implements OnInit {\n  constructor() {\n  }\n\n  ngOnInit() {\n\n  }\n  public generateLabelValuesForOrganization(organization:Organization):Array<LabelValueModel>  {\n    var labelValues:Array<LabelValueModel> = undefined;\n    if (organization) {\n      labelValues = [];\n      labelValues.push({label: 'MRN', valueHtml: organization.mrn});\n\t    labelValues.push({label: 'Name', valueHtml: organization.name});\n      labelValues.push({label: 'Address', valueHtml: organization.address});\n      labelValues.push({label: 'Country', valueHtml: organization.country});\n      if (organization.email) {\n        labelValues.push({label: 'Email', valueHtml: \"<a href='mailto:\" + organization.email + \"'>\" + organization.email + \"</a>\"});\n      }\n      if (organization.url) {\n        labelValues.push({label: 'Website', valueHtml: \"<a href='\" + organization.url + \"' target='_blank'>\" + organization.url + \"</a>\"});\n      }\n    }\n    return labelValues;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/services/organization-view-model.service.ts","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { DesignsTableComponent } from \"./components/designs-table/designs-table.component\";\nimport { SpecificationsTableComponent } from \"./components/specifications-table/specifications-table.component\";\nimport { NgaModule } from \"../../theme/nga.module\";\nimport { InstancesTableComponent } from \"./components/instances-table/instances-table.component\";\nimport { SrViewModelService } from \"../org-service-registry/shared/services/sr-view-model.service\";\nimport { CertificatesTableComponent } from \"./components/certificates-table/certificates-table.component\";\nimport { CertificateHelperService } from \"./services/certificate-helper.service\";\nimport { OrganizationDetailsTableComponent } from \"./components/organizaton-details-table/organization-details-table.component\";\nimport { OrganizationViewModelService } from \"./services/organization-view-model.service\";\nimport { CertificateIssueNewComponent } from \"./components/certificate-issue-new/certificate-issue-new.component\";\nimport { ServiceDetailsViewComponent } from \"./components/service-details-view/service-details-view.component\";\nimport { CertificateRevokeComponent } from \"./components/certificate-revoke/certificate-revoke.component\";\nimport { ServiceRegistrySearchComponent } from \"./components/service-registry-search/service-registry-search.component\";\nimport { ReactiveFormsModule } from \"@angular/forms\";\nimport { SrSearchRequestsService } from \"../org-service-registry/shared/services/sr-search-requests.service\";\nimport { EndorsedByListComponent } from \"./components/endorsed-by-list/endorsed-by-list.component\";\nimport { ServicesTableComponent } from \"./components/services-table/services-table.component\";\n\n\n@NgModule({\n  imports: [\n    CommonModule,\n    NgaModule,\n\t  ReactiveFormsModule\n  ],\n  declarations: [\n    DesignsTableComponent,\n    InstancesTableComponent,\n    SpecificationsTableComponent,\n    CertificatesTableComponent,\n    OrganizationDetailsTableComponent,\n    CertificateIssueNewComponent,\n\t  CertificateRevokeComponent,\n\t  ServiceDetailsViewComponent,\n\t  ServiceRegistrySearchComponent,\n\t  EndorsedByListComponent,\n\t  ServicesTableComponent\n  ],\n  exports: [\n    OrganizationDetailsTableComponent,\n    DesignsTableComponent,\n    InstancesTableComponent,\n    SpecificationsTableComponent,\n    CertificatesTableComponent,\n    CertificateIssueNewComponent,\n\t  CertificateRevokeComponent,\n\t  ServiceDetailsViewComponent,\n\t  ServiceRegistrySearchComponent,\n\t  EndorsedByListComponent,\n\t  ServicesTableComponent,\n  ],\n  providers: [\n    SrViewModelService,\n    CertificateHelperService,\n    OrganizationViewModelService,\n\t  SrSearchRequestsService\n  ]\n})\nexport class SharedModule {\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./~/string-replace-loader?{\"search\":\"(System|SystemJS)(.*[//n//r]//s*//.|//.)import//((.+)//)\",\"replace\":\"$1.import($3).then(mod => (mod.__esModule && mod.default) ? mod.default : mod)\",\"flags\":\"g\"}!./src/app/pages/shared/shared.module.ts"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5tIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC10BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACr/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC95CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjrBA;;;;;;;;;;AAUA;;AA0CA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAKA;;;;;;;;;AC1DA;;;;;;;;;;AAUA;;AAgEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAKA;;;;;;;;;;AChFA;AAMA;AACA;AACA;AACA;AAPA;AAAA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;;ACNA;AACA;AAEA;AACA;AACA;AACA;AAcA;AACA;AAZA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AACA;;;;;;;;;;ACrBA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AClBA;AAMA;AACA;AACA;AACA;AAPA;AAAA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AAdA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AACA;;;;;;;;;;ACxBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;ACzBA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAQA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAVA;AACA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA1JA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;AC5BA;;;;;;;ACAA;;;;;;;;;ACAA;AACA;AAEA;AACA;AAkBA;AASA;AAAA;AAAA;AAAA;AAAA;AARA;AAUA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AApHA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;ACtBA;;;;;;;;;ACAA;AACA;AACA;AAOA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA7CA;;;;;;;;;;ACTA;AAIA;AAEA;AADA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAdA;AAAA;;AAAA;AACA;;;;;;;;;;ACJA;AAKA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAzDA;AAAA;;AAAA;AACA;;;;;;;;;;ACTA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;AAeA;AAAA;AAAA;AACA;AAAA;AACA;AAXA;AACA;AAMA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;AAMA;;;;;;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAxaA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;ACpCA;;;;;;;;;ACAA;AACA;AAIA;AACA;AACA;AAIA;AAEA;AACA;AAOA;AAWA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAPA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnGA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;AChCA;;;;;;;;;ACAA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AASA;AASA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAPA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AApIA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAZA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;AC7BA;;;;;;;ACAA;;;;;;;;;ACAA;AAOA;AAIA;AAQA;AAMA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAtEA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AATA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;ACnBA;;;;;;;;;ACAA;AAEA;AACA;AACA;AAEA;AACA;AAQA;AAUA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AA1EA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AATA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;ACfA;;;;;;;;;ACAA;AAOA;AAIA;AACA;AAQA;AAMA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAnFA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AATA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;ACpBA;;;;;;;;;ACAA;AASA;AACA;AACA;AACA;AACA;AAWA;AAUA;AAAA;AAAA;AAAA;AAAA;AARA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA1DA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAXA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;ACxBA;;;;;;;;;ACAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAQA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AACA;AACA;AAIA;AACA;AAOA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAtKA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAEA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAfA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;ACtBA;;;;;;;;;ACAA;AASA;AAIA;AAEA;AAEA;AACA;AACA;AAaA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AACA;AACA;AAYA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAhKA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAbA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;AChCA;;;;;;;ACAA;;;;;;;;;ACAA;AAMA;AAIA;AACA;AAGA;AACA;AAQA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AA3FA;AAAA;;AAAA;AACA;AAAA;;AAAA;AARA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;ACvBA;;;;;;;;;ACAA;AAQA;AACA;AAWA;AAMA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAtEA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AATA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;;;;;ACpBA;;;;;;;;;ACAA;AAKA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AAAA;;AAAA;AACA;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA0CA;AACA;AAxCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;;","sourceRoot":""}